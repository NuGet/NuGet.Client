steps:
- task: PowerShell@1
  displayName: "Print Environment Variables"
  inputs:
    scriptType: "inlineScript"
    inlineScript: |
      Write-Host "##vso[build.updatebuildnumber]$env:FullVstsBuildNumber"
      gci env:* | sort-object name

- task: PowerShell@1
  displayName: "Download Config Files"
  enabled: "false"
  inputs:
    scriptType: "inlineScript"
    inlineScript: |
      $url = $(VstsConfigFileRootUrl) -f 'NuGet.Core.FuncTests.Config'
      Invoke-RestMethod -Method Get -Uri $url -UseDefaultCredentials -OutFile $(Build.Repository.LocalPath)\\NuGet.Core.FuncTests.Config
      $url = $(VstsConfigFileRootUrl) -f 'NuGet.Protocol.FuncTest.Config'
      Invoke-RestMethod -Method Get -Uri $url -UseDefaultCredentials -OutFile $(Build.Repository.LocalPath)\\NuGet.Protocol.FuncTest.Config

- task: PowerShell@1
  displayName: "Run Configure.ps1"
  inputs:
    scriptName: "$(Build.Repository.LocalPath)\\configure.ps1"
    arguments: "-Force -CI"

- task: PowerShell@1
  displayName: "Install Repository Timestamp Certificate" #This is a workaround for the intermittent restore failure(NuGet/Home/issues/11099)
  inputs:
    scriptType: "inlineScript"
    inlineScript: |
      # CN=Symantec SHA256 TimeStamping Signer - G3
      # SHA-256 fingerprint:  C474CE76007D02394E0DA5E4DE7C14C680F9E282013CFEF653EF5DB71FDF61F8
      [string] $certificateBase64 = 'MIIFSzCCBDOgAwIBAgIQe9Tlr7rMBz+hASMEIkFNEjANBgkqhkiG9w0BAQsFADB3MQswCQYDVQQGEwJVUzEdMBsGA1UEChMUU3ltYW50ZWMgQ29ycG9yYXRpb24xHzAdBgNVBAsTFlN5bWFudGVjIFRydXN0IE5ldHdvcmsxKDAmBgNVBAMTH1N5bWFudGVjIFNIQTI1NiBUaW1lU3RhbXBpbmcgQ0EwHhcNMTcxMjIzMDAwMDAwWhcNMjkwMzIyMjM1OTU5WjCBgDELMAkGA1UEBhMCVVMxHTAbBgNVBAoTFFN5bWFudGVjIENvcnBvcmF0aW9uMR8wHQYDVQQLExZTeW1hbnRlYyBUcnVzdCBOZXR3b3JrMTEwLwYDVQQDEyhTeW1hbnRlYyBTSEEyNTYgVGltZVN0YW1waW5nIFNpZ25lciAtIEczMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArw6Kqvjcv2l7VBdxRwm9jTyB+HQVd2eQnP3eTgKeS3b25TY+ZdUkIG0w+d0dg+k/J0ozTm0WiuSNQI0iqr6nCxvSB7Y8tRokKPgbclE9yAmIJgg6+fpDI3VHcAyzX1uPCB1ySFdlTa8CPED39N0yOJM/5Sym81kjy4DeE035EMmqChhsVWFX0fECLMS1q/JsI9KfDQ8ZbK2FYmn9ToXBilIxq1vYyXRS41dsIr9Vf2/KBqs/SrcidmXs7DbylpWBJiz9u5iqATjTryVAmwlT8ClXhVhe6oVIQSGH5d600yaye0BTWHmOUjEGTZQDRcTOPAPstwDyOiLFtG/l77CKmwIDAQABo4IBxzCCAcMwDAYDVR0TAQH/BAIwADBmBgNVHSAEXzBdMFsGC2CGSAGG+EUBBxcDMEwwIwYIKwYBBQUHAgEWF2h0dHBzOi8vZC5zeW1jYi5jb20vY3BzMCUGCCsGAQUFBwICMBkaF2h0dHBzOi8vZC5zeW1jYi5jb20vcnBhMEAGA1UdHwQ5MDcwNaAzoDGGL2h0dHA6Ly90cy1jcmwud3Muc3ltYW50ZWMuY29tL3NoYTI1Ni10c3MtY2EuY3JsMBYGA1UdJQEB/wQMMAoGCCsGAQUFBwMIMA4GA1UdDwEB/wQEAwIHgDB3BggrBgEFBQcBAQRrMGkwKgYIKwYBBQUHMAGGHmh0dHA6Ly90cy1vY3NwLndzLnN5bWFudGVjLmNvbTA7BggrBgEFBQcwAoYvaHR0cDovL3RzLWFpYS53cy5zeW1hbnRlYy5jb20vc2hhMjU2LXRzcy1jYS5jZXIwKAYDVR0RBCEwH6QdMBsxGTAXBgNVBAMTEFRpbWVTdGFtcC0yMDQ4LTYwHQYDVR0OBBYEFKUTAamfhcwbbhYeXzsxqnk2AHsdMB8GA1UdIwQYMBaAFK9j1sqjToVy4Ke8QfMpojh/gHViMA0GCSqGSIb3DQEBCwUAA4IBAQBGnq/wuKJfoplIz6gnSyHNsrmmcnBjL+NVKXs5Rk7nfmUGWIu8V4qSDQjYELo2JPoKe/s702K/SpQV5oLbilRt/yj+Z89xP+YzCdmiWRD0Hkr+Zcze1GvjUil1AEorpczLm+ipTfe0F1mSQcO3P4bm9sB/RDxGXBda46Q71Wkm1SF94YBnfmKst04uFZrlnCOvWxHqcalB+Q15OKmhDc+0sdo+mnrHIsV0zd9HCYbE/JElshuW6YUI6N3qdGBuYKVWeg3IRFjc5vlIFJ7lv94AvXexmBRyFCTfxxEsHwA/w0sUxmcczB4Go5BfXFSLPuMzW4IPxbeGAk5xn+lmRT92'
      [byte[]] $certificateBytes = [System.Convert]::FromBase64String($certificateBase64)
      $certificate = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new($certificateBytes)
      $oid = [System.Security.Cryptography.Oid]::new("1.3.6.1.5.5.7.3.8")
      Function Build-Chain([System.Security.Cryptography.X509Certificates.X509Certificate2] $certificate)
      {
          $chain = [System.Security.Cryptography.X509Certificates.X509Chain]::new()
          Try
          {
              $chain.ChainPolicy.ApplicationPolicy.Add($oid)
              $chain.Build($certificate)
              ForEach ($status In $chain.ChainStatus)
              {
                  If ($status.Status -eq [System.Security.Cryptography.X509Certificates.X509ChainStatusFlags]::UntrustedRoot)
                  {
                      Return $False
                  }
              }
              Return $True
          }
          Finally
          {
              $chain.Dispose()
          }
      }
      Try
      {
          While (!(Build-Chain $certificate))
          {
              Start-Sleep -Seconds 5
          }
      }
      Finally
      {
          $certificate.Dispose()
      }

- task: MSBuild@1
  displayName: "Restore for VS2017"
  inputs:
    solution: "build\\build.proj"
    msbuildVersion: "15.0"
    configuration: "$(BuildConfiguration)"
    msbuildArguments: "/t:RestoreVS15 /p:BuildNumber=$(BuildNumber) /p:BuildRTM=false /v:m"

- task: MSBuild@1
  displayName: "Run Functional Tests"
  continueOnError: "true"
  inputs:
    solution: "build\\build.proj"
    msbuildVersion: "15.0"
    configuration: "$(BuildConfiguration)"
    msbuildArguments: "/t:CoreFuncTests  /p:BuildRTM=false  /p:BuildNumber=$(BuildNumber) /p:TestResultOutputFormat=xml /p:NUGET_PFX_PATH=$(Build.Repository.LocalPath)\\keys\\NuGetKey.snk /p:MS_PFX_PATH=$(Build.Repository.LocalPath)\\keys\\35MSSharedLib1024.snk"

- task: PublishTestResults@2
  displayName: "Publish Test Results"
  continueOnError: "true"
  inputs:
    testRunner: "XUnit"
    testResultsFiles: "*.xml"
    searchFolder: "$(Build.Repository.LocalPath)\\build\\TestResults"
    mergeTestResults: "true"
    testRunTitle: "NuGet.Client Functional Tests On Windows"
  condition: "succeededOrFailed()"

- task: PowerShell@1
  displayName: "Initialize Git Commit Status on GitHub"
  inputs:
    scriptType: "inlineScript"
    arguments: "-VstsPersonalAccessToken $(VstsPersonalAccessToken)"
    inlineScript: |
      . $(Build.Repository.LocalPath)\\scripts\\utils\\PostGitCommitStatus.ps1
      SetCommitStatusForTestResult -PersonalAccessToken $(NuGetLurkerPersonalAccessToken) -CommitSha $(Build.SourceVersion) -VstsPersonalAccessToken $(VstsPersonalAccessToken) -TestName "Functional Tests On Windows"
  condition: "not(eq(variables['ManualGitHubChecks'], 'false'))"
