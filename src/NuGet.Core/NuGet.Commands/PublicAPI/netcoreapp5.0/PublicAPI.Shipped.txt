Microsoft.AspNet.FileProviders.IDirectoryContents
Microsoft.AspNet.FileProviders.IDirectoryContents.Exists.get -> bool
Microsoft.AspNet.FileProviders.IFileInfo
Microsoft.AspNet.FileProviders.IFileInfo.CreateReadStream() -> System.IO.Stream
Microsoft.AspNet.FileProviders.IFileInfo.Exists.get -> bool
Microsoft.AspNet.FileProviders.IFileInfo.IsDirectory.get -> bool
Microsoft.AspNet.FileProviders.IFileInfo.LastModified.get -> System.DateTimeOffset
Microsoft.AspNet.FileProviders.IFileInfo.Length.get -> long
Microsoft.AspNet.FileProviders.IFileInfo.Name.get -> string
Microsoft.AspNet.FileProviders.IFileInfo.PhysicalPath.get -> string
Microsoft.AspNet.FileProviders.IFileProvider
Microsoft.AspNet.FileProviders.IFileProvider.GetDirectoryContents(string subpath) -> Microsoft.AspNet.FileProviders.IDirectoryContents
Microsoft.AspNet.FileProviders.IFileProvider.GetFileInfo(string subpath) -> Microsoft.AspNet.FileProviders.IFileInfo
Microsoft.AspNet.FileProviders.IFileProvider.Watch(string filter) -> Microsoft.Extensions.Primitives.IChangeToken
Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase
Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase.DirectoryInfoBase() -> void
Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoWrapper
Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoWrapper.DirectoryInfoWrapper(System.IO.DirectoryInfo directoryInfo, bool isParentPath = false) -> void
Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase
Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase.FileInfoBase() -> void
Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoWrapper
Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoWrapper.FileInfoWrapper(System.IO.FileInfo fileInfo) -> void
Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileSystemInfoBase
Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileSystemInfoBase.FileSystemInfoBase() -> void
Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch
Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch.Equals(Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch other) -> bool
Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch.FilePatternMatch(string path, string stem) -> void
Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch.Path.get -> string
Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch.Stem.get -> string
Microsoft.Extensions.FileSystemGlobbing.Internal.ILinearPattern
Microsoft.Extensions.FileSystemGlobbing.Internal.ILinearPattern.Segments.get -> System.Collections.Generic.IList<Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment>
Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment
Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment.CanProduceStem.get -> bool
Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment.Match(string value) -> bool
Microsoft.Extensions.FileSystemGlobbing.Internal.IPattern
Microsoft.Extensions.FileSystemGlobbing.Internal.IPattern.CreatePatternContextForExclude() -> Microsoft.Extensions.FileSystemGlobbing.Internal.IPatternContext
Microsoft.Extensions.FileSystemGlobbing.Internal.IPattern.CreatePatternContextForInclude() -> Microsoft.Extensions.FileSystemGlobbing.Internal.IPatternContext
Microsoft.Extensions.FileSystemGlobbing.Internal.IPatternContext
Microsoft.Extensions.FileSystemGlobbing.Internal.IPatternContext.Declare(System.Action<Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment, bool> onDeclare) -> void
Microsoft.Extensions.FileSystemGlobbing.Internal.IPatternContext.PopDirectory() -> void
Microsoft.Extensions.FileSystemGlobbing.Internal.IPatternContext.PushDirectory(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase directory) -> void
Microsoft.Extensions.FileSystemGlobbing.Internal.IPatternContext.Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase directory) -> bool
Microsoft.Extensions.FileSystemGlobbing.Internal.IPatternContext.Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase file) -> Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult
Microsoft.Extensions.FileSystemGlobbing.Internal.IRaggedPattern
Microsoft.Extensions.FileSystemGlobbing.Internal.IRaggedPattern.Contains.get -> System.Collections.Generic.IList<System.Collections.Generic.IList<Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment>>
Microsoft.Extensions.FileSystemGlobbing.Internal.IRaggedPattern.EndsWith.get -> System.Collections.Generic.IList<Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment>
Microsoft.Extensions.FileSystemGlobbing.Internal.IRaggedPattern.Segments.get -> System.Collections.Generic.IList<Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment>
Microsoft.Extensions.FileSystemGlobbing.Internal.IRaggedPattern.StartsWith.get -> System.Collections.Generic.IList<Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment>
Microsoft.Extensions.FileSystemGlobbing.Internal.MatcherContext
Microsoft.Extensions.FileSystemGlobbing.Internal.MatcherContext.Execute() -> Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult
Microsoft.Extensions.FileSystemGlobbing.Internal.MatcherContext.MatcherContext(System.Collections.Generic.IEnumerable<Microsoft.Extensions.FileSystemGlobbing.Internal.IPattern> includePatterns, System.Collections.Generic.IEnumerable<Microsoft.Extensions.FileSystemGlobbing.Internal.IPattern> excludePatterns, Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase directoryInfo, System.StringComparison comparison) -> void
Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.CurrentPathSegment
Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.CurrentPathSegment.CanProduceStem.get -> bool
Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.CurrentPathSegment.CurrentPathSegment() -> void
Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.CurrentPathSegment.Match(string value) -> bool
Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.LiteralPathSegment
Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.LiteralPathSegment.CanProduceStem.get -> bool
Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.LiteralPathSegment.LiteralPathSegment(string value, System.StringComparison comparisonType) -> void
Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.LiteralPathSegment.Match(string value) -> bool
Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.LiteralPathSegment.Value.get -> string
Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.ParentPathSegment
Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.ParentPathSegment.CanProduceStem.get -> bool
Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.ParentPathSegment.Match(string value) -> bool
Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.ParentPathSegment.ParentPathSegment() -> void
Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.RecursiveWildcardSegment
Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.RecursiveWildcardSegment.CanProduceStem.get -> bool
Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.RecursiveWildcardSegment.Match(string value) -> bool
Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.RecursiveWildcardSegment.RecursiveWildcardSegment() -> void
Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.WildcardPathSegment
Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.WildcardPathSegment.BeginsWith.get -> string
Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.WildcardPathSegment.CanProduceStem.get -> bool
Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.WildcardPathSegment.Contains.get -> System.Collections.Generic.List<string>
Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.WildcardPathSegment.EndsWith.get -> string
Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.WildcardPathSegment.Match(string value) -> bool
Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.WildcardPathSegment.WildcardPathSegment(string beginsWith, System.Collections.Generic.List<string> contains, string endsWith, System.StringComparison comparisonType) -> void
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContext<TFrame>
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContext<TFrame>.Frame -> TFrame
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContext<TFrame>.IsStackEmpty() -> bool
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContext<TFrame>.PatternContext() -> void
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContext<TFrame>.PopDirectory() -> void
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContext<TFrame>.PushDataFrame(TFrame frame) -> void
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear.CalculateStem(Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase matchedFile) -> string
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear.FrameData
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear.FrameData.FrameData() -> void
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear.FrameData.InStem -> bool
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear.FrameData.IsNotApplicable -> bool
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear.FrameData.SegmentIndex -> int
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear.FrameData.Stem.get -> string
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear.FrameData.StemItems.get -> System.Collections.Generic.IList<string>
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear.IsLastSegment() -> bool
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear.Pattern.get -> Microsoft.Extensions.FileSystemGlobbing.Internal.ILinearPattern
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear.PatternContextLinear(Microsoft.Extensions.FileSystemGlobbing.Internal.ILinearPattern pattern) -> void
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear.TestMatchingSegment(string value) -> bool
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinearExclude
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinearExclude.PatternContextLinearExclude(Microsoft.Extensions.FileSystemGlobbing.Internal.ILinearPattern pattern) -> void
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinearInclude
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinearInclude.PatternContextLinearInclude(Microsoft.Extensions.FileSystemGlobbing.Internal.ILinearPattern pattern) -> void
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged.CalculateStem(Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase matchedFile) -> string
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged.FrameData
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged.FrameData.BacktrackAvailable -> int
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged.FrameData.FrameData() -> void
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged.FrameData.InStem -> bool
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged.FrameData.IsNotApplicable -> bool
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged.FrameData.SegmentGroup -> System.Collections.Generic.IList<Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment>
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged.FrameData.SegmentGroupIndex -> int
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged.FrameData.SegmentIndex -> int
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged.FrameData.Stem.get -> string
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged.FrameData.StemItems.get -> System.Collections.Generic.IList<string>
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged.IsEndingGroup() -> bool
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged.IsStartingGroup() -> bool
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged.Pattern.get -> Microsoft.Extensions.FileSystemGlobbing.Internal.IRaggedPattern
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged.PatternContextRagged(Microsoft.Extensions.FileSystemGlobbing.Internal.IRaggedPattern pattern) -> void
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged.TestMatchingGroup(Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileSystemInfoBase value) -> bool
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged.TestMatchingSegment(string value) -> bool
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRaggedExclude
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRaggedExclude.PatternContextRaggedExclude(Microsoft.Extensions.FileSystemGlobbing.Internal.IRaggedPattern pattern) -> void
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRaggedInclude
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRaggedInclude.PatternContextRaggedInclude(Microsoft.Extensions.FileSystemGlobbing.Internal.IRaggedPattern pattern) -> void
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult.IsSuccessful.get -> bool
Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult.Stem.get -> string
Microsoft.Extensions.FileSystemGlobbing.Internal.Patterns.PatternBuilder
Microsoft.Extensions.FileSystemGlobbing.Internal.Patterns.PatternBuilder.Build(string pattern) -> Microsoft.Extensions.FileSystemGlobbing.Internal.IPattern
Microsoft.Extensions.FileSystemGlobbing.Internal.Patterns.PatternBuilder.ComparisonType.get -> System.StringComparison
Microsoft.Extensions.FileSystemGlobbing.Internal.Patterns.PatternBuilder.PatternBuilder() -> void
Microsoft.Extensions.FileSystemGlobbing.Internal.Patterns.PatternBuilder.PatternBuilder(System.StringComparison comparisonType) -> void
Microsoft.Extensions.FileSystemGlobbing.Matcher
Microsoft.Extensions.FileSystemGlobbing.Matcher.Matcher() -> void
Microsoft.Extensions.FileSystemGlobbing.Matcher.Matcher(System.StringComparison comparisonType) -> void
Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions
Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult
Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult.Files.get -> System.Collections.Generic.IEnumerable<Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch>
Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult.Files.set -> void
Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult.PatternMatchingResult(System.Collections.Generic.IEnumerable<Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch> files) -> void
Microsoft.Extensions.Primitives.IChangeToken
Microsoft.Extensions.Primitives.IChangeToken.ActiveChangeCallbacks.get -> bool
Microsoft.Extensions.Primitives.IChangeToken.HasChanged.get -> bool
Microsoft.Extensions.Primitives.IChangeToken.RegisterChangeCallback(System.Action<object> callback, object state) -> System.IDisposable
NuGet.Commands.AddClientCertArgs
NuGet.Commands.AddClientCertArgs.AddClientCertArgs() -> void
NuGet.Commands.AddClientCertArgs.Configfile.get -> string
NuGet.Commands.AddClientCertArgs.Configfile.set -> void
NuGet.Commands.AddClientCertArgs.FindBy.get -> string
NuGet.Commands.AddClientCertArgs.FindBy.set -> void
NuGet.Commands.AddClientCertArgs.FindValue.get -> string
NuGet.Commands.AddClientCertArgs.FindValue.set -> void
NuGet.Commands.AddClientCertArgs.Force.get -> bool
NuGet.Commands.AddClientCertArgs.Force.set -> void
NuGet.Commands.AddClientCertArgs.PackageSource.get -> string
NuGet.Commands.AddClientCertArgs.PackageSource.set -> void
NuGet.Commands.AddClientCertArgs.Password.get -> string
NuGet.Commands.AddClientCertArgs.Password.set -> void
NuGet.Commands.AddClientCertArgs.Path.get -> string
NuGet.Commands.AddClientCertArgs.Path.set -> void
NuGet.Commands.AddClientCertArgs.StoreLocation.get -> string
NuGet.Commands.AddClientCertArgs.StoreLocation.set -> void
NuGet.Commands.AddClientCertArgs.StoreName.get -> string
NuGet.Commands.AddClientCertArgs.StoreName.set -> void
NuGet.Commands.AddClientCertArgs.StorePasswordInClearText.get -> bool
NuGet.Commands.AddClientCertArgs.StorePasswordInClearText.set -> void
NuGet.Commands.AddClientCertRunner
NuGet.Commands.AddSourceArgs
NuGet.Commands.AddSourceArgs.AddSourceArgs() -> void
NuGet.Commands.AddSourceArgs.Configfile.get -> string
NuGet.Commands.AddSourceArgs.Configfile.set -> void
NuGet.Commands.AddSourceArgs.Name.get -> string
NuGet.Commands.AddSourceArgs.Name.set -> void
NuGet.Commands.AddSourceArgs.Password.get -> string
NuGet.Commands.AddSourceArgs.Password.set -> void
NuGet.Commands.AddSourceArgs.Source.get -> string
NuGet.Commands.AddSourceArgs.Source.set -> void
NuGet.Commands.AddSourceArgs.StorePasswordInClearText.get -> bool
NuGet.Commands.AddSourceArgs.StorePasswordInClearText.set -> void
NuGet.Commands.AddSourceArgs.Username.get -> string
NuGet.Commands.AddSourceArgs.Username.set -> void
NuGet.Commands.AddSourceArgs.ValidAuthenticationTypes.get -> string
NuGet.Commands.AddSourceArgs.ValidAuthenticationTypes.set -> void
NuGet.Commands.AddSourceRunner
NuGet.Commands.AddSourceRunner.AddSourceRunner() -> void
NuGet.Commands.AssetTargetFallbackUtility
NuGet.Commands.BuildAssetsUtils
NuGet.Commands.ClientCertArgsExtensions
NuGet.Commands.CommandException
NuGet.Commands.CommandException.CommandException() -> void
NuGet.Commands.CommandException.CommandException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
NuGet.Commands.CommandException.CommandException(string format, params object[] args) -> void
NuGet.Commands.CommandException.CommandException(string message) -> void
NuGet.Commands.CommandException.CommandException(string message, System.Exception exception) -> void
NuGet.Commands.CompatibilityCheckResult
NuGet.Commands.CompatibilityCheckResult.CompatibilityCheckResult(NuGet.Commands.RestoreTargetGraph graph, System.Collections.Generic.IEnumerable<NuGet.Commands.CompatibilityIssue> issues) -> void
NuGet.Commands.CompatibilityCheckResult.Graph.get -> NuGet.Commands.RestoreTargetGraph
NuGet.Commands.CompatibilityCheckResult.Issues.get -> System.Collections.Generic.IReadOnlyList<NuGet.Commands.CompatibilityIssue>
NuGet.Commands.CompatibilityCheckResult.Success.get -> bool
NuGet.Commands.CompatibilityIssue
NuGet.Commands.CompatibilityIssue.AssemblyName.get -> string
NuGet.Commands.CompatibilityIssue.AvailableFrameworkRuntimePairs.get -> System.Collections.Generic.List<NuGet.Frameworks.FrameworkRuntimePair>
NuGet.Commands.CompatibilityIssue.AvailableFrameworks.get -> System.Collections.Generic.List<NuGet.Frameworks.NuGetFramework>
NuGet.Commands.CompatibilityIssue.Equals(NuGet.Commands.CompatibilityIssue other) -> bool
NuGet.Commands.CompatibilityIssue.Format() -> string
NuGet.Commands.CompatibilityIssue.Framework.get -> NuGet.Frameworks.NuGetFramework
NuGet.Commands.CompatibilityIssue.Package.get -> NuGet.Packaging.Core.PackageIdentity
NuGet.Commands.CompatibilityIssue.RuntimeIdentifier.get -> string
NuGet.Commands.CompatibilityIssue.Type.get -> NuGet.Commands.CompatibilityIssueType
NuGet.Commands.CompatibilityIssueType
NuGet.Commands.CompatibilityIssueType.IncompatiblePackageWithDotnetTool = 5 -> NuGet.Commands.CompatibilityIssueType
NuGet.Commands.CompatibilityIssueType.PackageIncompatible = 1 -> NuGet.Commands.CompatibilityIssueType
NuGet.Commands.CompatibilityIssueType.PackageToolsAssetsIncompatible = 3 -> NuGet.Commands.CompatibilityIssueType
NuGet.Commands.CompatibilityIssueType.PackageTypeIncompatible = 7 -> NuGet.Commands.CompatibilityIssueType
NuGet.Commands.CompatibilityIssueType.ProjectIncompatible = 2 -> NuGet.Commands.CompatibilityIssueType
NuGet.Commands.CompatibilityIssueType.ProjectWithIncorrectDependencyCount = 4 -> NuGet.Commands.CompatibilityIssueType
NuGet.Commands.CompatibilityIssueType.ReferenceAssemblyNotImplemented = 0 -> NuGet.Commands.CompatibilityIssueType
NuGet.Commands.CompatibilityIssueType.ToolsPackageWithExtraPackageTypes = 6 -> NuGet.Commands.CompatibilityIssueType
NuGet.Commands.ContentMetadata
NuGet.Commands.ContentMetadata.BuildAction.get -> string
NuGet.Commands.ContentMetadata.BuildAction.set -> void
NuGet.Commands.ContentMetadata.ContentMetadata() -> void
NuGet.Commands.ContentMetadata.CopyToOutput.get -> string
NuGet.Commands.ContentMetadata.CopyToOutput.set -> void
NuGet.Commands.ContentMetadata.Flatten.get -> string
NuGet.Commands.ContentMetadata.Flatten.set -> void
NuGet.Commands.ContentMetadata.Source.get -> string
NuGet.Commands.ContentMetadata.Source.set -> void
NuGet.Commands.ContentMetadata.Target.get -> string
NuGet.Commands.ContentMetadata.Target.set -> void
NuGet.Commands.DeleteRunner
NuGet.Commands.DependencyGraphFileRequestProvider
NuGet.Commands.DependencyGraphFileRequestProvider.DependencyGraphFileRequestProvider(NuGet.Commands.RestoreCommandProvidersCache providerCache) -> void
NuGet.Commands.DependencyGraphSpecRequestProvider
NuGet.Commands.DependencyGraphSpecRequestProvider.CreateRequests(NuGet.Commands.RestoreArgs restoreContext) -> System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<NuGet.Commands.RestoreSummaryRequest>>
NuGet.Commands.DependencyGraphSpecRequestProvider.DependencyGraphSpecRequestProvider(NuGet.Commands.RestoreCommandProvidersCache providerCache, NuGet.ProjectModel.DependencyGraphSpec dgFile) -> void
NuGet.Commands.DiagnosticUtility
NuGet.Commands.DisableSourceArgs
NuGet.Commands.DisableSourceArgs.Configfile.get -> string
NuGet.Commands.DisableSourceArgs.Configfile.set -> void
NuGet.Commands.DisableSourceArgs.DisableSourceArgs() -> void
NuGet.Commands.DisableSourceArgs.Name.get -> string
NuGet.Commands.DisableSourceArgs.Name.set -> void
NuGet.Commands.DisableSourceRunner
NuGet.Commands.DisableSourceRunner.DisableSourceRunner() -> void
NuGet.Commands.DownloadDependencyResolutionResult
NuGet.Commands.DownloadDependencyResolutionResult.Dependencies.get -> System.Collections.Generic.IList<System.Tuple<NuGet.LibraryModel.LibraryRange, NuGet.DependencyResolver.RemoteMatch>>
NuGet.Commands.DownloadDependencyResolutionResult.Framework.get -> NuGet.Frameworks.NuGetFramework
NuGet.Commands.DownloadDependencyResolutionResult.Install.get -> System.Collections.Generic.ISet<NuGet.DependencyResolver.RemoteMatch>
NuGet.Commands.DownloadDependencyResolutionResult.Unresolved.get -> System.Collections.Generic.ISet<NuGet.LibraryModel.LibraryRange>
NuGet.Commands.EnableSourceArgs
NuGet.Commands.EnableSourceArgs.Configfile.get -> string
NuGet.Commands.EnableSourceArgs.Configfile.set -> void
NuGet.Commands.EnableSourceArgs.EnableSourceArgs() -> void
NuGet.Commands.EnableSourceArgs.Name.get -> string
NuGet.Commands.EnableSourceArgs.Name.set -> void
NuGet.Commands.EnableSourceRunner
NuGet.Commands.EnableSourceRunner.EnableSourceRunner() -> void
NuGet.Commands.IClientCertArgsWithConfigFile
NuGet.Commands.IClientCertArgsWithConfigFile.Configfile.get -> string
NuGet.Commands.IClientCertArgsWithConfigFile.Configfile.set -> void
NuGet.Commands.IClientCertArgsWithFileData
NuGet.Commands.IClientCertArgsWithFileData.Password.get -> string
NuGet.Commands.IClientCertArgsWithFileData.Password.set -> void
NuGet.Commands.IClientCertArgsWithFileData.Path.get -> string
NuGet.Commands.IClientCertArgsWithFileData.Path.set -> void
NuGet.Commands.IClientCertArgsWithFileData.StorePasswordInClearText.get -> bool
NuGet.Commands.IClientCertArgsWithFileData.StorePasswordInClearText.set -> void
NuGet.Commands.IClientCertArgsWithForce
NuGet.Commands.IClientCertArgsWithForce.Force.get -> bool
NuGet.Commands.IClientCertArgsWithForce.Force.set -> void
NuGet.Commands.IClientCertArgsWithPackageSource
NuGet.Commands.IClientCertArgsWithPackageSource.PackageSource.get -> string
NuGet.Commands.IClientCertArgsWithPackageSource.PackageSource.set -> void
NuGet.Commands.IClientCertArgsWithStoreData
NuGet.Commands.IClientCertArgsWithStoreData.FindBy.get -> string
NuGet.Commands.IClientCertArgsWithStoreData.FindBy.set -> void
NuGet.Commands.IClientCertArgsWithStoreData.FindValue.get -> string
NuGet.Commands.IClientCertArgsWithStoreData.FindValue.set -> void
NuGet.Commands.IClientCertArgsWithStoreData.StoreLocation.get -> string
NuGet.Commands.IClientCertArgsWithStoreData.StoreLocation.set -> void
NuGet.Commands.IClientCertArgsWithStoreData.StoreName.get -> string
NuGet.Commands.IClientCertArgsWithStoreData.StoreName.set -> void
NuGet.Commands.IListCommandRunner
NuGet.Commands.IListCommandRunner.ExecuteCommand(NuGet.Commands.ListArgs listArgs) -> System.Threading.Tasks.Task
NuGet.Commands.ILocalsCommandRunner
NuGet.Commands.ILocalsCommandRunner.ExecuteCommand(NuGet.Commands.LocalsArgs localsArgs) -> void
NuGet.Commands.IMSBuildItem
NuGet.Commands.IMSBuildItem.GetProperty(string property) -> string
NuGet.Commands.IMSBuildItem.GetProperty(string property, bool trim) -> string
NuGet.Commands.IMSBuildItem.Identity.get -> string
NuGet.Commands.IMSBuildItem.Properties.get -> System.Collections.Generic.IReadOnlyList<string>
NuGet.Commands.IPreLoadedRestoreRequestProvider
NuGet.Commands.IPreLoadedRestoreRequestProvider.CreateRequests(NuGet.Commands.RestoreArgs restoreContext) -> System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<NuGet.Commands.RestoreSummaryRequest>>
NuGet.Commands.IProjectFactory
NuGet.Commands.IProjectFactory.CreateBuilder(string basePath, NuGet.Versioning.NuGetVersion version, string suffix, bool buildIfNeeded, NuGet.Packaging.PackageBuilder builder = null) -> NuGet.Packaging.PackageBuilder
NuGet.Commands.IProjectFactory.GetProjectProperties() -> System.Collections.Generic.Dictionary<string, string>
NuGet.Commands.IProjectFactory.GetWarningPropertiesForProject() -> NuGet.ProjectModel.WarningProperties
NuGet.Commands.IProjectFactory.Logger.get -> NuGet.Common.ILogger
NuGet.Commands.IProjectFactory.Logger.set -> void
NuGet.Commands.IProjectFactory.SetIncludeSymbols(bool includeSymbols) -> void
NuGet.Commands.IRestoreRequestProvider
NuGet.Commands.IRestoreRequestProvider.CreateRequests(string inputPath, NuGet.Commands.RestoreArgs restoreContext) -> System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<NuGet.Commands.RestoreSummaryRequest>>
NuGet.Commands.IRestoreRequestProvider.Supports(string path) -> System.Threading.Tasks.Task<bool>
NuGet.Commands.IRestoreResult
NuGet.Commands.IRestoreResult.LockFile.get -> NuGet.ProjectModel.LockFile
NuGet.Commands.IRestoreResult.LockFilePath.get -> string
NuGet.Commands.IRestoreResult.MSBuildOutputFiles.get -> System.Collections.Generic.IEnumerable<NuGet.Commands.MSBuildOutputFile>
NuGet.Commands.IRestoreResult.PreviousLockFile.get -> NuGet.ProjectModel.LockFile
NuGet.Commands.IRestoreResult.Success.get -> bool
NuGet.Commands.IRestoreTargetGraph
NuGet.Commands.IRestoreTargetGraph.AnalyzeResult.get -> NuGet.DependencyResolver.AnalyzeResult<NuGet.DependencyResolver.RemoteResolveResult>
NuGet.Commands.IRestoreTargetGraph.Conflicts.get -> System.Collections.Generic.IEnumerable<NuGet.Commands.ResolverConflict>
NuGet.Commands.IRestoreTargetGraph.Conventions.get -> NuGet.Client.ManagedCodeConventions
NuGet.Commands.IRestoreTargetGraph.Flattened.get -> System.Collections.Generic.ISet<NuGet.DependencyResolver.GraphItem<NuGet.DependencyResolver.RemoteResolveResult>>
NuGet.Commands.IRestoreTargetGraph.Framework.get -> NuGet.Frameworks.NuGetFramework
NuGet.Commands.IRestoreTargetGraph.Graphs.get -> System.Collections.Generic.IEnumerable<NuGet.DependencyResolver.GraphNode<NuGet.DependencyResolver.RemoteResolveResult>>
NuGet.Commands.IRestoreTargetGraph.InConflict.get -> bool
NuGet.Commands.IRestoreTargetGraph.Install.get -> System.Collections.Generic.ISet<NuGet.DependencyResolver.RemoteMatch>
NuGet.Commands.IRestoreTargetGraph.Name.get -> string
NuGet.Commands.IRestoreTargetGraph.ResolvedDependencies.get -> System.Collections.Generic.ISet<NuGet.Commands.ResolvedDependencyKey>
NuGet.Commands.IRestoreTargetGraph.RuntimeGraph.get -> NuGet.RuntimeModel.RuntimeGraph
NuGet.Commands.IRestoreTargetGraph.RuntimeIdentifier.get -> string
NuGet.Commands.IRestoreTargetGraph.TargetGraphName.get -> string
NuGet.Commands.IRestoreTargetGraph.Unresolved.get -> System.Collections.Generic.ISet<NuGet.LibraryModel.LibraryRange>
NuGet.Commands.ISignCommandRunner
NuGet.Commands.ISignCommandRunner.ExecuteCommandAsync(NuGet.Commands.SignArgs signArgs) -> System.Threading.Tasks.Task<int>
NuGet.Commands.ITrustedSignersCommandRunner
NuGet.Commands.ITrustedSignersCommandRunner.ExecuteCommandAsync(NuGet.Commands.TrustedSignersArgs trustedSignersArgs) -> System.Threading.Tasks.Task<int>
NuGet.Commands.IVerifyCommandRunner
NuGet.Commands.IVerifyCommandRunner.ExecuteCommandAsync(NuGet.Commands.VerifyArgs verifyArgs) -> System.Threading.Tasks.Task<int>
NuGet.Commands.IndexedRestoreTargetGraph
NuGet.Commands.IndexedRestoreTargetGraph.GetItemById(string id) -> NuGet.DependencyResolver.GraphItem<NuGet.DependencyResolver.RemoteResolveResult>
NuGet.Commands.IndexedRestoreTargetGraph.GetItemById(string id, NuGet.LibraryModel.LibraryType libraryType) -> NuGet.DependencyResolver.GraphItem<NuGet.DependencyResolver.RemoteResolveResult>
NuGet.Commands.IndexedRestoreTargetGraph.Graph.get -> NuGet.Commands.IRestoreTargetGraph
NuGet.Commands.IndexedRestoreTargetGraph.HasErrors(string id) -> bool
NuGet.Commands.ListArgs
NuGet.Commands.ListArgs.AllVersions.get -> bool
NuGet.Commands.ListArgs.Arguments.get -> System.Collections.Generic.IList<string>
NuGet.Commands.ListArgs.CancellationToken.get -> System.Threading.CancellationToken
NuGet.Commands.ListArgs.IncludeDelisted.get -> bool
NuGet.Commands.ListArgs.IsDetailed.get -> bool
NuGet.Commands.ListArgs.ListArgs(System.Collections.Generic.IList<string> arguments, System.Collections.Generic.IList<NuGet.Configuration.PackageSource> listEndpoints, NuGet.Configuration.ISettings settings, NuGet.Common.ILogger logger, NuGet.Commands.ListArgs.Log printJustified, bool isDetailedl, string listCommandNoPackages, string listCommandLicenseUrl, string listCommandListNotSupported, bool allVersions, bool includeDelisted, bool prerelease, System.Threading.CancellationToken token) -> void
NuGet.Commands.ListArgs.ListCommandLicenseUrl.get -> string
NuGet.Commands.ListArgs.ListCommandListNotSupported.get -> string
NuGet.Commands.ListArgs.ListCommandNoPackages.get -> string
NuGet.Commands.ListArgs.ListEndpoints.get -> System.Collections.Generic.IList<NuGet.Configuration.PackageSource>
NuGet.Commands.ListArgs.Log
NuGet.Commands.ListArgs.Logger.get -> NuGet.Common.ILogger
NuGet.Commands.ListArgs.Prerelease.get -> bool
NuGet.Commands.ListArgs.PrintJustified.get -> NuGet.Commands.ListArgs.Log
NuGet.Commands.ListArgs.Settings.get -> NuGet.Configuration.ISettings
NuGet.Commands.ListClientCertArgs
NuGet.Commands.ListClientCertArgs.Configfile.get -> string
NuGet.Commands.ListClientCertArgs.Configfile.set -> void
NuGet.Commands.ListClientCertArgs.ListClientCertArgs() -> void
NuGet.Commands.ListClientCertRunner
NuGet.Commands.ListCommandRunner
NuGet.Commands.ListCommandRunner.ExecuteCommand(NuGet.Commands.ListArgs listArgs) -> System.Threading.Tasks.Task
NuGet.Commands.ListCommandRunner.ListCommandRunner() -> void
NuGet.Commands.ListSourceArgs
NuGet.Commands.ListSourceArgs.Configfile.get -> string
NuGet.Commands.ListSourceArgs.Configfile.set -> void
NuGet.Commands.ListSourceArgs.Format.get -> string
NuGet.Commands.ListSourceArgs.Format.set -> void
NuGet.Commands.ListSourceArgs.ListSourceArgs() -> void
NuGet.Commands.ListSourceRunner
NuGet.Commands.ListSourceRunner.ListSourceRunner() -> void
NuGet.Commands.LocalsArgs
NuGet.Commands.LocalsArgs.Arguments.get -> System.Collections.Generic.IList<string>
NuGet.Commands.LocalsArgs.Clear.get -> bool
NuGet.Commands.LocalsArgs.List.get -> bool
NuGet.Commands.LocalsArgs.LocalsArgs(System.Collections.Generic.IList<string> arguments, NuGet.Configuration.ISettings settings, NuGet.Commands.LocalsArgs.Log logInformation, NuGet.Commands.LocalsArgs.Log logError, bool clear, bool list) -> void
NuGet.Commands.LocalsArgs.Log
NuGet.Commands.LocalsArgs.LogError.get -> NuGet.Commands.LocalsArgs.Log
NuGet.Commands.LocalsArgs.LogInformation.get -> NuGet.Commands.LocalsArgs.Log
NuGet.Commands.LocalsArgs.Settings.get -> NuGet.Configuration.ISettings
NuGet.Commands.LocalsCommandRunner
NuGet.Commands.LocalsCommandRunner.ExecuteCommand(NuGet.Commands.LocalsArgs localsArgs) -> void
NuGet.Commands.LocalsCommandRunner.LocalsCommandRunner() -> void
NuGet.Commands.LockFileBuilder
NuGet.Commands.LockFileBuilder.CreateLockFile(NuGet.ProjectModel.LockFile previousLockFile, NuGet.ProjectModel.PackageSpec project, System.Collections.Generic.IEnumerable<NuGet.Commands.RestoreTargetGraph> targetGraphs, System.Collections.Generic.IReadOnlyList<NuGet.Repositories.NuGetv3LocalRepository> localRepositories, NuGet.DependencyResolver.RemoteWalkContext context) -> NuGet.ProjectModel.LockFile
NuGet.Commands.LockFileBuilder.LockFileBuilder(int lockFileVersion, NuGet.Common.ILogger logger, System.Collections.Generic.Dictionary<NuGet.Commands.RestoreTargetGraph, System.Collections.Generic.Dictionary<string, NuGet.LibraryModel.LibraryIncludeFlags>> includeFlagGraphs) -> void
NuGet.Commands.LockFileBuilderCache
NuGet.Commands.LockFileBuilderCache.GetContentItems(NuGet.ProjectModel.LockFileLibrary library, NuGet.Repositories.LocalPackageInfo package) -> NuGet.ContentModel.ContentItemCollection
NuGet.Commands.LockFileBuilderCache.GetSelectionCriteria(NuGet.Commands.RestoreTargetGraph graph, NuGet.Frameworks.NuGetFramework framework) -> System.Collections.Generic.List<System.Collections.Generic.List<NuGet.ContentModel.SelectionCriteria>>
NuGet.Commands.LockFileBuilderCache.LockFileBuilderCache() -> void
NuGet.Commands.LockFileUtils
NuGet.Commands.MSBuildItem
NuGet.Commands.MSBuildItem.GetProperty(string property) -> string
NuGet.Commands.MSBuildItem.GetProperty(string property, bool trim) -> string
NuGet.Commands.MSBuildItem.Identity.get -> string
NuGet.Commands.MSBuildItem.MSBuildItem(string identity, System.Collections.Generic.IDictionary<string, string> metadata) -> void
NuGet.Commands.MSBuildItem.Properties.get -> System.Collections.Generic.IReadOnlyList<string>
NuGet.Commands.MSBuildOutputFile
NuGet.Commands.MSBuildOutputFile.Content.get -> System.Xml.Linq.XDocument
NuGet.Commands.MSBuildOutputFile.MSBuildOutputFile(string path, System.Xml.Linq.XDocument content) -> void
NuGet.Commands.MSBuildOutputFile.Path.get -> string
NuGet.Commands.MSBuildPackTargetArgs
NuGet.Commands.MSBuildPackTargetArgs.AllowedOutputExtensionsInPackageBuildOutputFolder.get -> System.Collections.Generic.HashSet<string>
NuGet.Commands.MSBuildPackTargetArgs.AllowedOutputExtensionsInPackageBuildOutputFolder.set -> void
NuGet.Commands.MSBuildPackTargetArgs.AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder.get -> System.Collections.Generic.HashSet<string>
NuGet.Commands.MSBuildPackTargetArgs.AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder.set -> void
NuGet.Commands.MSBuildPackTargetArgs.AssemblyName.get -> string
NuGet.Commands.MSBuildPackTargetArgs.AssemblyName.set -> void
NuGet.Commands.MSBuildPackTargetArgs.BuildOutputFolder.get -> string[]
NuGet.Commands.MSBuildPackTargetArgs.BuildOutputFolder.set -> void
NuGet.Commands.MSBuildPackTargetArgs.ContentFiles.get -> System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<NuGet.Commands.ContentMetadata>>
NuGet.Commands.MSBuildPackTargetArgs.ContentFiles.set -> void
NuGet.Commands.MSBuildPackTargetArgs.IncludeBuildOutput.get -> bool
NuGet.Commands.MSBuildPackTargetArgs.IncludeBuildOutput.set -> void
NuGet.Commands.MSBuildPackTargetArgs.MSBuildPackTargetArgs() -> void
NuGet.Commands.MSBuildPackTargetArgs.NuspecOutputPath.get -> string
NuGet.Commands.MSBuildPackTargetArgs.NuspecOutputPath.set -> void
NuGet.Commands.MSBuildPackTargetArgs.SourceFiles.get -> System.Collections.Generic.IDictionary<string, string>
NuGet.Commands.MSBuildPackTargetArgs.SourceFiles.set -> void
NuGet.Commands.MSBuildPackTargetArgs.TargetFrameworks.get -> System.Collections.Generic.ISet<NuGet.Frameworks.NuGetFramework>
NuGet.Commands.MSBuildPackTargetArgs.TargetFrameworks.set -> void
NuGet.Commands.MSBuildPackTargetArgs.TargetPathsToAssemblies.get -> System.Collections.Generic.IEnumerable<NuGet.Commands.OutputLibFile>
NuGet.Commands.MSBuildPackTargetArgs.TargetPathsToAssemblies.set -> void
NuGet.Commands.MSBuildPackTargetArgs.TargetPathsToSymbols.get -> System.Collections.Generic.IEnumerable<NuGet.Commands.OutputLibFile>
NuGet.Commands.MSBuildPackTargetArgs.TargetPathsToSymbols.set -> void
NuGet.Commands.MSBuildProjectFactory
NuGet.Commands.MSBuildProjectFactory.Build.get -> bool
NuGet.Commands.MSBuildProjectFactory.Build.set -> void
NuGet.Commands.MSBuildProjectFactory.CreateBuilder(string basePath, NuGet.Versioning.NuGetVersion version, string suffix, bool buildIfNeeded, NuGet.Packaging.PackageBuilder builder) -> NuGet.Packaging.PackageBuilder
NuGet.Commands.MSBuildProjectFactory.Files.get -> System.Collections.Generic.ICollection<NuGet.Packaging.ManifestFile>
NuGet.Commands.MSBuildProjectFactory.Files.set -> void
NuGet.Commands.MSBuildProjectFactory.GetProjectProperties() -> System.Collections.Generic.Dictionary<string, string>
NuGet.Commands.MSBuildProjectFactory.GetWarningPropertiesForProject() -> NuGet.ProjectModel.WarningProperties
NuGet.Commands.MSBuildProjectFactory.IncludeSymbols.get -> bool
NuGet.Commands.MSBuildProjectFactory.IncludeSymbols.set -> void
NuGet.Commands.MSBuildProjectFactory.IsTool.get -> bool
NuGet.Commands.MSBuildProjectFactory.IsTool.set -> void
NuGet.Commands.MSBuildProjectFactory.Logger.get -> NuGet.Common.ILogger
NuGet.Commands.MSBuildProjectFactory.Logger.set -> void
NuGet.Commands.MSBuildProjectFactory.MSBuildProjectFactory() -> void
NuGet.Commands.MSBuildProjectFactory.MachineWideSettings.get -> NuGet.Configuration.IMachineWideSettings
NuGet.Commands.MSBuildProjectFactory.MachineWideSettings.set -> void
NuGet.Commands.MSBuildProjectFactory.ProjectProperties.get -> System.Collections.Generic.Dictionary<string, string>
NuGet.Commands.MSBuildProjectFactory.SetIncludeSymbols(bool includeSymbols) -> void
NuGet.Commands.MSBuildProjectFrameworkUtility
NuGet.Commands.MSBuildRestoreItemGroup
NuGet.Commands.MSBuildRestoreItemGroup.Condition.get -> string
NuGet.Commands.MSBuildRestoreItemGroup.Conditions.get -> System.Collections.Generic.List<string>
NuGet.Commands.MSBuildRestoreItemGroup.Conditions.set -> void
NuGet.Commands.MSBuildRestoreItemGroup.Items.get -> System.Collections.Generic.List<System.Xml.Linq.XElement>
NuGet.Commands.MSBuildRestoreItemGroup.Items.set -> void
NuGet.Commands.MSBuildRestoreItemGroup.MSBuildRestoreItemGroup() -> void
NuGet.Commands.MSBuildRestoreItemGroup.Position.get -> int
NuGet.Commands.MSBuildRestoreItemGroup.Position.set -> void
NuGet.Commands.MSBuildRestoreItemGroup.RootName.get -> string
NuGet.Commands.MSBuildRestoreItemGroup.RootName.set -> void
NuGet.Commands.MSBuildRestoreUtility
NuGet.Commands.NoOpRestoreResult
NuGet.Commands.NoOpRestoreResult.NoOpRestoreResult(bool success, string lockFilePath, System.Lazy<NuGet.ProjectModel.LockFile> lockFileLazy, NuGet.ProjectModel.CacheFile cacheFile, string cacheFilePath, NuGet.ProjectModel.ProjectStyle projectStyle, System.TimeSpan elapsedTime) -> void
NuGet.Commands.NoOpRestoreUtilities
NuGet.Commands.NoOpRestoreUtilities.NoOpRestoreUtilities() -> void
NuGet.Commands.OriginalCaseGlobalPackageFolder
NuGet.Commands.OriginalCaseGlobalPackageFolder.ConvertLockFileToOriginalCase(NuGet.ProjectModel.LockFile lockFile) -> void
NuGet.Commands.OriginalCaseGlobalPackageFolder.CopyPackagesToOriginalCaseAsync(System.Collections.Generic.IEnumerable<NuGet.Commands.RestoreTargetGraph> graphs, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task
NuGet.Commands.OriginalCaseGlobalPackageFolder.OriginalCaseGlobalPackageFolder(NuGet.Commands.RestoreRequest request) -> void
NuGet.Commands.OriginalCaseGlobalPackageFolder.OriginalCaseGlobalPackageFolder(NuGet.Commands.RestoreRequest request, System.Guid parentId) -> void
NuGet.Commands.OriginalCaseGlobalPackageFolder.ParentId.get -> System.Guid
NuGet.Commands.OutputLibFile
NuGet.Commands.OutputLibFile.FinalOutputPath.get -> string
NuGet.Commands.OutputLibFile.FinalOutputPath.set -> void
NuGet.Commands.OutputLibFile.OutputLibFile() -> void
NuGet.Commands.OutputLibFile.TargetFramework.get -> string
NuGet.Commands.OutputLibFile.TargetFramework.set -> void
NuGet.Commands.OutputLibFile.TargetPath.get -> string
NuGet.Commands.OutputLibFile.TargetPath.set -> void
NuGet.Commands.PackArgs
NuGet.Commands.PackArgs.Arguments.get -> System.Collections.Generic.IEnumerable<string>
NuGet.Commands.PackArgs.Arguments.set -> void
NuGet.Commands.PackArgs.BasePath.get -> string
NuGet.Commands.PackArgs.BasePath.set -> void
NuGet.Commands.PackArgs.Build.get -> bool
NuGet.Commands.PackArgs.Build.set -> void
NuGet.Commands.PackArgs.CurrentDirectory.get -> string
NuGet.Commands.PackArgs.CurrentDirectory.set -> void
NuGet.Commands.PackArgs.Deterministic.get -> bool
NuGet.Commands.PackArgs.Deterministic.set -> void
NuGet.Commands.PackArgs.Exclude.get -> System.Collections.Generic.IEnumerable<string>
NuGet.Commands.PackArgs.Exclude.set -> void
NuGet.Commands.PackArgs.ExcludeEmptyDirectories.get -> bool
NuGet.Commands.PackArgs.ExcludeEmptyDirectories.set -> void
NuGet.Commands.PackArgs.GetPropertyValue(string propertyName) -> string
NuGet.Commands.PackArgs.IncludeReferencedProjects.get -> bool
NuGet.Commands.PackArgs.IncludeReferencedProjects.set -> void
NuGet.Commands.PackArgs.InstallPackageToOutputPath.get -> bool
NuGet.Commands.PackArgs.InstallPackageToOutputPath.set -> void
NuGet.Commands.PackArgs.LogLevel.get -> NuGet.Common.LogLevel
NuGet.Commands.PackArgs.LogLevel.set -> void
NuGet.Commands.PackArgs.Logger.get -> NuGet.Common.ILogger
NuGet.Commands.PackArgs.Logger.set -> void
NuGet.Commands.PackArgs.MachineWideSettings.get -> NuGet.Configuration.IMachineWideSettings
NuGet.Commands.PackArgs.MachineWideSettings.set -> void
NuGet.Commands.PackArgs.MinClientVersion.get -> System.Version
NuGet.Commands.PackArgs.MinClientVersion.set -> void
NuGet.Commands.PackArgs.MsBuildDirectory.get -> System.Lazy<string>
NuGet.Commands.PackArgs.MsBuildDirectory.set -> void
NuGet.Commands.PackArgs.NoDefaultExcludes.get -> bool
NuGet.Commands.PackArgs.NoDefaultExcludes.set -> void
NuGet.Commands.PackArgs.NoPackageAnalysis.get -> bool
NuGet.Commands.PackArgs.NoPackageAnalysis.set -> void
NuGet.Commands.PackArgs.OutputDirectory.get -> string
NuGet.Commands.PackArgs.OutputDirectory.set -> void
NuGet.Commands.PackArgs.OutputFileNamesWithoutVersion.get -> bool
NuGet.Commands.PackArgs.OutputFileNamesWithoutVersion.set -> void
NuGet.Commands.PackArgs.PackArgs() -> void
NuGet.Commands.PackArgs.PackTargetArgs.get -> NuGet.Commands.MSBuildPackTargetArgs
NuGet.Commands.PackArgs.PackTargetArgs.set -> void
NuGet.Commands.PackArgs.PackagesDirectory.get -> string
NuGet.Commands.PackArgs.PackagesDirectory.set -> void
NuGet.Commands.PackArgs.Path.get -> string
NuGet.Commands.PackArgs.Path.set -> void
NuGet.Commands.PackArgs.Properties.get -> System.Collections.Generic.Dictionary<string, string>
NuGet.Commands.PackArgs.Serviceable.get -> bool
NuGet.Commands.PackArgs.Serviceable.set -> void
NuGet.Commands.PackArgs.SolutionDirectory.get -> string
NuGet.Commands.PackArgs.SolutionDirectory.set -> void
NuGet.Commands.PackArgs.Suffix.get -> string
NuGet.Commands.PackArgs.Suffix.set -> void
NuGet.Commands.PackArgs.SymbolPackageFormat.get -> NuGet.Commands.SymbolPackageFormat
NuGet.Commands.PackArgs.SymbolPackageFormat.set -> void
NuGet.Commands.PackArgs.Symbols.get -> bool
NuGet.Commands.PackArgs.Symbols.set -> void
NuGet.Commands.PackArgs.Tool.get -> bool
NuGet.Commands.PackArgs.Tool.set -> void
NuGet.Commands.PackArgs.Version.get -> string
NuGet.Commands.PackArgs.Version.set -> void
NuGet.Commands.PackArgs.WarningProperties.get -> NuGet.ProjectModel.WarningProperties
NuGet.Commands.PackArgs.WarningProperties.set -> void
NuGet.Commands.PackCollectorLogger
NuGet.Commands.PackCollectorLogger.Errors.get -> System.Collections.Generic.IEnumerable<NuGet.Common.ILogMessage>
NuGet.Commands.PackCollectorLogger.PackCollectorLogger(NuGet.Common.ILogger innerLogger, NuGet.ProjectModel.WarningProperties warningProperties) -> void
NuGet.Commands.PackCollectorLogger.WarningProperties.get -> NuGet.ProjectModel.WarningProperties
NuGet.Commands.PackCollectorLogger.WarningProperties.set -> void
NuGet.Commands.PackCommandRunner
NuGet.Commands.PackCommandRunner.BuildPackage() -> void
NuGet.Commands.PackCommandRunner.BuildPackage(NuGet.Packaging.PackageBuilder builder, string outputPath = null) -> NuGet.Packaging.PackageArchiveReader
NuGet.Commands.PackCommandRunner.CreateProjectFactory
NuGet.Commands.PackCommandRunner.GenerateNugetPackage.get -> bool
NuGet.Commands.PackCommandRunner.GenerateNugetPackage.set -> void
NuGet.Commands.PackCommandRunner.PackCommandRunner(NuGet.Commands.PackArgs packArgs, NuGet.Commands.PackCommandRunner.CreateProjectFactory createProjectFactory) -> void
NuGet.Commands.PackCommandRunner.PackCommandRunner(NuGet.Commands.PackArgs packArgs, NuGet.Commands.PackCommandRunner.CreateProjectFactory createProjectFactory, NuGet.Packaging.PackageBuilder packageBuilder) -> void
NuGet.Commands.PackCommandRunner.Rules.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.Rules.IPackageRule>
NuGet.Commands.PackCommandRunner.Rules.set -> void
NuGet.Commands.PackCommandRunner.RunPackageBuild() -> bool
NuGet.Commands.PackageSourceProviderExtensions
NuGet.Commands.PackageSpecificWarningProperties
NuGet.Commands.PackageSpecificWarningProperties.Add(NuGet.Common.NuGetLogCode code, string libraryId, NuGet.Frameworks.NuGetFramework framework) -> void
NuGet.Commands.PackageSpecificWarningProperties.AddRangeOfCodes(System.Collections.Generic.IEnumerable<NuGet.Common.NuGetLogCode> codes, string libraryId, NuGet.Frameworks.NuGetFramework framework) -> void
NuGet.Commands.PackageSpecificWarningProperties.AddRangeOfFrameworks(NuGet.Common.NuGetLogCode code, string libraryId, System.Collections.Generic.IEnumerable<NuGet.Frameworks.NuGetFramework> frameworks) -> void
NuGet.Commands.PackageSpecificWarningProperties.Contains(NuGet.Common.NuGetLogCode code, string libraryId, NuGet.Frameworks.NuGetFramework framework) -> bool
NuGet.Commands.PackageSpecificWarningProperties.Equals(NuGet.Commands.PackageSpecificWarningProperties other) -> bool
NuGet.Commands.PackageSpecificWarningProperties.PackageSpecificWarningProperties() -> void
NuGet.Commands.PackageSpecificWarningProperties.Properties.get -> System.Collections.Generic.IDictionary<NuGet.Common.NuGetLogCode, System.Collections.Generic.IDictionary<string, System.Collections.Generic.ISet<NuGet.Frameworks.NuGetFramework>>>
NuGet.Commands.PackagesLockFileBuilder
NuGet.Commands.PackagesLockFileBuilder.CreateNuGetLockFile(NuGet.ProjectModel.LockFile assetsFile) -> NuGet.ProjectModel.PackagesLockFile
NuGet.Commands.PackagesLockFileBuilder.PackagesLockFileBuilder() -> void
NuGet.Commands.PushRunner
NuGet.Commands.RemoveClientCertArgs
NuGet.Commands.RemoveClientCertArgs.Configfile.get -> string
NuGet.Commands.RemoveClientCertArgs.Configfile.set -> void
NuGet.Commands.RemoveClientCertArgs.PackageSource.get -> string
NuGet.Commands.RemoveClientCertArgs.PackageSource.set -> void
NuGet.Commands.RemoveClientCertArgs.RemoveClientCertArgs() -> void
NuGet.Commands.RemoveClientCertRunner
NuGet.Commands.RemoveSourceArgs
NuGet.Commands.RemoveSourceArgs.Configfile.get -> string
NuGet.Commands.RemoveSourceArgs.Configfile.set -> void
NuGet.Commands.RemoveSourceArgs.Name.get -> string
NuGet.Commands.RemoveSourceArgs.Name.set -> void
NuGet.Commands.RemoveSourceArgs.RemoveSourceArgs() -> void
NuGet.Commands.RemoveSourceRunner
NuGet.Commands.RemoveSourceRunner.RemoveSourceRunner() -> void
NuGet.Commands.RequestRuntimeUtility
NuGet.Commands.ResolvedDependencyKey
NuGet.Commands.ResolvedDependencyKey.Child.get -> NuGet.LibraryModel.LibraryIdentity
NuGet.Commands.ResolvedDependencyKey.Equals(NuGet.Commands.ResolvedDependencyKey other) -> bool
NuGet.Commands.ResolvedDependencyKey.Parent.get -> NuGet.LibraryModel.LibraryIdentity
NuGet.Commands.ResolvedDependencyKey.Range.get -> NuGet.Versioning.VersionRange
NuGet.Commands.ResolvedDependencyKey.ResolvedDependencyKey(NuGet.LibraryModel.LibraryIdentity parent, NuGet.Versioning.VersionRange range, NuGet.LibraryModel.LibraryIdentity child) -> void
NuGet.Commands.ResolverConflict
NuGet.Commands.ResolverConflict.Name.get -> string
NuGet.Commands.ResolverConflict.Requests.get -> System.Collections.Generic.IList<NuGet.Commands.ResolverRequest>
NuGet.Commands.ResolverConflict.ResolverConflict(string name, System.Collections.Generic.IEnumerable<NuGet.Commands.ResolverRequest> requests) -> void
NuGet.Commands.ResolverRequest
NuGet.Commands.ResolverRequest.Request.get -> NuGet.LibraryModel.LibraryRange
NuGet.Commands.ResolverRequest.Requestor.get -> NuGet.LibraryModel.LibraryIdentity
NuGet.Commands.ResolverRequest.ResolverRequest(NuGet.LibraryModel.LibraryIdentity requestor, NuGet.LibraryModel.LibraryRange request) -> void
NuGet.Commands.RestoreArgs
NuGet.Commands.RestoreArgs.AdditionalMessages.get -> System.Collections.Generic.IReadOnlyList<NuGet.ProjectModel.IAssetsLogMessage>
NuGet.Commands.RestoreArgs.AdditionalMessages.set -> void
NuGet.Commands.RestoreArgs.AllowNoOp.get -> bool
NuGet.Commands.RestoreArgs.AllowNoOp.set -> void
NuGet.Commands.RestoreArgs.ApplyStandardProperties(NuGet.Commands.RestoreRequest request) -> void
NuGet.Commands.RestoreArgs.CacheContext.get -> NuGet.Protocol.Core.Types.SourceCacheContext
NuGet.Commands.RestoreArgs.CacheContext.set -> void
NuGet.Commands.RestoreArgs.CachingSourceProvider.get -> NuGet.Protocol.CachingSourceProvider
NuGet.Commands.RestoreArgs.CachingSourceProvider.set -> void
NuGet.Commands.RestoreArgs.ConfigFile.get -> string
NuGet.Commands.RestoreArgs.ConfigFile.set -> void
NuGet.Commands.RestoreArgs.DisableParallel.get -> bool
NuGet.Commands.RestoreArgs.DisableParallel.set -> void
NuGet.Commands.RestoreArgs.FallbackRuntimes.get -> System.Collections.Generic.HashSet<string>
NuGet.Commands.RestoreArgs.FallbackRuntimes.set -> void
NuGet.Commands.RestoreArgs.GetEffectiveFallbackPackageFolders(NuGet.Configuration.ISettings settings) -> System.Collections.Generic.IReadOnlyList<string>
NuGet.Commands.RestoreArgs.GetEffectiveGlobalPackagesFolder(string rootDirectory, NuGet.Configuration.ISettings settings) -> string
NuGet.Commands.RestoreArgs.GetSettings(string projectDirectory) -> NuGet.Configuration.ISettings
NuGet.Commands.RestoreArgs.GlobalPackagesFolder.get -> string
NuGet.Commands.RestoreArgs.GlobalPackagesFolder.set -> void
NuGet.Commands.RestoreArgs.HideWarningsAndErrors.get -> bool
NuGet.Commands.RestoreArgs.HideWarningsAndErrors.set -> void
NuGet.Commands.RestoreArgs.Inputs.get -> System.Collections.Generic.List<string>
NuGet.Commands.RestoreArgs.Inputs.set -> void
NuGet.Commands.RestoreArgs.IsLowercaseGlobalPackagesFolder.get -> bool?
NuGet.Commands.RestoreArgs.IsLowercaseGlobalPackagesFolder.set -> void
NuGet.Commands.RestoreArgs.IsRestoreOriginalAction.get -> bool
NuGet.Commands.RestoreArgs.IsRestoreOriginalAction.set -> void
NuGet.Commands.RestoreArgs.LockFileVersion.get -> int?
NuGet.Commands.RestoreArgs.LockFileVersion.set -> void
NuGet.Commands.RestoreArgs.Log.get -> NuGet.Common.ILogger
NuGet.Commands.RestoreArgs.Log.set -> void
NuGet.Commands.RestoreArgs.MachineWideSettings.get -> NuGet.Configuration.IMachineWideSettings
NuGet.Commands.RestoreArgs.MachineWideSettings.set -> void
NuGet.Commands.RestoreArgs.PackageSaveMode.get -> NuGet.Packaging.PackageSaveMode
NuGet.Commands.RestoreArgs.PackageSaveMode.set -> void
NuGet.Commands.RestoreArgs.ParentId.get -> System.Guid
NuGet.Commands.RestoreArgs.ParentId.set -> void
NuGet.Commands.RestoreArgs.PreLoadedRequestProviders.get -> System.Collections.Generic.List<NuGet.Commands.IPreLoadedRestoreRequestProvider>
NuGet.Commands.RestoreArgs.PreLoadedRequestProviders.set -> void
NuGet.Commands.RestoreArgs.RequestProviders.get -> System.Collections.Generic.List<NuGet.Commands.IRestoreRequestProvider>
NuGet.Commands.RestoreArgs.RequestProviders.set -> void
NuGet.Commands.RestoreArgs.RestoreArgs() -> void
NuGet.Commands.RestoreArgs.RestoreForceEvaluate.get -> bool
NuGet.Commands.RestoreArgs.RestoreForceEvaluate.set -> void
NuGet.Commands.RestoreArgs.Runtimes.get -> System.Collections.Generic.HashSet<string>
NuGet.Commands.RestoreArgs.Runtimes.set -> void
NuGet.Commands.RestoreArgs.Sources.get -> System.Collections.Generic.List<string>
NuGet.Commands.RestoreArgs.Sources.set -> void
NuGet.Commands.RestoreArgs.ValidateRuntimeAssets.get -> bool?
NuGet.Commands.RestoreArgs.ValidateRuntimeAssets.set -> void
NuGet.Commands.RestoreCollectorLogger
NuGet.Commands.RestoreCollectorLogger.ApplyRestoreInputs(NuGet.ProjectModel.PackageSpec projectSpec) -> void
NuGet.Commands.RestoreCollectorLogger.ApplyRestoreOutput(System.Collections.Generic.IEnumerable<NuGet.Commands.RestoreTargetGraph> restoreTargetGraphs) -> void
NuGet.Commands.RestoreCollectorLogger.DisplayMessage(NuGet.Common.IRestoreLogMessage message) -> bool
NuGet.Commands.RestoreCollectorLogger.Errors.get -> System.Collections.Generic.IEnumerable<NuGet.Common.IRestoreLogMessage>
NuGet.Commands.RestoreCollectorLogger.Log(NuGet.Common.IRestoreLogMessage message) -> void
NuGet.Commands.RestoreCollectorLogger.LogAsync(NuGet.Common.IRestoreLogMessage message) -> System.Threading.Tasks.Task
NuGet.Commands.RestoreCollectorLogger.ProjectPath.get -> string
NuGet.Commands.RestoreCollectorLogger.ProjectWarningPropertiesCollection.get -> NuGet.Commands.WarningPropertiesCollection
NuGet.Commands.RestoreCollectorLogger.ProjectWarningPropertiesCollection.set -> void
NuGet.Commands.RestoreCollectorLogger.RestoreCollectorLogger(NuGet.Common.ILogger innerLogger) -> void
NuGet.Commands.RestoreCollectorLogger.RestoreCollectorLogger(NuGet.Common.ILogger innerLogger, NuGet.Common.LogLevel verbosity) -> void
NuGet.Commands.RestoreCollectorLogger.RestoreCollectorLogger(NuGet.Common.ILogger innerLogger, NuGet.Common.LogLevel verbosity, bool hideWarningsAndErrors) -> void
NuGet.Commands.RestoreCollectorLogger.RestoreCollectorLogger(NuGet.Common.ILogger innerLogger, bool hideWarningsAndErrors) -> void
NuGet.Commands.RestoreCollectorLogger.TransitiveWarningPropertiesCollection.get -> NuGet.Commands.WarningPropertiesCollection
NuGet.Commands.RestoreCollectorLogger.TransitiveWarningPropertiesCollection.set -> void
NuGet.Commands.RestoreCommand
NuGet.Commands.RestoreCommand.ExecuteAsync() -> System.Threading.Tasks.Task<NuGet.Commands.RestoreResult>
NuGet.Commands.RestoreCommand.ExecuteAsync(System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Commands.RestoreResult>
NuGet.Commands.RestoreCommand.ParentId.get -> System.Guid
NuGet.Commands.RestoreCommand.RestoreCommand(NuGet.Commands.RestoreRequest request) -> void
NuGet.Commands.RestoreCommandException
NuGet.Commands.RestoreCommandException.AsLogMessage() -> NuGet.Common.ILogMessage
NuGet.Commands.RestoreCommandException.RestoreCommandException(NuGet.Common.IRestoreLogMessage logMessage) -> void
NuGet.Commands.RestoreCommandProviders
NuGet.Commands.RestoreCommandProviders.FallbackPackageFolders.get -> System.Collections.Generic.IReadOnlyList<NuGet.Repositories.NuGetv3LocalRepository>
NuGet.Commands.RestoreCommandProviders.GlobalPackages.get -> NuGet.Repositories.NuGetv3LocalRepository
NuGet.Commands.RestoreCommandProviders.LocalProviders.get -> System.Collections.Generic.IReadOnlyList<NuGet.DependencyResolver.IRemoteDependencyProvider>
NuGet.Commands.RestoreCommandProviders.PackageFileCache.get -> NuGet.Protocol.LocalPackageFileCache
NuGet.Commands.RestoreCommandProviders.RemoteProviders.get -> System.Collections.Generic.IReadOnlyList<NuGet.DependencyResolver.IRemoteDependencyProvider>
NuGet.Commands.RestoreCommandProviders.RestoreCommandProviders(NuGet.Repositories.NuGetv3LocalRepository globalPackages, System.Collections.Generic.IReadOnlyList<NuGet.Repositories.NuGetv3LocalRepository> fallbackPackageFolders, System.Collections.Generic.IReadOnlyList<NuGet.DependencyResolver.IRemoteDependencyProvider> localProviders, System.Collections.Generic.IReadOnlyList<NuGet.DependencyResolver.IRemoteDependencyProvider> remoteProviders, NuGet.Protocol.LocalPackageFileCache packageFileCache) -> void
NuGet.Commands.RestoreCommandProvidersCache
NuGet.Commands.RestoreCommandProvidersCache.GetOrCreate(string globalPackagesPath, System.Collections.Generic.IReadOnlyList<string> fallbackPackagesPaths, System.Collections.Generic.IReadOnlyList<NuGet.Protocol.Core.Types.SourceRepository> sources, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger log) -> NuGet.Commands.RestoreCommandProviders
NuGet.Commands.RestoreCommandProvidersCache.RestoreCommandProvidersCache() -> void
NuGet.Commands.RestoreRequest
NuGet.Commands.RestoreRequest.AdditionalMessages.get -> System.Collections.Generic.IReadOnlyList<NuGet.ProjectModel.IAssetsLogMessage>
NuGet.Commands.RestoreRequest.AdditionalMessages.set -> void
NuGet.Commands.RestoreRequest.AllowNoOp.get -> bool
NuGet.Commands.RestoreRequest.AllowNoOp.set -> void
NuGet.Commands.RestoreRequest.CacheContext.get -> NuGet.Protocol.Core.Types.SourceCacheContext
NuGet.Commands.RestoreRequest.CacheContext.set -> void
NuGet.Commands.RestoreRequest.ClientPolicyContext.get -> NuGet.Packaging.Signing.ClientPolicyContext
NuGet.Commands.RestoreRequest.CompatibilityProfiles.get -> System.Collections.Generic.ISet<NuGet.Frameworks.FrameworkRuntimePair>
NuGet.Commands.RestoreRequest.DependencyGraphSpec.get -> NuGet.ProjectModel.DependencyGraphSpec
NuGet.Commands.RestoreRequest.DependencyGraphSpec.set -> void
NuGet.Commands.RestoreRequest.DependencyProviders.get -> NuGet.Commands.RestoreCommandProviders
NuGet.Commands.RestoreRequest.DependencyProviders.set -> void
NuGet.Commands.RestoreRequest.ExistingLockFile.get -> NuGet.ProjectModel.LockFile
NuGet.Commands.RestoreRequest.ExistingLockFile.set -> void
NuGet.Commands.RestoreRequest.ExternalProjects.get -> System.Collections.Generic.IList<NuGet.ProjectModel.ExternalProjectReference>
NuGet.Commands.RestoreRequest.ExternalProjects.set -> void
NuGet.Commands.RestoreRequest.FallbackRuntimes.get -> System.Collections.Generic.ISet<string>
NuGet.Commands.RestoreRequest.HideWarningsAndErrors.get -> bool
NuGet.Commands.RestoreRequest.HideWarningsAndErrors.set -> void
NuGet.Commands.RestoreRequest.IsLowercasePackagesDirectory.get -> bool
NuGet.Commands.RestoreRequest.IsLowercasePackagesDirectory.set -> void
NuGet.Commands.RestoreRequest.IsRestoreOriginalAction.get -> bool
NuGet.Commands.RestoreRequest.IsRestoreOriginalAction.set -> void
NuGet.Commands.RestoreRequest.LockFilePath.get -> string
NuGet.Commands.RestoreRequest.LockFilePath.set -> void
NuGet.Commands.RestoreRequest.LockFileVersion.get -> int
NuGet.Commands.RestoreRequest.LockFileVersion.set -> void
NuGet.Commands.RestoreRequest.Log.get -> NuGet.Common.ILogger
NuGet.Commands.RestoreRequest.Log.set -> void
NuGet.Commands.RestoreRequest.MSBuildProjectExtensionsPath.get -> string
NuGet.Commands.RestoreRequest.MSBuildProjectExtensionsPath.set -> void
NuGet.Commands.RestoreRequest.MaxDegreeOfConcurrency.get -> int
NuGet.Commands.RestoreRequest.MaxDegreeOfConcurrency.set -> void
NuGet.Commands.RestoreRequest.PackageSaveMode.get -> NuGet.Packaging.PackageSaveMode
NuGet.Commands.RestoreRequest.PackageSaveMode.set -> void
NuGet.Commands.RestoreRequest.PackagesDirectory.get -> string
NuGet.Commands.RestoreRequest.ParentId.get -> System.Guid
NuGet.Commands.RestoreRequest.ParentId.set -> void
NuGet.Commands.RestoreRequest.Project.get -> NuGet.ProjectModel.PackageSpec
NuGet.Commands.RestoreRequest.ProjectStyle.get -> NuGet.ProjectModel.ProjectStyle
NuGet.Commands.RestoreRequest.ProjectStyle.set -> void
NuGet.Commands.RestoreRequest.RequestedRuntimes.get -> System.Collections.Generic.ISet<string>
NuGet.Commands.RestoreRequest.RestoreForceEvaluate.get -> bool
NuGet.Commands.RestoreRequest.RestoreForceEvaluate.set -> void
NuGet.Commands.RestoreRequest.RestoreOutputPath.get -> string
NuGet.Commands.RestoreRequest.RestoreOutputPath.set -> void
NuGet.Commands.RestoreRequest.RestoreRequest(NuGet.ProjectModel.PackageSpec project, NuGet.Commands.RestoreCommandProviders dependencyProviders, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Packaging.Signing.ClientPolicyContext clientPolicyContext, NuGet.Common.ILogger log) -> void
NuGet.Commands.RestoreRequest.ValidateRuntimeAssets.get -> bool
NuGet.Commands.RestoreRequest.ValidateRuntimeAssets.set -> void
NuGet.Commands.RestoreRequest.XmlDocFileSaveMode.get -> NuGet.Packaging.XmlDocFileSaveMode
NuGet.Commands.RestoreRequest.XmlDocFileSaveMode.set -> void
NuGet.Commands.RestoreResult
NuGet.Commands.RestoreResult.CacheFilePath.get -> string
NuGet.Commands.RestoreResult.CompatibilityCheckResults.get -> System.Collections.Generic.IEnumerable<NuGet.Commands.CompatibilityCheckResult>
NuGet.Commands.RestoreResult.ElapsedTime.get -> System.TimeSpan
NuGet.Commands.RestoreResult.GetAllUnresolved() -> System.Collections.Generic.ISet<NuGet.LibraryModel.LibraryRange>
NuGet.Commands.RestoreResult.LockFilePath.get -> string
NuGet.Commands.RestoreResult.LockFilePath.set -> void
NuGet.Commands.RestoreResult.MSBuildOutputFiles.get -> System.Collections.Generic.IEnumerable<NuGet.Commands.MSBuildOutputFile>
NuGet.Commands.RestoreResult.ProjectStyle.get -> NuGet.ProjectModel.ProjectStyle
NuGet.Commands.RestoreResult.RestoreGraphs.get -> System.Collections.Generic.IEnumerable<NuGet.Commands.RestoreTargetGraph>
NuGet.Commands.RestoreResult.RestoreResult(bool success, System.Collections.Generic.IEnumerable<NuGet.Commands.RestoreTargetGraph> restoreGraphs, System.Collections.Generic.IEnumerable<NuGet.Commands.CompatibilityCheckResult> compatibilityCheckResults, System.Collections.Generic.IEnumerable<NuGet.Commands.MSBuildOutputFile> msbuildFiles, NuGet.ProjectModel.LockFile lockFile, NuGet.ProjectModel.LockFile previousLockFile, string lockFilePath, NuGet.ProjectModel.CacheFile cacheFile, string cacheFilePath, string packagesLockFilePath, NuGet.ProjectModel.PackagesLockFile packagesLockFile, string dependencyGraphSpecFilePath, NuGet.ProjectModel.DependencyGraphSpec dependencyGraphSpec, NuGet.ProjectModel.ProjectStyle projectStyle, System.TimeSpan elapsedTime) -> void
NuGet.Commands.RestoreResult.Success.get -> bool
NuGet.Commands.RestoreResultPair
NuGet.Commands.RestoreResultPair.RestoreResultPair(NuGet.Commands.RestoreSummaryRequest request, NuGet.Commands.RestoreResult result) -> void
NuGet.Commands.RestoreResultPair.Result.get -> NuGet.Commands.RestoreResult
NuGet.Commands.RestoreResultPair.SummaryRequest.get -> NuGet.Commands.RestoreSummaryRequest
NuGet.Commands.RestoreRunner
NuGet.Commands.RestoreSpecException
NuGet.Commands.RestoreSpecException.Files.get -> System.Collections.Generic.IEnumerable<string>
NuGet.Commands.RestoreSummary
NuGet.Commands.RestoreSummary.ConfigFiles.get -> System.Collections.Generic.IReadOnlyList<string>
NuGet.Commands.RestoreSummary.Errors.get -> System.Collections.Generic.IReadOnlyList<NuGet.Common.IRestoreLogMessage>
NuGet.Commands.RestoreSummary.FeedsUsed.get -> System.Collections.Generic.IReadOnlyList<string>
NuGet.Commands.RestoreSummary.InputPath.get -> string
NuGet.Commands.RestoreSummary.InstallCount.get -> int
NuGet.Commands.RestoreSummary.NoOpRestore.get -> bool
NuGet.Commands.RestoreSummary.RestoreSummary(NuGet.Commands.RestoreResult result, string inputPath, System.Collections.Generic.IEnumerable<string> configFiles, System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.SourceRepository> sourceRepositories, System.Collections.Generic.IEnumerable<NuGet.Common.RestoreLogMessage> errors) -> void
NuGet.Commands.RestoreSummary.RestoreSummary(bool success) -> void
NuGet.Commands.RestoreSummary.RestoreSummary(bool success, string inputPath, System.Collections.Generic.IReadOnlyList<string> configFiles, System.Collections.Generic.IReadOnlyList<string> feedsUsed, int installCount, System.Collections.Generic.IReadOnlyList<NuGet.Common.IRestoreLogMessage> errors) -> void
NuGet.Commands.RestoreSummary.Success.get -> bool
NuGet.Commands.RestoreSummaryRequest
NuGet.Commands.RestoreSummaryRequest.ConfigFiles.get -> System.Collections.Generic.IEnumerable<string>
NuGet.Commands.RestoreSummaryRequest.InputPath.get -> string
NuGet.Commands.RestoreSummaryRequest.Request.get -> NuGet.Commands.RestoreRequest
NuGet.Commands.RestoreSummaryRequest.RestoreSummaryRequest(NuGet.Commands.RestoreRequest request, string inputPath, System.Collections.Generic.IEnumerable<string> configFiles, System.Collections.Generic.IReadOnlyList<NuGet.Protocol.Core.Types.SourceRepository> sources) -> void
NuGet.Commands.RestoreSummaryRequest.Sources.get -> System.Collections.Generic.IReadOnlyList<NuGet.Protocol.Core.Types.SourceRepository>
NuGet.Commands.RestoreTargetGraph
NuGet.Commands.RestoreTargetGraph.AnalyzeResult.get -> NuGet.DependencyResolver.AnalyzeResult<NuGet.DependencyResolver.RemoteResolveResult>
NuGet.Commands.RestoreTargetGraph.Conflicts.get -> System.Collections.Generic.IEnumerable<NuGet.Commands.ResolverConflict>
NuGet.Commands.RestoreTargetGraph.Conventions.get -> NuGet.Client.ManagedCodeConventions
NuGet.Commands.RestoreTargetGraph.Flattened.get -> System.Collections.Generic.ISet<NuGet.DependencyResolver.GraphItem<NuGet.DependencyResolver.RemoteResolveResult>>
NuGet.Commands.RestoreTargetGraph.Framework.get -> NuGet.Frameworks.NuGetFramework
NuGet.Commands.RestoreTargetGraph.Graphs.get -> System.Collections.Generic.IEnumerable<NuGet.DependencyResolver.GraphNode<NuGet.DependencyResolver.RemoteResolveResult>>
NuGet.Commands.RestoreTargetGraph.InConflict.get -> bool
NuGet.Commands.RestoreTargetGraph.Install.get -> System.Collections.Generic.ISet<NuGet.DependencyResolver.RemoteMatch>
NuGet.Commands.RestoreTargetGraph.Name.get -> string
NuGet.Commands.RestoreTargetGraph.ResolvedDependencies.get -> System.Collections.Generic.ISet<NuGet.Commands.ResolvedDependencyKey>
NuGet.Commands.RestoreTargetGraph.RuntimeGraph.get -> NuGet.RuntimeModel.RuntimeGraph
NuGet.Commands.RestoreTargetGraph.RuntimeIdentifier.get -> string
NuGet.Commands.RestoreTargetGraph.TargetGraphName.get -> string
NuGet.Commands.RestoreTargetGraph.Unresolved.get -> System.Collections.Generic.ISet<NuGet.LibraryModel.LibraryRange>
NuGet.Commands.SignArgs
NuGet.Commands.SignArgs.CertificateFingerprint.get -> string
NuGet.Commands.SignArgs.CertificateFingerprint.set -> void
NuGet.Commands.SignArgs.CertificatePassword.get -> string
NuGet.Commands.SignArgs.CertificatePassword.set -> void
NuGet.Commands.SignArgs.CertificatePath.get -> string
NuGet.Commands.SignArgs.CertificatePath.set -> void
NuGet.Commands.SignArgs.CertificateStoreLocation.get -> System.Security.Cryptography.X509Certificates.StoreLocation
NuGet.Commands.SignArgs.CertificateStoreLocation.set -> void
NuGet.Commands.SignArgs.CertificateStoreName.get -> System.Security.Cryptography.X509Certificates.StoreName
NuGet.Commands.SignArgs.CertificateStoreName.set -> void
NuGet.Commands.SignArgs.CertificateSubjectName.get -> string
NuGet.Commands.SignArgs.CertificateSubjectName.set -> void
NuGet.Commands.SignArgs.Logger.get -> NuGet.Common.ILogger
NuGet.Commands.SignArgs.Logger.set -> void
NuGet.Commands.SignArgs.NonInteractive.get -> bool
NuGet.Commands.SignArgs.NonInteractive.set -> void
NuGet.Commands.SignArgs.OutputDirectory.get -> string
NuGet.Commands.SignArgs.OutputDirectory.set -> void
NuGet.Commands.SignArgs.Overwrite.get -> bool
NuGet.Commands.SignArgs.Overwrite.set -> void
NuGet.Commands.SignArgs.PackagePath.get -> string
NuGet.Commands.SignArgs.PackagePath.set -> void
NuGet.Commands.SignArgs.PasswordProvider.get -> NuGet.Commands.SignCommand.IPasswordProvider
NuGet.Commands.SignArgs.PasswordProvider.set -> void
NuGet.Commands.SignArgs.SignArgs() -> void
NuGet.Commands.SignArgs.SignatureHashAlgorithm.get -> NuGet.Common.HashAlgorithmName
NuGet.Commands.SignArgs.SignatureHashAlgorithm.set -> void
NuGet.Commands.SignArgs.TimestampHashAlgorithm.get -> NuGet.Common.HashAlgorithmName
NuGet.Commands.SignArgs.TimestampHashAlgorithm.set -> void
NuGet.Commands.SignArgs.Timestamper.get -> string
NuGet.Commands.SignArgs.Timestamper.set -> void
NuGet.Commands.SignArgs.Token.get -> System.Threading.CancellationToken
NuGet.Commands.SignArgs.Token.set -> void
NuGet.Commands.SignCommand.IPasswordProvider
NuGet.Commands.SignCommandException
NuGet.Commands.SignCommandException.AsLogMessage() -> NuGet.Common.ILogMessage
NuGet.Commands.SignCommandException.SignCommandException(NuGet.Common.ILogMessage logMessage) -> void
NuGet.Commands.SignCommandRunner
NuGet.Commands.SignCommandRunner.ExecuteCommandAsync(NuGet.Commands.SignArgs signArgs) -> System.Threading.Tasks.Task<int>
NuGet.Commands.SignCommandRunner.ExecuteCommandAsync(System.Collections.Generic.IEnumerable<string> packagesToSign, NuGet.Packaging.Signing.SignPackageRequest signPackageRequest, string timestamper, NuGet.Common.ILogger logger, string outputDirectory, bool overwrite, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<int>
NuGet.Commands.SignCommandRunner.SignCommandRunner() -> void
NuGet.Commands.SourceRepositoryDependencyProvider
NuGet.Commands.SourceRepositoryDependencyProvider.FindLibraryAsync(NuGet.LibraryModel.LibraryRange libraryRange, NuGet.Frameworks.NuGetFramework targetFramework, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.LibraryModel.LibraryIdentity>
NuGet.Commands.SourceRepositoryDependencyProvider.GetAllVersionsAsync(string id, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Versioning.NuGetVersion>>
NuGet.Commands.SourceRepositoryDependencyProvider.GetDependenciesAsync(NuGet.LibraryModel.LibraryIdentity libraryIdentity, NuGet.Frameworks.NuGetFramework targetFramework, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.LibraryModel.LibraryDependencyInfo>
NuGet.Commands.SourceRepositoryDependencyProvider.GetPackageDownloaderAsync(NuGet.Packaging.Core.PackageIdentity packageIdentity, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Packaging.IPackageDownloader>
NuGet.Commands.SourceRepositoryDependencyProvider.IsHttp.get -> bool
NuGet.Commands.SourceRepositoryDependencyProvider.Source.get -> NuGet.Configuration.PackageSource
NuGet.Commands.SourceRepositoryDependencyProvider.SourceRepositoryDependencyProvider(NuGet.Protocol.Core.Types.SourceRepository sourceRepository, NuGet.Common.ILogger logger, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, bool ignoreFailedSources, bool ignoreWarning) -> void
NuGet.Commands.SourceRepositoryDependencyProvider.SourceRepositoryDependencyProvider(NuGet.Protocol.Core.Types.SourceRepository sourceRepository, NuGet.Common.ILogger logger, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, bool ignoreFailedSources, bool ignoreWarning, NuGet.Protocol.LocalPackageFileCache fileCache, bool isFallbackFolderSource) -> void
NuGet.Commands.SourcesAction
NuGet.Commands.SourcesAction.Add = 2 -> NuGet.Commands.SourcesAction
NuGet.Commands.SourcesAction.Disable = 5 -> NuGet.Commands.SourcesAction
NuGet.Commands.SourcesAction.Enable = 4 -> NuGet.Commands.SourcesAction
NuGet.Commands.SourcesAction.List = 1 -> NuGet.Commands.SourcesAction
NuGet.Commands.SourcesAction.None = 0 -> NuGet.Commands.SourcesAction
NuGet.Commands.SourcesAction.Remove = 3 -> NuGet.Commands.SourcesAction
NuGet.Commands.SourcesAction.Update = 6 -> NuGet.Commands.SourcesAction
NuGet.Commands.SourcesListFormat
NuGet.Commands.SourcesListFormat.Detailed = 1 -> NuGet.Commands.SourcesListFormat
NuGet.Commands.SourcesListFormat.None = 0 -> NuGet.Commands.SourcesListFormat
NuGet.Commands.SourcesListFormat.Short = 2 -> NuGet.Commands.SourcesListFormat
NuGet.Commands.SpecValidationUtility
NuGet.Commands.SymbolPackageFormat
NuGet.Commands.SymbolPackageFormat.Snupkg = 0 -> NuGet.Commands.SymbolPackageFormat
NuGet.Commands.SymbolPackageFormat.SymbolsNupkg = 1 -> NuGet.Commands.SymbolPackageFormat
NuGet.Commands.ToolRestoreUtility
NuGet.Commands.TransitiveNoWarnUtils
NuGet.Commands.TransitiveNoWarnUtils.DependencyNode
NuGet.Commands.TransitiveNoWarnUtils.DependencyNode.DependencyNode(string id, bool isProject, NuGet.Commands.TransitiveNoWarnUtils.NodeWarningProperties nodeWarningProperties) -> void
NuGet.Commands.TransitiveNoWarnUtils.DependencyNode.DependencyNode(string id, bool isProject, System.Collections.Generic.HashSet<NuGet.Common.NuGetLogCode> projectWideNoWarn, System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<NuGet.Common.NuGetLogCode>> packageSpecificNoWarn) -> void
NuGet.Commands.TransitiveNoWarnUtils.DependencyNode.Equals(NuGet.Commands.TransitiveNoWarnUtils.DependencyNode other) -> bool
NuGet.Commands.TransitiveNoWarnUtils.DependencyNode.Id.get -> string
NuGet.Commands.TransitiveNoWarnUtils.DependencyNode.IsProject.get -> bool
NuGet.Commands.TransitiveNoWarnUtils.DependencyNode.NodeWarningProperties.get -> NuGet.Commands.TransitiveNoWarnUtils.NodeWarningProperties
NuGet.Commands.TransitiveNoWarnUtils.NodeWarningProperties
NuGet.Commands.TransitiveNoWarnUtils.NodeWarningProperties.Equals(NuGet.Commands.TransitiveNoWarnUtils.NodeWarningProperties other) -> bool
NuGet.Commands.TransitiveNoWarnUtils.NodeWarningProperties.GetIntersect(NuGet.Commands.TransitiveNoWarnUtils.NodeWarningProperties other) -> NuGet.Commands.TransitiveNoWarnUtils.NodeWarningProperties
NuGet.Commands.TransitiveNoWarnUtils.NodeWarningProperties.IsSubSetOf(NuGet.Commands.TransitiveNoWarnUtils.NodeWarningProperties other) -> bool
NuGet.Commands.TransitiveNoWarnUtils.NodeWarningProperties.NodeWarningProperties(System.Collections.Generic.HashSet<NuGet.Common.NuGetLogCode> projectWide, System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<NuGet.Common.NuGetLogCode>> packageSpecific) -> void
NuGet.Commands.TransitiveNoWarnUtils.NodeWarningProperties.PackageSpecific.get -> System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<NuGet.Common.NuGetLogCode>>
NuGet.Commands.TransitiveNoWarnUtils.NodeWarningProperties.ProjectWide.get -> System.Collections.Generic.HashSet<NuGet.Common.NuGetLogCode>
NuGet.Commands.TrustedSignerActionsProvider
NuGet.Commands.TrustedSignerActionsProvider.AddOrUpdateTrustedSigner(string name, string fingerprint, NuGet.Common.HashAlgorithmName hashAlgorithm, bool allowUntrustedRoot) -> void
NuGet.Commands.TrustedSignerActionsProvider.AddTrustedRepositoryAsync(string name, System.Uri serviceIndex, System.Collections.Generic.IEnumerable<string> owners, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task
NuGet.Commands.TrustedSignerActionsProvider.AddTrustedSignerAsync(string name, NuGet.Packaging.Signing.ISignedPackageReader package, NuGet.Packaging.Signing.VerificationTarget trustTarget, bool allowUntrustedRoot, System.Collections.Generic.IEnumerable<string> owners, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task
NuGet.Commands.TrustedSignerActionsProvider.SyncTrustedRepositoryAsync(string name, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task
NuGet.Commands.TrustedSignerActionsProvider.TrustedSignerActionsProvider(NuGet.Packaging.Signing.ITrustedSignersProvider trustedSignersProvider, NuGet.Common.ILogger logger) -> void
NuGet.Commands.TrustedSignersArgs
NuGet.Commands.TrustedSignersArgs.Action.get -> NuGet.Commands.TrustedSignersArgs.TrustedSignersAction
NuGet.Commands.TrustedSignersArgs.Action.set -> void
NuGet.Commands.TrustedSignersArgs.AllowUntrustedRoot.get -> bool
NuGet.Commands.TrustedSignersArgs.AllowUntrustedRoot.set -> void
NuGet.Commands.TrustedSignersArgs.Author.get -> bool
NuGet.Commands.TrustedSignersArgs.Author.set -> void
NuGet.Commands.TrustedSignersArgs.CertificateFingerprint.get -> string
NuGet.Commands.TrustedSignersArgs.CertificateFingerprint.set -> void
NuGet.Commands.TrustedSignersArgs.FingerprintAlgorithm.get -> string
NuGet.Commands.TrustedSignersArgs.FingerprintAlgorithm.set -> void
NuGet.Commands.TrustedSignersArgs.Logger.get -> NuGet.Common.ILogger
NuGet.Commands.TrustedSignersArgs.Logger.set -> void
NuGet.Commands.TrustedSignersArgs.Name.get -> string
NuGet.Commands.TrustedSignersArgs.Name.set -> void
NuGet.Commands.TrustedSignersArgs.Owners.get -> System.Collections.Generic.IEnumerable<string>
NuGet.Commands.TrustedSignersArgs.Owners.set -> void
NuGet.Commands.TrustedSignersArgs.PackagePath.get -> string
NuGet.Commands.TrustedSignersArgs.PackagePath.set -> void
NuGet.Commands.TrustedSignersArgs.Repository.get -> bool
NuGet.Commands.TrustedSignersArgs.Repository.set -> void
NuGet.Commands.TrustedSignersArgs.ServiceIndex.get -> string
NuGet.Commands.TrustedSignersArgs.ServiceIndex.set -> void
NuGet.Commands.TrustedSignersArgs.TrustedSignersAction
NuGet.Commands.TrustedSignersArgs.TrustedSignersAction.Add = 0 -> NuGet.Commands.TrustedSignersArgs.TrustedSignersAction
NuGet.Commands.TrustedSignersArgs.TrustedSignersAction.List = 1 -> NuGet.Commands.TrustedSignersArgs.TrustedSignersAction
NuGet.Commands.TrustedSignersArgs.TrustedSignersAction.Remove = 2 -> NuGet.Commands.TrustedSignersArgs.TrustedSignersAction
NuGet.Commands.TrustedSignersArgs.TrustedSignersAction.Sync = 3 -> NuGet.Commands.TrustedSignersArgs.TrustedSignersAction
NuGet.Commands.TrustedSignersArgs.TrustedSignersArgs() -> void
NuGet.Commands.TrustedSignersCommandRunner
NuGet.Commands.TrustedSignersCommandRunner.ExecuteCommandAsync(NuGet.Commands.TrustedSignersArgs trustedSignersArgs) -> System.Threading.Tasks.Task<int>
NuGet.Commands.TrustedSignersCommandRunner.TrustedSignersCommandRunner(NuGet.Packaging.Signing.ITrustedSignersProvider trustedSignersProvider, NuGet.Configuration.IPackageSourceProvider packageSourceProvider) -> void
NuGet.Commands.UnexpectedDependencyMessages
NuGet.Commands.UnresolvedMessages
NuGet.Commands.UpdateClientCertArgs
NuGet.Commands.UpdateClientCertArgs.Configfile.get -> string
NuGet.Commands.UpdateClientCertArgs.Configfile.set -> void
NuGet.Commands.UpdateClientCertArgs.FindBy.get -> string
NuGet.Commands.UpdateClientCertArgs.FindBy.set -> void
NuGet.Commands.UpdateClientCertArgs.FindValue.get -> string
NuGet.Commands.UpdateClientCertArgs.FindValue.set -> void
NuGet.Commands.UpdateClientCertArgs.Force.get -> bool
NuGet.Commands.UpdateClientCertArgs.Force.set -> void
NuGet.Commands.UpdateClientCertArgs.PackageSource.get -> string
NuGet.Commands.UpdateClientCertArgs.PackageSource.set -> void
NuGet.Commands.UpdateClientCertArgs.Password.get -> string
NuGet.Commands.UpdateClientCertArgs.Password.set -> void
NuGet.Commands.UpdateClientCertArgs.Path.get -> string
NuGet.Commands.UpdateClientCertArgs.Path.set -> void
NuGet.Commands.UpdateClientCertArgs.StoreLocation.get -> string
NuGet.Commands.UpdateClientCertArgs.StoreLocation.set -> void
NuGet.Commands.UpdateClientCertArgs.StoreName.get -> string
NuGet.Commands.UpdateClientCertArgs.StoreName.set -> void
NuGet.Commands.UpdateClientCertArgs.StorePasswordInClearText.get -> bool
NuGet.Commands.UpdateClientCertArgs.StorePasswordInClearText.set -> void
NuGet.Commands.UpdateClientCertArgs.UpdateClientCertArgs() -> void
NuGet.Commands.UpdateClientCertRunner
NuGet.Commands.UpdateSourceArgs
NuGet.Commands.UpdateSourceArgs.Configfile.get -> string
NuGet.Commands.UpdateSourceArgs.Configfile.set -> void
NuGet.Commands.UpdateSourceArgs.Name.get -> string
NuGet.Commands.UpdateSourceArgs.Name.set -> void
NuGet.Commands.UpdateSourceArgs.Password.get -> string
NuGet.Commands.UpdateSourceArgs.Password.set -> void
NuGet.Commands.UpdateSourceArgs.Source.get -> string
NuGet.Commands.UpdateSourceArgs.Source.set -> void
NuGet.Commands.UpdateSourceArgs.StorePasswordInClearText.get -> bool
NuGet.Commands.UpdateSourceArgs.StorePasswordInClearText.set -> void
NuGet.Commands.UpdateSourceArgs.UpdateSourceArgs() -> void
NuGet.Commands.UpdateSourceArgs.Username.get -> string
NuGet.Commands.UpdateSourceArgs.Username.set -> void
NuGet.Commands.UpdateSourceArgs.ValidAuthenticationTypes.get -> string
NuGet.Commands.UpdateSourceArgs.ValidAuthenticationTypes.set -> void
NuGet.Commands.UpdateSourceRunner
NuGet.Commands.UpdateSourceRunner.UpdateSourceRunner() -> void
NuGet.Commands.VerifyArgs
NuGet.Commands.VerifyArgs.CertificateFingerprint.get -> System.Collections.Generic.IEnumerable<string>
NuGet.Commands.VerifyArgs.CertificateFingerprint.set -> void
NuGet.Commands.VerifyArgs.LogLevel.get -> NuGet.Common.LogLevel
NuGet.Commands.VerifyArgs.LogLevel.set -> void
NuGet.Commands.VerifyArgs.Logger.get -> NuGet.Common.ILogger
NuGet.Commands.VerifyArgs.Logger.set -> void
NuGet.Commands.VerifyArgs.PackagePath.get -> string
NuGet.Commands.VerifyArgs.PackagePath.set -> void
NuGet.Commands.VerifyArgs.PackagePaths.get -> System.Collections.Generic.IReadOnlyList<string>
NuGet.Commands.VerifyArgs.PackagePaths.set -> void
NuGet.Commands.VerifyArgs.Verification
NuGet.Commands.VerifyArgs.Verification.All = 1 -> NuGet.Commands.VerifyArgs.Verification
NuGet.Commands.VerifyArgs.Verification.Signatures = 2 -> NuGet.Commands.VerifyArgs.Verification
NuGet.Commands.VerifyArgs.Verification.Unknown = 0 -> NuGet.Commands.VerifyArgs.Verification
NuGet.Commands.VerifyArgs.Verifications.get -> System.Collections.Generic.IList<NuGet.Commands.VerifyArgs.Verification>
NuGet.Commands.VerifyArgs.Verifications.set -> void
NuGet.Commands.VerifyArgs.VerifyArgs() -> void
NuGet.Commands.VerifyCommandRunner
NuGet.Commands.VerifyCommandRunner.ExecuteCommandAsync(NuGet.Commands.VerifyArgs verifyArgs) -> System.Threading.Tasks.Task<int>
NuGet.Commands.VerifyCommandRunner.VerifyCommandRunner() -> void
NuGet.Commands.WarningPropertiesCollection
NuGet.Commands.WarningPropertiesCollection.ApplyNoWarnProperties(NuGet.Common.IRestoreLogMessage message) -> bool
NuGet.Commands.WarningPropertiesCollection.ApplyWarningAsErrorProperties(NuGet.Common.IRestoreLogMessage message) -> void
NuGet.Commands.WarningPropertiesCollection.ApplyWarningProperties(NuGet.Common.IRestoreLogMessage message) -> bool
NuGet.Commands.WarningPropertiesCollection.Equals(NuGet.Commands.WarningPropertiesCollection other) -> bool
NuGet.Commands.WarningPropertiesCollection.PackageSpecificWarningProperties.get -> NuGet.Commands.PackageSpecificWarningProperties
NuGet.Commands.WarningPropertiesCollection.ProjectFrameworks.get -> System.Collections.Generic.IReadOnlyList<NuGet.Frameworks.NuGetFramework>
NuGet.Commands.WarningPropertiesCollection.ProjectWideWarningProperties.get -> NuGet.ProjectModel.WarningProperties
NuGet.Commands.WarningPropertiesCollection.WarningPropertiesCollection(NuGet.ProjectModel.WarningProperties projectWideWarningProperties, NuGet.Commands.PackageSpecificWarningProperties packageSpecificWarningProperties, System.Collections.Generic.IReadOnlyList<NuGet.Frameworks.NuGetFramework> projectFrameworks) -> void
abstract Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase.EnumerateFileSystemInfos() -> System.Collections.Generic.IEnumerable<Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileSystemInfoBase>
abstract Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase.GetDirectory(string path) -> Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase
abstract Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase.GetFile(string path) -> Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase
abstract Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileSystemInfoBase.FullName.get -> string
abstract Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileSystemInfoBase.Name.get -> string
abstract Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileSystemInfoBase.ParentDirectory.get -> Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase
abstract Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContext<TFrame>.PushDirectory(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase directory) -> void
abstract Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContext<TFrame>.Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase directory) -> bool
abstract Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContext<TFrame>.Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase file) -> Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult
const NuGet.Commands.BuildAssetsUtils.PropsExtension = ".props" -> string
const NuGet.Commands.BuildAssetsUtils.TargetsExtension = ".targets" -> string
override Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoWrapper.EnumerateFileSystemInfos() -> System.Collections.Generic.IEnumerable<Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileSystemInfoBase>
override Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoWrapper.FullName.get -> string
override Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoWrapper.GetDirectory(string name) -> Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase
override Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoWrapper.GetFile(string name) -> Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase
override Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoWrapper.Name.get -> string
override Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoWrapper.ParentDirectory.get -> Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase
override Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoWrapper.FullName.get -> string
override Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoWrapper.Name.get -> string
override Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoWrapper.ParentDirectory.get -> Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase
override Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch.Equals(object obj) -> bool
override Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch.GetHashCode() -> int
override Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.LiteralPathSegment.Equals(object obj) -> bool
override Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.LiteralPathSegment.GetHashCode() -> int
override Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear.PushDirectory(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase directory) -> void
override Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear.Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase file) -> Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult
override Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinearExclude.Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase directory) -> bool
override Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinearInclude.Declare(System.Action<Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment, bool> onDeclare) -> void
override Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinearInclude.Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase directory) -> bool
override Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged.Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase file) -> Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult
override Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRaggedExclude.Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase directory) -> bool
override Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRaggedInclude.Declare(System.Action<Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment, bool> onDeclare) -> void
override Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRaggedInclude.Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase directory) -> bool
override NuGet.Commands.CompatibilityIssue.ToString() -> string
override NuGet.Commands.MSBuildItem.ToString() -> string
override NuGet.Commands.NoOpRestoreResult.CommitAsync(NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task
override NuGet.Commands.NoOpRestoreResult.GetAllInstalled() -> System.Collections.Generic.ISet<NuGet.LibraryModel.LibraryIdentity>
override NuGet.Commands.NoOpRestoreResult.LockFile.get -> NuGet.ProjectModel.LockFile
override NuGet.Commands.NoOpRestoreResult.PreviousLockFile.get -> NuGet.ProjectModel.LockFile
override NuGet.Commands.PackCollectorLogger.Log(NuGet.Common.ILogMessage message) -> void
override NuGet.Commands.PackCollectorLogger.LogAsync(NuGet.Common.ILogMessage message) -> System.Threading.Tasks.Task
override NuGet.Commands.PackageSpecificWarningProperties.Equals(object obj) -> bool
override NuGet.Commands.PackageSpecificWarningProperties.GetHashCode() -> int
override NuGet.Commands.ResolvedDependencyKey.Equals(object obj) -> bool
override NuGet.Commands.ResolvedDependencyKey.GetHashCode() -> int
override NuGet.Commands.ResolverRequest.ToString() -> string
override NuGet.Commands.RestoreCollectorLogger.Log(NuGet.Common.ILogMessage message) -> void
override NuGet.Commands.RestoreCollectorLogger.LogAsync(NuGet.Common.ILogMessage message) -> System.Threading.Tasks.Task
override NuGet.Commands.TransitiveNoWarnUtils.DependencyNode.Equals(object obj) -> bool
override NuGet.Commands.TransitiveNoWarnUtils.DependencyNode.GetHashCode() -> int
override NuGet.Commands.TransitiveNoWarnUtils.DependencyNode.ToString() -> string
override NuGet.Commands.TransitiveNoWarnUtils.NodeWarningProperties.Equals(object obj) -> bool
override NuGet.Commands.TransitiveNoWarnUtils.NodeWarningProperties.GetHashCode() -> int
override NuGet.Commands.WarningPropertiesCollection.Equals(object obj) -> bool
override NuGet.Commands.WarningPropertiesCollection.GetHashCode() -> int
override sealed Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged.PushDirectory(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase directory) -> void
static Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult.Success(string stem) -> Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult
static Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.AddExcludePatterns(this Microsoft.Extensions.FileSystemGlobbing.Matcher matcher, params System.Collections.Generic.IEnumerable<string>[] excludePatternsGroups) -> void
static Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.AddIncludePatterns(this Microsoft.Extensions.FileSystemGlobbing.Matcher matcher, params System.Collections.Generic.IEnumerable<string>[] includePatternsGroups) -> void
static Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.GetResultsInFullPath(this Microsoft.Extensions.FileSystemGlobbing.Matcher matcher, string directoryPath) -> System.Collections.Generic.IEnumerable<string>
static NuGet.Commands.AddClientCertRunner.Run(NuGet.Commands.AddClientCertArgs args, System.Func<NuGet.Common.ILogger> getLogger) -> void
static NuGet.Commands.AddSourceRunner.Run(NuGet.Commands.AddSourceArgs args, System.Func<NuGet.Common.ILogger> getLogger) -> void
static NuGet.Commands.AssetTargetFallbackUtility.ApplyFramework(NuGet.ProjectModel.TargetFrameworkInformation targetFrameworkInfo, System.Collections.Generic.IEnumerable<NuGet.Frameworks.NuGetFramework> packageTargetFallback, System.Collections.Generic.IEnumerable<NuGet.Frameworks.NuGetFramework> assetTargetFallback) -> void
static NuGet.Commands.AssetTargetFallbackUtility.EnsureValidFallback(System.Collections.Generic.IEnumerable<NuGet.Frameworks.NuGetFramework> packageTargetFallback, System.Collections.Generic.IEnumerable<NuGet.Frameworks.NuGetFramework> assetTargetFallback, string filePath) -> void
static NuGet.Commands.AssetTargetFallbackUtility.GetFallbackFramework(NuGet.Frameworks.NuGetFramework projectFramework, System.Collections.Generic.IEnumerable<NuGet.Frameworks.NuGetFramework> packageTargetFallback, System.Collections.Generic.IEnumerable<NuGet.Frameworks.NuGetFramework> assetTargetFallback) -> NuGet.Frameworks.NuGetFramework
static NuGet.Commands.AssetTargetFallbackUtility.GetInvalidFallbackCombinationMessage(string path) -> NuGet.Common.RestoreLogMessage
static NuGet.Commands.BuildAssetsUtils.AddNuGetProperties(System.Xml.Linq.XDocument doc, System.Collections.Generic.IEnumerable<string> packageFolders, string repositoryRoot, NuGet.ProjectModel.ProjectStyle projectStyle, string assetsFilePath, bool success) -> void
static NuGet.Commands.BuildAssetsUtils.AddNuGetPropertiesToFirstImport(System.Collections.Generic.IEnumerable<NuGet.Commands.MSBuildOutputFile> files, System.Collections.Generic.IEnumerable<string> packageFolders, string repositoryRoot, NuGet.ProjectModel.ProjectStyle projectStyle, string assetsFilePath, bool success) -> void
static NuGet.Commands.BuildAssetsUtils.GenerateContentFilesItem(string path, NuGet.ProjectModel.LockFileContentFile item, string packageId, string packageVersion) -> System.Xml.Linq.XElement
static NuGet.Commands.BuildAssetsUtils.GenerateEmptyImportsFile() -> System.Xml.Linq.XDocument
static NuGet.Commands.BuildAssetsUtils.GenerateImport(string path) -> System.Xml.Linq.XElement
static NuGet.Commands.BuildAssetsUtils.GenerateMSBuildFile(System.Collections.Generic.List<NuGet.Commands.MSBuildRestoreItemGroup> groups, NuGet.ProjectModel.ProjectStyle outputType) -> System.Xml.Linq.XDocument
static NuGet.Commands.BuildAssetsUtils.GenerateMultiTargetFailureFiles(string targetsPath, string propsPath, NuGet.ProjectModel.ProjectStyle restoreType) -> System.Collections.Generic.List<NuGet.Commands.MSBuildOutputFile>
static NuGet.Commands.BuildAssetsUtils.GenerateMultiTargetFrameworkWarning() -> System.Xml.Linq.XDocument
static NuGet.Commands.BuildAssetsUtils.GenerateProperty(string propertyName, string content) -> System.Xml.Linq.XElement
static NuGet.Commands.BuildAssetsUtils.GetLanguage(string nugetLanguage) -> string
static NuGet.Commands.BuildAssetsUtils.GetMSBuildFilePath(NuGet.ProjectModel.PackageSpec project, NuGet.Commands.RestoreRequest request, string extension) -> string
static NuGet.Commands.BuildAssetsUtils.GetMSBuildFilePath(NuGet.ProjectModel.PackageSpec project, string extension) -> string
static NuGet.Commands.BuildAssetsUtils.GetMSBuildFilePathForPackageReferenceStyleProject(NuGet.ProjectModel.PackageSpec project, string extension) -> string
static NuGet.Commands.BuildAssetsUtils.GetMSBuildOutputFiles(NuGet.ProjectModel.PackageSpec project, NuGet.ProjectModel.LockFile assetsFile, System.Collections.Generic.IEnumerable<NuGet.Commands.RestoreTargetGraph> targetGraphs, System.Collections.Generic.IReadOnlyList<NuGet.Repositories.NuGetv3LocalRepository> repositories, NuGet.Commands.RestoreRequest request, string assetsFilePath, bool restoreSuccess, NuGet.Common.ILogger log) -> System.Collections.Generic.List<NuGet.Commands.MSBuildOutputFile>
static NuGet.Commands.BuildAssetsUtils.GetPathWithMacros(string absolutePath, string repositoryRoot) -> string
static NuGet.Commands.BuildAssetsUtils.HasChanges(System.Xml.Linq.XDocument newFile, string path, NuGet.Common.ILogger log) -> bool
static NuGet.Commands.BuildAssetsUtils.ReadExisting(string path, NuGet.Common.ILogger log) -> System.Xml.Linq.XDocument
static NuGet.Commands.BuildAssetsUtils.WriteFiles(System.Collections.Generic.IEnumerable<NuGet.Commands.MSBuildOutputFile> files, NuGet.Common.ILogger log) -> void
static NuGet.Commands.BuildAssetsUtils.WriteXML(string path, System.Xml.Linq.XDocument doc) -> void
static NuGet.Commands.ClientCertArgsExtensions.GetFindBy(this NuGet.Commands.IClientCertArgsWithStoreData args) -> System.Security.Cryptography.X509Certificates.X509FindType?
static NuGet.Commands.ClientCertArgsExtensions.GetStoreLocation(this NuGet.Commands.IClientCertArgsWithStoreData args) -> System.Security.Cryptography.X509Certificates.StoreLocation?
static NuGet.Commands.ClientCertArgsExtensions.GetStoreName(this NuGet.Commands.IClientCertArgsWithStoreData args) -> System.Security.Cryptography.X509Certificates.StoreName?
static NuGet.Commands.ClientCertArgsExtensions.IsFileCertSettingsProvided(this NuGet.Commands.IClientCertArgsWithFileData args) -> bool
static NuGet.Commands.ClientCertArgsExtensions.IsPackageSourceSettingProvided(this NuGet.Commands.IClientCertArgsWithPackageSource args) -> bool
static NuGet.Commands.ClientCertArgsExtensions.IsStoreCertSettingsProvided(this NuGet.Commands.IClientCertArgsWithStoreData args) -> bool
static NuGet.Commands.ClientCertArgsExtensions.Validate(this NuGet.Commands.AddClientCertArgs args) -> void
static NuGet.Commands.ClientCertArgsExtensions.Validate(this NuGet.Commands.RemoveClientCertArgs args) -> void
static NuGet.Commands.ClientCertArgsExtensions.Validate(this NuGet.Commands.UpdateClientCertArgs args) -> void
static NuGet.Commands.CompatibilityIssue.IncompatiblePackage(NuGet.Packaging.Core.PackageIdentity referenceAssemblyPackage, NuGet.Frameworks.NuGetFramework framework, string runtimeIdentifier, System.Collections.Generic.IEnumerable<NuGet.Frameworks.NuGetFramework> packageFrameworks) -> NuGet.Commands.CompatibilityIssue
static NuGet.Commands.CompatibilityIssue.IncompatiblePackageWithDotnetTool(NuGet.Packaging.Core.PackageIdentity referenceAssemblyPackage) -> NuGet.Commands.CompatibilityIssue
static NuGet.Commands.CompatibilityIssue.IncompatibleProject(NuGet.Packaging.Core.PackageIdentity project, NuGet.Frameworks.NuGetFramework framework, string runtimeIdentifier, System.Collections.Generic.IEnumerable<NuGet.Frameworks.NuGetFramework> projectFrameworks) -> NuGet.Commands.CompatibilityIssue
static NuGet.Commands.CompatibilityIssue.IncompatibleProjectType(NuGet.Packaging.Core.PackageIdentity project) -> NuGet.Commands.CompatibilityIssue
static NuGet.Commands.CompatibilityIssue.IncompatibleToolsPackage(NuGet.Packaging.Core.PackageIdentity packageIdentity, NuGet.Frameworks.NuGetFramework framework, string runtimeIdentifier, System.Collections.Generic.HashSet<NuGet.Frameworks.FrameworkRuntimePair> available) -> NuGet.Commands.CompatibilityIssue
static NuGet.Commands.CompatibilityIssue.ReferenceAssemblyNotImplemented(string assemblyName, NuGet.Packaging.Core.PackageIdentity referenceAssemblyPackage, NuGet.Frameworks.NuGetFramework framework, string runtimeIdentifier) -> NuGet.Commands.CompatibilityIssue
static NuGet.Commands.CompatibilityIssue.ToolsPackageWithExtraPackageTypes(NuGet.Packaging.Core.PackageIdentity referenceAssemblyPackage) -> NuGet.Commands.CompatibilityIssue
static NuGet.Commands.DeleteRunner.Run(NuGet.Configuration.ISettings settings, NuGet.Configuration.IPackageSourceProvider sourceProvider, string packageId, string packageVersion, string source, string apiKey, bool nonInteractive, bool noServiceEndpoint, System.Func<string, bool> confirmFunc, NuGet.Common.ILogger logger) -> System.Threading.Tasks.Task
static NuGet.Commands.DependencyGraphSpecRequestProvider.GetExternalClosure(NuGet.ProjectModel.DependencyGraphSpec dgFile, string projectNameToRestore) -> System.Collections.Generic.IEnumerable<NuGet.ProjectModel.ExternalProjectReference>
static NuGet.Commands.DiagnosticUtility.FormatDependency(string id, NuGet.Versioning.VersionRange range) -> string
static NuGet.Commands.DiagnosticUtility.FormatExpectedIdentity(string id, NuGet.Versioning.VersionRange range) -> string
static NuGet.Commands.DiagnosticUtility.FormatGraphName(NuGet.Commands.RestoreTargetGraph graph) -> string
static NuGet.Commands.DiagnosticUtility.FormatIdentity(NuGet.LibraryModel.LibraryIdentity identity) -> string
static NuGet.Commands.DiagnosticUtility.GetMultiLineMessage(System.Collections.Generic.IEnumerable<string> lines) -> string
static NuGet.Commands.DiagnosticUtility.MergeOnTargetGraph(System.Collections.Generic.IEnumerable<NuGet.Common.RestoreLogMessage> messages) -> System.Collections.Generic.IEnumerable<NuGet.Common.RestoreLogMessage>
static NuGet.Commands.DisableSourceRunner.Run(NuGet.Commands.DisableSourceArgs args, System.Func<NuGet.Common.ILogger> getLogger) -> void
static NuGet.Commands.DownloadDependencyResolutionResult.Create(NuGet.Frameworks.NuGetFramework framework, System.Collections.Generic.IList<System.Tuple<NuGet.LibraryModel.LibraryRange, NuGet.DependencyResolver.RemoteMatch>> dependencies, System.Collections.Generic.IList<NuGet.DependencyResolver.IRemoteDependencyProvider> remoteDependencyProviders) -> NuGet.Commands.DownloadDependencyResolutionResult
static NuGet.Commands.EnableSourceRunner.Run(NuGet.Commands.EnableSourceArgs args, System.Func<NuGet.Common.ILogger> getLogger) -> void
static NuGet.Commands.IndexedRestoreTargetGraph.Create(NuGet.Commands.IRestoreTargetGraph graph) -> NuGet.Commands.IndexedRestoreTargetGraph
static NuGet.Commands.ListClientCertRunner.Run(NuGet.Commands.ListClientCertArgs args, System.Func<NuGet.Common.ILogger> getLogger) -> void
static NuGet.Commands.ListSourceRunner.Run(NuGet.Commands.ListSourceArgs args, System.Func<NuGet.Common.ILogger> getLogger) -> void
static NuGet.Commands.LockFileUtils.CreateLockFileTargetLibrary(NuGet.ProjectModel.LockFileLibrary library, NuGet.Repositories.LocalPackageInfo package, NuGet.Commands.RestoreTargetGraph targetGraph, NuGet.LibraryModel.LibraryIncludeFlags dependencyType) -> NuGet.ProjectModel.LockFileTargetLibrary
static NuGet.Commands.LockFileUtils.CreateLockFileTargetLibrary(NuGet.ProjectModel.LockFileLibrary library, NuGet.Repositories.LocalPackageInfo package, NuGet.Commands.RestoreTargetGraph targetGraph, NuGet.LibraryModel.LibraryIncludeFlags dependencyType, NuGet.Frameworks.NuGetFramework targetFrameworkOverride, System.Collections.Generic.IEnumerable<NuGet.LibraryModel.LibraryDependency> dependencies, NuGet.Commands.LockFileBuilderCache cache) -> NuGet.ProjectModel.LockFileTargetLibrary
static NuGet.Commands.LockFileUtils.CreateLockFileTargetProject(NuGet.DependencyResolver.GraphItem<NuGet.DependencyResolver.RemoteResolveResult> graphItem, NuGet.LibraryModel.LibraryIdentity library, NuGet.LibraryModel.LibraryIncludeFlags dependencyType, NuGet.Commands.RestoreTargetGraph targetGraph, NuGet.ProjectModel.ProjectStyle rootProjectStyle) -> NuGet.ProjectModel.LockFileTargetLibrary
static NuGet.Commands.LockFileUtils.ExcludeItems(NuGet.ProjectModel.LockFileTargetLibrary lockFileLib, NuGet.LibraryModel.LibraryIncludeFlags dependencyType) -> void
static NuGet.Commands.LockFileUtils.ToDirectorySeparator(string path) -> string
static NuGet.Commands.MSBuildProjectFactory.GetTargetPathForSourceFile(string sourcePath, string projectDirectory) -> string
static NuGet.Commands.MSBuildProjectFactory.ProjectCreator(NuGet.Commands.PackArgs packArgs, string path) -> NuGet.Commands.IProjectFactory
static NuGet.Commands.MSBuildProjectFrameworkUtility.GetProjectFramework(string projectFilePath, string targetFrameworkMoniker, string targetPlatformMoniker, string targetPlatformMinVersion) -> NuGet.Frameworks.NuGetFramework
static NuGet.Commands.MSBuildProjectFrameworkUtility.GetProjectFrameworkReplacement(NuGet.Frameworks.NuGetFramework framework) -> NuGet.Frameworks.NuGetFramework
static NuGet.Commands.MSBuildProjectFrameworkUtility.GetProjectFrameworkStrings(string projectFilePath, string targetFrameworks, string targetFramework, string targetFrameworkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string targetPlatformMinVersion) -> System.Collections.Generic.IEnumerable<string>
static NuGet.Commands.MSBuildProjectFrameworkUtility.GetProjectFrameworkStrings(string projectFilePath, string targetFrameworks, string targetFramework, string targetFrameworkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string targetPlatformMinVersion, bool isXnaWindowsPhoneProject, bool isManagementPackProject) -> System.Collections.Generic.IEnumerable<string>
static NuGet.Commands.MSBuildProjectFrameworkUtility.GetProjectFrameworks(System.Collections.Generic.IEnumerable<string> frameworkStrings) -> System.Collections.Generic.IEnumerable<NuGet.Frameworks.NuGetFramework>
static NuGet.Commands.MSBuildRestoreItemGroup.Create(string rootName, System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement> items, int position, System.Collections.Generic.IEnumerable<string> conditions) -> NuGet.Commands.MSBuildRestoreItemGroup
static NuGet.Commands.MSBuildRestoreUtility.AggregateSources(System.Collections.Generic.IEnumerable<string> values, System.Collections.Generic.IEnumerable<string> excludeValues) -> System.Collections.Generic.IEnumerable<string>
static NuGet.Commands.MSBuildRestoreUtility.ApplyIncludeFlags(NuGet.LibraryModel.LibraryDependency dependency, string includeAssets, string excludeAssets, string privateAssets) -> void
static NuGet.Commands.MSBuildRestoreUtility.ApplyIncludeFlags(NuGet.ProjectModel.ProjectRestoreReference dependency, string includeAssets, string excludeAssets, string privateAssets) -> void
static NuGet.Commands.MSBuildRestoreUtility.ContainsClearKeyword(System.Collections.Generic.IEnumerable<string> values) -> bool
static NuGet.Commands.MSBuildRestoreUtility.Dump(System.Collections.Generic.IEnumerable<NuGet.Commands.IMSBuildItem> items, NuGet.Common.ILogger log) -> void
static NuGet.Commands.MSBuildRestoreUtility.FixSourcePath(string s) -> string
static NuGet.Commands.MSBuildRestoreUtility.GetDependencySpec(System.Collections.Generic.IEnumerable<NuGet.Commands.IMSBuildItem> items) -> NuGet.ProjectModel.DependencyGraphSpec
static NuGet.Commands.MSBuildRestoreUtility.GetPackageSpec(System.Collections.Generic.IEnumerable<NuGet.Commands.IMSBuildItem> items) -> NuGet.ProjectModel.PackageSpec
static NuGet.Commands.MSBuildRestoreUtility.GetWarningForUnsupportedProject(string path) -> NuGet.Common.RestoreLogMessage
static NuGet.Commands.MSBuildRestoreUtility.HasInvalidClear(System.Collections.Generic.IEnumerable<string> values) -> bool
static NuGet.Commands.MSBuildRestoreUtility.LogErrorForClearIfInvalid(System.Collections.Generic.IEnumerable<string> values, string projectPath, NuGet.Common.ILogger logger) -> bool
static NuGet.Commands.MSBuildRestoreUtility.NormalizePathCasings(System.Collections.Generic.Dictionary<string, string> paths, NuGet.ProjectModel.DependencyGraphSpec graphSpec) -> void
static NuGet.Commands.MSBuildRestoreUtility.NormalizePathCasings(System.Collections.Generic.IDictionary<string, string> paths, NuGet.ProjectModel.DependencyGraphSpec graphSpec) -> void
static NuGet.Commands.MSBuildRestoreUtility.RemoveMissingProjects(NuGet.ProjectModel.DependencyGraphSpec graphSpec) -> void
static NuGet.Commands.MSBuildRestoreUtility.ReplayWarningsAndErrorsAsync(NuGet.ProjectModel.LockFile lockFile, NuGet.Common.ILogger logger) -> System.Threading.Tasks.Task
static NuGet.Commands.MSBuildRestoreUtility.ReplayWarningsAndErrorsAsync(System.Collections.Generic.IEnumerable<NuGet.ProjectModel.IAssetsLogMessage> messages, NuGet.Common.ILogger logger) -> System.Threading.Tasks.Task
static NuGet.Commands.NoOpRestoreUtilities.GetProjectCacheFilePath(string cacheRoot) -> string
static NuGet.Commands.NoOpRestoreUtilities.GetProjectCacheFilePath(string cacheRoot, string projectPath) -> string
static NuGet.Commands.PackArgs.GetSymbolPackageFormat(string symbolPackageFormat) -> NuGet.Commands.SymbolPackageFormat
static NuGet.Commands.PackCommandRunner.AddDependencyGroups(System.Collections.Generic.IEnumerable<NuGet.LibraryModel.LibraryDependency> dependencies, NuGet.Frameworks.NuGetFramework framework, NuGet.Packaging.PackageBuilder builder) -> void
static NuGet.Commands.PackCommandRunner.AddLibraryDependency(NuGet.LibraryModel.LibraryDependency dependency, System.Collections.Generic.ISet<NuGet.LibraryModel.LibraryDependency> list) -> void
static NuGet.Commands.PackCommandRunner.AddPackageDependency(NuGet.Packaging.Core.PackageDependency dependency, System.Collections.Generic.ISet<NuGet.Packaging.Core.PackageDependency> set) -> void
static NuGet.Commands.PackCommandRunner.GetInputFile(NuGet.Commands.PackArgs packArgs) -> string
static NuGet.Commands.PackCommandRunner.GetOutputFileName(string packageId, NuGet.Versioning.NuGetVersion version, bool isNupkg, bool symbols, NuGet.Commands.SymbolPackageFormat symbolPackageFormat, bool excludeVersion = false) -> string
static NuGet.Commands.PackCommandRunner.GetOutputPath(NuGet.Packaging.PackageBuilder builder, NuGet.Commands.PackArgs packArgs, bool symbols = false, NuGet.Versioning.NuGetVersion nugetVersion = null, string outputDirectory = null, bool isNupkg = true) -> string
static NuGet.Commands.PackCommandRunner.ProcessProjectJsonFile(NuGet.Packaging.PackageBuilder builder, string basePath, string id, NuGet.Versioning.NuGetVersion version, string suffix, System.Func<string, string> propertyProvider) -> bool
static NuGet.Commands.PackCommandRunner.SetupCurrentDirectory(NuGet.Commands.PackArgs packArgs) -> void
static NuGet.Commands.PackageSourceProviderExtensions.ResolveAndValidateSource(this NuGet.Configuration.IPackageSourceProvider sourceProvider, string source) -> string
static NuGet.Commands.PackageSourceProviderExtensions.ResolveSource(System.Collections.Generic.IEnumerable<NuGet.Configuration.PackageSource> availableSources, string source) -> NuGet.Configuration.PackageSource
static NuGet.Commands.PackageSpecificWarningProperties.CreatePackageSpecificWarningProperties(NuGet.ProjectModel.PackageSpec packageSpec) -> NuGet.Commands.PackageSpecificWarningProperties
static NuGet.Commands.PackageSpecificWarningProperties.CreatePackageSpecificWarningProperties(NuGet.ProjectModel.PackageSpec packageSpec, NuGet.Frameworks.NuGetFramework framework) -> NuGet.Commands.PackageSpecificWarningProperties
static NuGet.Commands.PushRunner.Run(NuGet.Configuration.ISettings settings, NuGet.Configuration.IPackageSourceProvider sourceProvider, string packagePath, string source, string apiKey, string symbolSource, string symbolApiKey, int timeoutSeconds, bool disableBuffering, bool noSymbols, bool noServiceEndpoint, bool skipDuplicate, NuGet.Common.ILogger logger) -> System.Threading.Tasks.Task
static NuGet.Commands.RemoveClientCertRunner.Run(NuGet.Commands.RemoveClientCertArgs args, System.Func<NuGet.Common.ILogger> getLogger) -> void
static NuGet.Commands.RemoveSourceRunner.Run(NuGet.Commands.RemoveSourceArgs args, System.Func<NuGet.Common.ILogger> getLogger) -> void
static NuGet.Commands.RequestRuntimeUtility.GetDefaultRestoreRuntimes(string os, string runtimeOsName) -> System.Collections.Generic.IEnumerable<string>
static NuGet.Commands.RestoreCommandProviders.Create(string globalFolderPath, System.Collections.Generic.IEnumerable<string> fallbackPackageFolderPaths, System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.SourceRepository> sources, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Protocol.LocalPackageFileCache packageFileCache, NuGet.Common.ILogger log) -> NuGet.Commands.RestoreCommandProviders
static NuGet.Commands.RestoreRunner.CommitAsync(NuGet.Commands.RestoreResultPair restoreResult, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Commands.RestoreSummary>
static NuGet.Commands.RestoreRunner.GetInvalidInputErrorMessage(string input) -> string
static NuGet.Commands.RestoreRunner.GetRequests(NuGet.Commands.RestoreArgs restoreContext) -> System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<NuGet.Commands.RestoreSummaryRequest>>
static NuGet.Commands.RestoreRunner.RunAsync(NuGet.Commands.RestoreArgs restoreContext) -> System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<NuGet.Commands.RestoreSummary>>
static NuGet.Commands.RestoreRunner.RunAsync(NuGet.Commands.RestoreArgs restoreContext, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<NuGet.Commands.RestoreSummary>>
static NuGet.Commands.RestoreRunner.RunWithoutCommit(System.Collections.Generic.IEnumerable<NuGet.Commands.RestoreSummaryRequest> restoreRequests, NuGet.Commands.RestoreArgs restoreContext) -> System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<NuGet.Commands.RestoreResultPair>>
static NuGet.Commands.RestoreSpecException.Create(string message, System.Collections.Generic.IEnumerable<string> files) -> NuGet.Commands.RestoreSpecException
static NuGet.Commands.RestoreSpecException.Create(string message, System.Collections.Generic.IEnumerable<string> files, System.Exception innerException) -> NuGet.Commands.RestoreSpecException
static NuGet.Commands.RestoreSummary.Log(NuGet.Common.ILogger logger, System.Collections.Generic.IEnumerable<NuGet.Commands.RestoreSummary> restoreSummaries, bool logErrors = false) -> void
static NuGet.Commands.RestoreSummary.Log(NuGet.Common.ILogger logger, System.Collections.Generic.IReadOnlyList<NuGet.Commands.RestoreSummary> restoreSummaries, bool logErrors = false) -> void
static NuGet.Commands.RestoreTargetGraph.Create(NuGet.RuntimeModel.RuntimeGraph runtimeGraph, System.Collections.Generic.IEnumerable<NuGet.DependencyResolver.GraphNode<NuGet.DependencyResolver.RemoteResolveResult>> graphs, NuGet.DependencyResolver.RemoteWalkContext context, NuGet.Common.ILogger log, NuGet.Frameworks.NuGetFramework framework, string runtimeIdentifier) -> NuGet.Commands.RestoreTargetGraph
static NuGet.Commands.RestoreTargetGraph.Create(System.Collections.Generic.IEnumerable<NuGet.DependencyResolver.GraphNode<NuGet.DependencyResolver.RemoteResolveResult>> graphs, NuGet.DependencyResolver.RemoteWalkContext context, NuGet.Common.ILogger logger, NuGet.Frameworks.NuGetFramework framework) -> NuGet.Commands.RestoreTargetGraph
static NuGet.Commands.SpecValidationUtility.ValidateDependencySpec(NuGet.ProjectModel.DependencyGraphSpec spec) -> void
static NuGet.Commands.SpecValidationUtility.ValidateDependencySpec(NuGet.ProjectModel.DependencyGraphSpec spec, System.Collections.Generic.HashSet<string> projectsToSkip) -> void
static NuGet.Commands.SpecValidationUtility.ValidateProjectSpec(NuGet.ProjectModel.PackageSpec spec) -> void
static NuGet.Commands.ToolRestoreUtility.GetSpec(string projectFilePath, string id, NuGet.Versioning.VersionRange versionRange, NuGet.Frameworks.NuGetFramework framework, string packagesPath, System.Collections.Generic.IList<string> fallbackFolders, System.Collections.Generic.IList<NuGet.Configuration.PackageSource> sources, NuGet.ProjectModel.WarningProperties projectWideWarningProperties) -> NuGet.ProjectModel.PackageSpec
static NuGet.Commands.ToolRestoreUtility.GetSubSetRequests(System.Collections.Generic.IEnumerable<NuGet.Commands.RestoreSummaryRequest> requestSummaries) -> System.Collections.Generic.IReadOnlyList<NuGet.Commands.RestoreSummaryRequest>
static NuGet.Commands.ToolRestoreUtility.GetSubSetRequestsForSingleId(System.Collections.Generic.IEnumerable<NuGet.Commands.RestoreSummaryRequest> requests) -> System.Collections.Generic.IReadOnlyList<NuGet.Commands.RestoreSummaryRequest>
static NuGet.Commands.ToolRestoreUtility.GetToolDependencyOrNullFromSpec(NuGet.ProjectModel.PackageSpec spec) -> NuGet.LibraryModel.LibraryDependency
static NuGet.Commands.ToolRestoreUtility.GetToolIdOrNullFromSpec(NuGet.ProjectModel.PackageSpec spec) -> string
static NuGet.Commands.ToolRestoreUtility.GetToolTargetLibrary(NuGet.ProjectModel.LockFile toolLockFile, string toolId) -> NuGet.ProjectModel.LockFileTargetLibrary
static NuGet.Commands.ToolRestoreUtility.GetUniqueName(string id, string framework, NuGet.Versioning.VersionRange versionRange) -> string
static NuGet.Commands.TransitiveNoWarnUtils.CreateTransitiveWarningPropertiesCollection(System.Collections.Generic.IEnumerable<NuGet.Commands.RestoreTargetGraph> targetGraphs, NuGet.ProjectModel.PackageSpec parentProjectSpec) -> NuGet.Commands.WarningPropertiesCollection
static NuGet.Commands.TransitiveNoWarnUtils.ExtractPackageSpecificNoWarnForFramework(NuGet.Commands.PackageSpecificWarningProperties packageSpecificWarningProperties, NuGet.Frameworks.NuGetFramework framework) -> System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<NuGet.Common.NuGetLogCode>>
static NuGet.Commands.TransitiveNoWarnUtils.ExtractPackageSpecificNoWarnPerFramework(NuGet.Commands.PackageSpecificWarningProperties packageSpecificWarningProperties) -> System.Collections.Generic.Dictionary<NuGet.Frameworks.NuGetFramework, System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<NuGet.Common.NuGetLogCode>>>
static NuGet.Commands.TransitiveNoWarnUtils.ExtractPathNoWarnProperties(NuGet.Commands.TransitiveNoWarnUtils.NodeWarningProperties nodeWarningProperties, string libraryId) -> System.Collections.Generic.HashSet<NuGet.Common.NuGetLogCode>
static NuGet.Commands.TransitiveNoWarnUtils.MergeCodes(System.Collections.Generic.HashSet<NuGet.Common.NuGetLogCode> first, System.Collections.Generic.HashSet<NuGet.Common.NuGetLogCode> second) -> System.Collections.Generic.HashSet<NuGet.Common.NuGetLogCode>
static NuGet.Commands.TransitiveNoWarnUtils.MergePackageSpecificNoWarn(System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<NuGet.Common.NuGetLogCode>> first, System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<NuGet.Common.NuGetLogCode>> second) -> System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<NuGet.Common.NuGetLogCode>>
static NuGet.Commands.TransitiveNoWarnUtils.MergePackageSpecificWarningProperties(NuGet.Commands.PackageSpecificWarningProperties first, NuGet.Commands.PackageSpecificWarningProperties second) -> NuGet.Commands.PackageSpecificWarningProperties
static NuGet.Commands.TransitiveNoWarnUtils.TryMergeNullObjects<T>(T first, T second, out T merged) -> bool
static NuGet.Commands.UnexpectedDependencyMessages.DependencyRangeHasMissingExactMatch(NuGet.Commands.ResolvedDependencyKey dependency) -> bool
static NuGet.Commands.UnexpectedDependencyMessages.GetBumpedUpDependencies(System.Collections.Generic.List<NuGet.Commands.IndexedRestoreTargetGraph> graphs, NuGet.ProjectModel.PackageSpec project, System.Collections.Generic.ISet<string> ignoreIds) -> System.Collections.Generic.IEnumerable<NuGet.Common.RestoreLogMessage>
static NuGet.Commands.UnexpectedDependencyMessages.GetDependenciesAboveUpperBounds(System.Collections.Generic.List<NuGet.Commands.IndexedRestoreTargetGraph> graphs, NuGet.Common.ILogger logger) -> System.Collections.Generic.IEnumerable<NuGet.Common.RestoreLogMessage>
static NuGet.Commands.UnexpectedDependencyMessages.GetMissingLowerBoundMessage(NuGet.Commands.ResolvedDependencyKey dependency, params string[] targetGraphs) -> NuGet.Common.RestoreLogMessage
static NuGet.Commands.UnexpectedDependencyMessages.GetMissingLowerBounds(System.Collections.Generic.IEnumerable<NuGet.Commands.IRestoreTargetGraph> graphs, System.Collections.Generic.ISet<string> ignoreIds) -> System.Collections.Generic.IEnumerable<NuGet.Common.RestoreLogMessage>
static NuGet.Commands.UnexpectedDependencyMessages.GetProjectDependenciesMissingLowerBounds(NuGet.ProjectModel.PackageSpec project) -> System.Collections.Generic.IEnumerable<NuGet.Common.RestoreLogMessage>
static NuGet.Commands.UnexpectedDependencyMessages.HasMissingLowerBound(NuGet.Versioning.VersionRange range) -> bool
static NuGet.Commands.UnexpectedDependencyMessages.LogAsync(System.Collections.Generic.IEnumerable<NuGet.Commands.IRestoreTargetGraph> graphs, NuGet.ProjectModel.PackageSpec project, NuGet.Common.ILogger logger) -> System.Threading.Tasks.Task
static NuGet.Commands.UnresolvedMessages.GetMessageAsync(string targetGraphName, NuGet.LibraryModel.LibraryRange unresolved, System.Collections.Generic.IList<NuGet.DependencyResolver.IRemoteDependencyProvider> remoteLibraryProviders, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Common.RestoreLogMessage>
static NuGet.Commands.UnresolvedMessages.LogAsync(System.Collections.Generic.IEnumerable<NuGet.Commands.IRestoreTargetGraph> graphs, NuGet.DependencyResolver.RemoteWalkContext context, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task
static NuGet.Commands.UnresolvedMessages.LogAsync(System.Collections.Generic.IList<NuGet.Commands.DownloadDependencyResolutionResult> downloadDependencyResults, System.Collections.Generic.IList<NuGet.DependencyResolver.IRemoteDependencyProvider> remoteLibraryProviders, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task
static NuGet.Commands.UpdateClientCertRunner.Run(NuGet.Commands.UpdateClientCertArgs args, System.Func<NuGet.Common.ILogger> getLogger) -> void
static NuGet.Commands.UpdateSourceRunner.Run(NuGet.Commands.UpdateSourceArgs args, System.Func<NuGet.Common.ILogger> getLogger) -> void
static NuGet.Commands.WarningPropertiesCollection.ApplyProjectWideNoWarnProperties(NuGet.Common.ILogMessage message, NuGet.ProjectModel.WarningProperties warningProperties) -> bool
static NuGet.Commands.WarningPropertiesCollection.ApplyProjectWideWarningsAsErrorProperties(NuGet.Common.ILogMessage message, NuGet.ProjectModel.WarningProperties warningProperties) -> void
static readonly Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.WildcardPathSegment.MatchAll -> Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.WildcardPathSegment
static readonly Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult.Failed -> Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult
static readonly NuGet.Commands.AssetTargetFallbackUtility.AssetTargetFallback -> string
static readonly NuGet.Commands.BuildAssetsUtils.MacroCandidates -> string[]
static readonly NuGet.Commands.LockFileUtils.LIBANY -> string
static readonly NuGet.Commands.MSBuildRestoreItemGroup.ImportGroup -> string
static readonly NuGet.Commands.MSBuildRestoreItemGroup.ItemGroup -> string
static readonly NuGet.Commands.MSBuildRestoreUtility.Clear -> string
static readonly NuGet.Commands.RestoreRequest.DefaultDegreeOfConcurrency -> int
virtual Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContext<TFrame>.Declare(System.Action<Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment, bool> declare) -> void
virtual Microsoft.Extensions.FileSystemGlobbing.Matcher.AddExclude(string pattern) -> Microsoft.Extensions.FileSystemGlobbing.Matcher
virtual Microsoft.Extensions.FileSystemGlobbing.Matcher.AddInclude(string pattern) -> Microsoft.Extensions.FileSystemGlobbing.Matcher
virtual Microsoft.Extensions.FileSystemGlobbing.Matcher.Execute(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase directoryInfo) -> Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult
virtual NuGet.Commands.DependencyGraphFileRequestProvider.CreateRequests(string inputPath, NuGet.Commands.RestoreArgs restoreContext) -> System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<NuGet.Commands.RestoreSummaryRequest>>
virtual NuGet.Commands.DependencyGraphFileRequestProvider.Supports(string path) -> System.Threading.Tasks.Task<bool>
virtual NuGet.Commands.RestoreResult.CommitAsync(NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task
virtual NuGet.Commands.RestoreResult.GetAllInstalled() -> System.Collections.Generic.ISet<NuGet.LibraryModel.LibraryIdentity>
virtual NuGet.Commands.RestoreResult.LockFile.get -> NuGet.ProjectModel.LockFile
virtual NuGet.Commands.RestoreResult.LogMessages.get -> System.Collections.Generic.IList<NuGet.ProjectModel.IAssetsLogMessage>
virtual NuGet.Commands.RestoreResult.PreviousLockFile.get -> NuGet.ProjectModel.LockFile
