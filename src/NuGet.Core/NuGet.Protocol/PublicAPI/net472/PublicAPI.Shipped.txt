#nullable enable
NuGet.Protocol.AlternatePackageMetadata
NuGet.Protocol.AlternatePackageMetadata.AlternatePackageMetadata() -> void
~NuGet.Protocol.AlternatePackageMetadata.PackageId.get -> string
~NuGet.Protocol.AlternatePackageMetadata.Range.get -> NuGet.Versioning.VersionRange
NuGet.Protocol.AmbientAuthenticationState
NuGet.Protocol.AmbientAuthenticationState.AmbientAuthenticationState() -> void
NuGet.Protocol.AmbientAuthenticationState.AuthenticationRetriesCount.get -> int
NuGet.Protocol.AmbientAuthenticationState.Block() -> void
NuGet.Protocol.AmbientAuthenticationState.Increment() -> void
NuGet.Protocol.AmbientAuthenticationState.IsBlocked.get -> bool
NuGet.Protocol.AutoCompleteResourceV2Feed
~NuGet.Protocol.AutoCompleteResourceV2Feed.AutoCompleteResourceV2Feed(NuGet.Protocol.HttpSourceResource httpSourceResource, string baseAddress, NuGet.Configuration.PackageSource packageSource) -> void
NuGet.Protocol.AutoCompleteResourceV2FeedProvider
NuGet.Protocol.AutoCompleteResourceV2FeedProvider.AutoCompleteResourceV2FeedProvider() -> void
NuGet.Protocol.AutoCompleteResourceV3
~NuGet.Protocol.AutoCompleteResourceV3.AutoCompleteResourceV3(NuGet.Protocol.HttpSource client, NuGet.Protocol.ServiceIndexResourceV3 serviceIndex, NuGet.Protocol.RegistrationResourceV3 regResource) -> void
NuGet.Protocol.AutoCompleteResourceV3Provider
NuGet.Protocol.AutoCompleteResourceV3Provider.AutoCompleteResourceV3Provider() -> void
NuGet.Protocol.CachingSourceProvider
~NuGet.Protocol.CachingSourceProvider.AddSourceRepository(NuGet.Protocol.Core.Types.SourceRepository source) -> void
~NuGet.Protocol.CachingSourceProvider.CachingSourceProvider(NuGet.Configuration.IPackageSourceProvider packageSourceProvider) -> void
~NuGet.Protocol.CachingSourceProvider.CreateRepository(NuGet.Configuration.PackageSource source) -> NuGet.Protocol.Core.Types.SourceRepository
~NuGet.Protocol.CachingSourceProvider.CreateRepository(NuGet.Configuration.PackageSource source, NuGet.Protocol.FeedType type) -> NuGet.Protocol.Core.Types.SourceRepository
~NuGet.Protocol.CachingSourceProvider.CreateRepository(string source) -> NuGet.Protocol.Core.Types.SourceRepository
~NuGet.Protocol.CachingSourceProvider.GetRepositories() -> System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.SourceRepository>
~NuGet.Protocol.CachingSourceProvider.PackageSourceProvider.get -> NuGet.Configuration.IPackageSourceProvider
NuGet.Protocol.CachingUtility
NuGet.Protocol.Core.Types.AutoCompleteResource
NuGet.Protocol.Core.Types.AutoCompleteResource.AutoCompleteResource() -> void
NuGet.Protocol.Core.Types.DependencyInfoResource
NuGet.Protocol.Core.Types.DependencyInfoResource.DependencyInfoResource() -> void
NuGet.Protocol.Core.Types.DownloadResource
NuGet.Protocol.Core.Types.DownloadResource.DownloadResource() -> void
NuGet.Protocol.Core.Types.DownloadResourceResult
NuGet.Protocol.Core.Types.DownloadResourceResult.Dispose() -> void
~NuGet.Protocol.Core.Types.DownloadResourceResult.DownloadResourceResult(NuGet.Packaging.PackageReaderBase packageReader, string source) -> void
NuGet.Protocol.Core.Types.DownloadResourceResult.DownloadResourceResult(NuGet.Protocol.Core.Types.DownloadResourceResultStatus status) -> void
~NuGet.Protocol.Core.Types.DownloadResourceResult.DownloadResourceResult(System.IO.Stream stream, NuGet.Packaging.PackageReaderBase packageReader, string source) -> void
~NuGet.Protocol.Core.Types.DownloadResourceResult.DownloadResourceResult(System.IO.Stream stream, string source) -> void
~NuGet.Protocol.Core.Types.DownloadResourceResult.PackageReader.get -> NuGet.Packaging.PackageReaderBase
~NuGet.Protocol.Core.Types.DownloadResourceResult.PackageSource.get -> string
~NuGet.Protocol.Core.Types.DownloadResourceResult.PackageStream.get -> System.IO.Stream
NuGet.Protocol.Core.Types.DownloadResourceResult.SignatureVerified.get -> bool
NuGet.Protocol.Core.Types.DownloadResourceResult.SignatureVerified.set -> void
NuGet.Protocol.Core.Types.DownloadResourceResult.Status.get -> NuGet.Protocol.Core.Types.DownloadResourceResultStatus
NuGet.Protocol.Core.Types.DownloadResourceResultStatus
NuGet.Protocol.Core.Types.DownloadResourceResultStatus.Available = 0 -> NuGet.Protocol.Core.Types.DownloadResourceResultStatus
NuGet.Protocol.Core.Types.DownloadResourceResultStatus.AvailableWithoutStream = 1 -> NuGet.Protocol.Core.Types.DownloadResourceResultStatus
NuGet.Protocol.Core.Types.DownloadResourceResultStatus.Cancelled = 3 -> NuGet.Protocol.Core.Types.DownloadResourceResultStatus
NuGet.Protocol.Core.Types.DownloadResourceResultStatus.NotFound = 2 -> NuGet.Protocol.Core.Types.DownloadResourceResultStatus
NuGet.Protocol.Core.Types.FatalProtocolException
~NuGet.Protocol.Core.Types.FatalProtocolException.FatalProtocolException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
~NuGet.Protocol.Core.Types.FatalProtocolException.FatalProtocolException(string message) -> void
~NuGet.Protocol.Core.Types.FatalProtocolException.FatalProtocolException(string message, System.Exception innerException) -> void
NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo
~NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo.DependencyGroups.get -> System.Collections.Generic.IReadOnlyList<NuGet.Packaging.PackageDependencyGroup>
~NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo.FindPackageByIdDependencyInfo(NuGet.Packaging.Core.PackageIdentity packageIdentity, System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageDependencyGroup> dependencyGroups, System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup> frameworkReferenceGroups) -> void
~NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo.FrameworkReferenceGroups.get -> System.Collections.Generic.IReadOnlyList<NuGet.Packaging.FrameworkSpecificGroup>
~NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo.PackageIdentity.get -> NuGet.Packaging.Core.PackageIdentity
NuGet.Protocol.Core.Types.FindPackageByIdResource
NuGet.Protocol.Core.Types.FindPackageByIdResource.FindPackageByIdResource() -> void
NuGet.Protocol.Core.Types.HttpHandlerResource
NuGet.Protocol.Core.Types.HttpHandlerResource.HttpHandlerResource() -> void
NuGet.Protocol.Core.Types.HttpSourceCacheContext
NuGet.Protocol.Core.Types.HttpSourceCacheContext.DirectDownload.get -> bool
NuGet.Protocol.Core.Types.HttpSourceCacheContext.MaxAge.get -> System.TimeSpan
~NuGet.Protocol.Core.Types.HttpSourceCacheContext.RootTempFolder.get -> string
~NuGet.Protocol.Core.Types.HttpSourceCacheContext.SourceCacheContext.get -> NuGet.Protocol.Core.Types.SourceCacheContext
NuGet.Protocol.Core.Types.ILegacyFeedCapabilityResource
~NuGet.Protocol.Core.Types.ILegacyFeedCapabilityResource.SupportsIsAbsoluteLatestVersionAsync(NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<bool>
~NuGet.Protocol.Core.Types.ILegacyFeedCapabilityResource.SupportsSearchAsync(NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<bool>
NuGet.Protocol.Core.Types.INuGetResource
NuGet.Protocol.Core.Types.INuGetResourceProvider
NuGet.Protocol.Core.Types.INuGetResourceProvider.After.get -> System.Collections.Generic.IEnumerable<string!>!
NuGet.Protocol.Core.Types.INuGetResourceProvider.Before.get -> System.Collections.Generic.IEnumerable<string!>!
NuGet.Protocol.Core.Types.INuGetResourceProvider.Name.get -> string!
NuGet.Protocol.Core.Types.INuGetResourceProvider.ResourceType.get -> System.Type!
NuGet.Protocol.Core.Types.INuGetResourceProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository! source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource?>!>!
NuGet.Protocol.Core.Types.IPackageSearchMetadata
~NuGet.Protocol.Core.Types.IPackageSearchMetadata.Authors.get -> string
~NuGet.Protocol.Core.Types.IPackageSearchMetadata.DependencySets.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageDependencyGroup>
~NuGet.Protocol.Core.Types.IPackageSearchMetadata.Description.get -> string
NuGet.Protocol.Core.Types.IPackageSearchMetadata.DownloadCount.get -> long?
~NuGet.Protocol.Core.Types.IPackageSearchMetadata.GetDeprecationMetadataAsync() -> System.Threading.Tasks.Task<NuGet.Protocol.PackageDeprecationMetadata>
~NuGet.Protocol.Core.Types.IPackageSearchMetadata.GetVersionsAsync() -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.VersionInfo>>
~NuGet.Protocol.Core.Types.IPackageSearchMetadata.IconUrl.get -> System.Uri
~NuGet.Protocol.Core.Types.IPackageSearchMetadata.Identity.get -> NuGet.Packaging.Core.PackageIdentity
NuGet.Protocol.Core.Types.IPackageSearchMetadata.IsListed.get -> bool
~NuGet.Protocol.Core.Types.IPackageSearchMetadata.LicenseMetadata.get -> NuGet.Packaging.LicenseMetadata
~NuGet.Protocol.Core.Types.IPackageSearchMetadata.LicenseUrl.get -> System.Uri
~NuGet.Protocol.Core.Types.IPackageSearchMetadata.Owners.get -> string
~NuGet.Protocol.Core.Types.IPackageSearchMetadata.PackageDetailsUrl.get -> System.Uri
NuGet.Protocol.Core.Types.IPackageSearchMetadata.PrefixReserved.get -> bool
~NuGet.Protocol.Core.Types.IPackageSearchMetadata.ProjectUrl.get -> System.Uri
NuGet.Protocol.Core.Types.IPackageSearchMetadata.Published.get -> System.DateTimeOffset?
~NuGet.Protocol.Core.Types.IPackageSearchMetadata.ReadmeUrl.get -> System.Uri
~NuGet.Protocol.Core.Types.IPackageSearchMetadata.ReportAbuseUrl.get -> System.Uri
NuGet.Protocol.Core.Types.IPackageSearchMetadata.RequireLicenseAcceptance.get -> bool
~NuGet.Protocol.Core.Types.IPackageSearchMetadata.Summary.get -> string
~NuGet.Protocol.Core.Types.IPackageSearchMetadata.Tags.get -> string
~NuGet.Protocol.Core.Types.IPackageSearchMetadata.Title.get -> string
~NuGet.Protocol.Core.Types.IPackageSearchMetadata.Vulnerabilities.get -> System.Collections.Generic.IEnumerable<NuGet.Protocol.PackageVulnerabilityMetadata>
NuGet.Protocol.Core.Types.ISourceRepositoryProvider
~NuGet.Protocol.Core.Types.ISourceRepositoryProvider.CreateRepository(NuGet.Configuration.PackageSource source) -> NuGet.Protocol.Core.Types.SourceRepository
~NuGet.Protocol.Core.Types.ISourceRepositoryProvider.CreateRepository(NuGet.Configuration.PackageSource source, NuGet.Protocol.FeedType type) -> NuGet.Protocol.Core.Types.SourceRepository
~NuGet.Protocol.Core.Types.ISourceRepositoryProvider.GetRepositories() -> System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.SourceRepository>
~NuGet.Protocol.Core.Types.ISourceRepositoryProvider.PackageSourceProvider.get -> NuGet.Configuration.IPackageSourceProvider
NuGet.Protocol.Core.Types.LegacyFeedCapabilityResource
NuGet.Protocol.Core.Types.LegacyFeedCapabilityResource.LegacyFeedCapabilityResource() -> void
NuGet.Protocol.Core.Types.ListResource
NuGet.Protocol.Core.Types.ListResource.ListResource() -> void
NuGet.Protocol.Core.Types.MetadataResource
~NuGet.Protocol.Core.Types.MetadataResource.Exists(NuGet.Packaging.Core.PackageIdentity identity, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<bool>
~NuGet.Protocol.Core.Types.MetadataResource.Exists(string packageId, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<bool>
~NuGet.Protocol.Core.Types.MetadataResource.GetLatestVersion(string packageId, bool includePrerelease, bool includeUnlisted, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Versioning.NuGetVersion>
~NuGet.Protocol.Core.Types.MetadataResource.GetVersions(string packageId, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Versioning.NuGetVersion>>
NuGet.Protocol.Core.Types.MetadataResource.MetadataResource() -> void
NuGet.Protocol.Core.Types.NuGetProtocolException
~NuGet.Protocol.Core.Types.NuGetProtocolException.NuGetProtocolException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
~NuGet.Protocol.Core.Types.NuGetProtocolException.NuGetProtocolException(string message) -> void
~NuGet.Protocol.Core.Types.NuGetProtocolException.NuGetProtocolException(string message, System.Exception innerException) -> void
NuGet.Protocol.Core.Types.NuGetResourceProviderPositions
NuGet.Protocol.Core.Types.NuGetResourceProviderPositions.NuGetResourceProviderPositions() -> void
NuGet.Protocol.Core.Types.NuGetTestMode
NuGet.Protocol.Core.Types.NullSourceCacheContext
NuGet.Protocol.Core.Types.NullSourceCacheContext.NullSourceCacheContext() -> void
NuGet.Protocol.Core.Types.OfflineFeedAddContext
~NuGet.Protocol.Core.Types.OfflineFeedAddContext.ExtractionContext.get -> NuGet.Packaging.PackageExtractionContext
~NuGet.Protocol.Core.Types.OfflineFeedAddContext.Logger.get -> NuGet.Common.ILogger
~NuGet.Protocol.Core.Types.OfflineFeedAddContext.OfflineFeedAddContext(string packagePath, string source, NuGet.Common.ILogger logger, bool throwIfSourcePackageIsInvalid, bool throwIfPackageExistsAndInvalid, bool throwIfPackageExists, NuGet.Packaging.PackageExtractionContext extractionContext) -> void
~NuGet.Protocol.Core.Types.OfflineFeedAddContext.PackagePath.get -> string
~NuGet.Protocol.Core.Types.OfflineFeedAddContext.Source.get -> string
NuGet.Protocol.Core.Types.OfflineFeedAddContext.ThrowIfPackageExists.get -> bool
NuGet.Protocol.Core.Types.OfflineFeedAddContext.ThrowIfPackageExistsAndInvalid.get -> bool
NuGet.Protocol.Core.Types.OfflineFeedAddContext.ThrowIfSourcePackageIsInvalid.get -> bool
NuGet.Protocol.Core.Types.OfflineFeedUtility
NuGet.Protocol.Core.Types.PackageDownloadContext
~NuGet.Protocol.Core.Types.PackageDownloadContext.ClientPolicyContext.get -> NuGet.Packaging.Signing.ClientPolicyContext
~NuGet.Protocol.Core.Types.PackageDownloadContext.ClientPolicyContext.set -> void
NuGet.Protocol.Core.Types.PackageDownloadContext.DirectDownload.get -> bool
~NuGet.Protocol.Core.Types.PackageDownloadContext.DirectDownloadDirectory.get -> string
~NuGet.Protocol.Core.Types.PackageDownloadContext.PackageDownloadContext(NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext) -> void
~NuGet.Protocol.Core.Types.PackageDownloadContext.PackageDownloadContext(NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, string directDownloadDirectory, bool directDownload) -> void
~NuGet.Protocol.Core.Types.PackageDownloadContext.PackageDownloadContext(NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, string directDownloadDirectory, bool directDownload, NuGet.Configuration.PackageSourceMapping packageSourceMappingConfiguration) -> void
~NuGet.Protocol.Core.Types.PackageDownloadContext.PackageSourceMapping.get -> NuGet.Configuration.PackageSourceMapping
NuGet.Protocol.Core.Types.PackageDownloadContext.ParentId.get -> System.Guid
NuGet.Protocol.Core.Types.PackageDownloadContext.ParentId.set -> void
~NuGet.Protocol.Core.Types.PackageDownloadContext.SourceCacheContext.get -> NuGet.Protocol.Core.Types.SourceCacheContext
NuGet.Protocol.Core.Types.PackageMetadataResource
NuGet.Protocol.Core.Types.PackageMetadataResource.PackageMetadataResource() -> void
NuGet.Protocol.Core.Types.PackageProgressEventArgs
NuGet.Protocol.Core.Types.PackageProgressEventArgs.Complete.get -> double
NuGet.Protocol.Core.Types.PackageProgressEventArgs.HasPackageSource.get -> bool
NuGet.Protocol.Core.Types.PackageProgressEventArgs.IsComplete.get -> bool
~NuGet.Protocol.Core.Types.PackageProgressEventArgs.PackageIdentity.get -> NuGet.Packaging.Core.PackageIdentity
~NuGet.Protocol.Core.Types.PackageProgressEventArgs.PackageProgressEventArgs(NuGet.Packaging.Core.PackageIdentity identity, NuGet.Configuration.PackageSource source, double complete) -> void
~NuGet.Protocol.Core.Types.PackageProgressEventArgs.PackageSource.get -> NuGet.Configuration.PackageSource
NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.Build() -> NuGet.Protocol.Core.Types.IPackageSearchMetadata
NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.Authors.get -> string
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.Authors.set -> void
NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.ClonedPackageSearchMetadata() -> void
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.DependencySets.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageDependencyGroup>
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.DependencySets.set -> void
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.Description.get -> string
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.Description.set -> void
NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.DownloadCount.get -> long?
NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.DownloadCount.set -> void
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.GetDeprecationMetadataAsync() -> System.Threading.Tasks.Task<NuGet.Protocol.PackageDeprecationMetadata>
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.GetVersionsAsync() -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.VersionInfo>>
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.IconUrl.get -> System.Uri
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.IconUrl.set -> void
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.Identity.get -> NuGet.Packaging.Core.PackageIdentity
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.Identity.set -> void
NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.IsListed.get -> bool
NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.IsListed.set -> void
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.LicenseMetadata.get -> NuGet.Packaging.LicenseMetadata
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.LicenseMetadata.set -> void
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.LicenseUrl.get -> System.Uri
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.LicenseUrl.set -> void
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.Owners.get -> string
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.Owners.set -> void
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.PackageDetailsUrl.get -> System.Uri
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.PackageDetailsUrl.set -> void
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.PackagePath.get -> string
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.PackagePath.set -> void
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.PackageReader.get -> System.Func<NuGet.Packaging.PackageReaderBase>
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.PackageReader.set -> void
NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.PrefixReserved.get -> bool
NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.PrefixReserved.set -> void
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.ProjectUrl.get -> System.Uri
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.ProjectUrl.set -> void
NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.Published.get -> System.DateTimeOffset?
NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.Published.set -> void
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.ReadmeUrl.get -> System.Uri
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.ReadmeUrl.set -> void
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.ReportAbuseUrl.get -> System.Uri
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.ReportAbuseUrl.set -> void
NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.RequireLicenseAcceptance.get -> bool
NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.RequireLicenseAcceptance.set -> void
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.Summary.get -> string
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.Summary.set -> void
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.Tags.get -> string
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.Tags.set -> void
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.Title.get -> string
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.Title.set -> void
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.Vulnerabilities.get -> System.Collections.Generic.IEnumerable<NuGet.Protocol.PackageVulnerabilityMetadata>
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.ClonedPackageSearchMetadata.Vulnerabilities.set -> void
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.WithDeprecation(NuGet.Common.AsyncLazy<NuGet.Protocol.PackageDeprecationMetadata> lazyDeprecationFactory) -> NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder
~NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.WithVersions(NuGet.Common.AsyncLazy<System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.VersionInfo>> lazyVersionsFactory) -> NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder
NuGet.Protocol.Core.Types.PackageSearchMetadataExtensions
NuGet.Protocol.Core.Types.PackageSearchResource
NuGet.Protocol.Core.Types.PackageSearchResource.PackageSearchResource() -> void
NuGet.Protocol.Core.Types.PackageUpdateResource
~NuGet.Protocol.Core.Types.PackageUpdateResource.Delete(string packageId, string packageVersion, System.Func<string, string> getApiKey, System.Func<string, bool> confirm, bool noServiceEndpoint, NuGet.Common.ILogger log) -> System.Threading.Tasks.Task
~NuGet.Protocol.Core.Types.PackageUpdateResource.PackageUpdateResource(string source, NuGet.Protocol.HttpSource httpSource) -> void
~NuGet.Protocol.Core.Types.PackageUpdateResource.Push(System.Collections.Generic.IList<string> packagePaths, string symbolSource, int timeoutInSecond, bool disableBuffering, System.Func<string, string> getApiKey, System.Func<string, string> getSymbolApiKey, bool noServiceEndpoint, bool skipDuplicate, NuGet.Protocol.Core.Types.SymbolPackageUpdateResourceV3 symbolPackageUpdateResource, NuGet.Common.ILogger log) -> System.Threading.Tasks.Task
~NuGet.Protocol.Core.Types.PackageUpdateResource.Push(string packagePath, string symbolSource, int timeoutInSecond, bool disableBuffering, System.Func<string, string> getApiKey, System.Func<string, string> getSymbolApiKey, bool noServiceEndpoint, NuGet.Common.ILogger log) -> System.Threading.Tasks.Task
~NuGet.Protocol.Core.Types.PackageUpdateResource.Push(string packagePath, string symbolSource, int timeoutInSecond, bool disableBuffering, System.Func<string, string> getApiKey, System.Func<string, string> getSymbolApiKey, bool noServiceEndpoint, bool skipDuplicate, NuGet.Protocol.Core.Types.SymbolPackageUpdateResourceV3 symbolPackageUpdateResource, NuGet.Common.ILogger log) -> System.Threading.Tasks.Task
~NuGet.Protocol.Core.Types.PackageUpdateResource.Settings.get -> NuGet.Configuration.ISettings
~NuGet.Protocol.Core.Types.PackageUpdateResource.Settings.set -> void
~NuGet.Protocol.Core.Types.PackageUpdateResource.SourceUri.get -> System.Uri
NuGet.Protocol.Core.Types.PluginFindPackageByIdResource
~NuGet.Protocol.Core.Types.PluginFindPackageByIdResource.PluginFindPackageByIdResource(NuGet.Protocol.Plugins.IPlugin plugin, NuGet.Protocol.Plugins.IPluginMulticlientUtilities utilities, NuGet.Configuration.PackageSource packageSource) -> void
NuGet.Protocol.Core.Types.PluginResource
~NuGet.Protocol.Core.Types.PluginResource.GetPluginAsync(NuGet.Protocol.Plugins.OperationClaim requiredClaim, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.PluginResource.GetPluginResult>
NuGet.Protocol.Core.Types.PluginResource.GetPluginResult
~NuGet.Protocol.Core.Types.PluginResource.GetPluginResult.Plugin.get -> NuGet.Protocol.Plugins.IPlugin
~NuGet.Protocol.Core.Types.PluginResource.GetPluginResult.PluginMulticlientUtilities.get -> NuGet.Protocol.Plugins.IPluginMulticlientUtilities
~NuGet.Protocol.Core.Types.PluginResource.PluginResource(System.Collections.Generic.IEnumerable<NuGet.Protocol.Plugins.PluginCreationResult> pluginCreationResults, NuGet.Configuration.PackageSource packageSource, NuGet.Configuration.ICredentialService credentialService) -> void
NuGet.Protocol.Core.Types.PluginResourceProvider
NuGet.Protocol.Core.Types.PluginResourceProvider.PluginResourceProvider() -> void
~NuGet.Protocol.Core.Types.PluginResourceProvider.PluginResourceProvider(NuGet.Protocol.Plugins.IPluginManager pluginManager) -> void
NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo
~NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo.ContentUri.get -> string
~NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo.ContentUri.set -> void
~NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo.DependencyGroups.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageDependencyGroup>
~NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo.Equals(NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo other) -> bool
~NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo.Identity.get -> NuGet.Packaging.Core.PackageIdentity
NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo.Listed.get -> bool
~NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo.RemoteSourceDependencyInfo(NuGet.Packaging.Core.PackageIdentity identity, bool listed, System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageDependencyGroup> dependencyGroups, string contentUri) -> void
NuGet.Protocol.Core.Types.Repository
NuGet.Protocol.Core.Types.Repository.ProviderFactory
NuGet.Protocol.Core.Types.Repository.ProviderFactory.ProviderFactory() -> void
NuGet.Protocol.Core.Types.Repository.RepositoryFactory
NuGet.Protocol.Core.Types.Repository.RepositoryFactory.RepositoryFactory() -> void
NuGet.Protocol.Core.Types.ResourceProvider
NuGet.Protocol.Core.Types.ResourceProvider.ResourceProvider(System.Type! resourceType) -> void
NuGet.Protocol.Core.Types.ResourceProvider.ResourceProvider(System.Type! resourceType, string! name) -> void
NuGet.Protocol.Core.Types.ResourceProvider.ResourceProvider(System.Type! resourceType, string! name, System.Collections.Generic.IEnumerable<string!>! before, System.Collections.Generic.IEnumerable<string!>! after) -> void
NuGet.Protocol.Core.Types.ResourceProvider.ResourceProvider(System.Type! resourceType, string! name, string? before) -> void
NuGet.Protocol.Core.Types.RetriableProtocolException
~NuGet.Protocol.Core.Types.RetriableProtocolException.RetriableProtocolException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
~NuGet.Protocol.Core.Types.RetriableProtocolException.RetriableProtocolException(string message) -> void
~NuGet.Protocol.Core.Types.RetriableProtocolException.RetriableProtocolException(string message, System.Exception innerException) -> void
NuGet.Protocol.Core.Types.SearchFilter
NuGet.Protocol.Core.Types.SearchFilter.Filter.get -> NuGet.Protocol.Core.Types.SearchFilterType?
NuGet.Protocol.Core.Types.SearchFilter.IncludeDelisted.get -> bool
NuGet.Protocol.Core.Types.SearchFilter.IncludeDelisted.set -> void
NuGet.Protocol.Core.Types.SearchFilter.IncludePrerelease.get -> bool
NuGet.Protocol.Core.Types.SearchFilter.OrderBy.get -> NuGet.Protocol.Core.Types.SearchOrderBy?
NuGet.Protocol.Core.Types.SearchFilter.OrderBy.set -> void
~NuGet.Protocol.Core.Types.SearchFilter.PackageTypes.get -> System.Collections.Generic.IEnumerable<string>
~NuGet.Protocol.Core.Types.SearchFilter.PackageTypes.set -> void
NuGet.Protocol.Core.Types.SearchFilter.SearchFilter(bool includePrerelease) -> void
NuGet.Protocol.Core.Types.SearchFilter.SearchFilter(bool includePrerelease, NuGet.Protocol.Core.Types.SearchFilterType? filter) -> void
~NuGet.Protocol.Core.Types.SearchFilter.SupportedFrameworks.get -> System.Collections.Generic.IEnumerable<string>
~NuGet.Protocol.Core.Types.SearchFilter.SupportedFrameworks.set -> void
NuGet.Protocol.Core.Types.SearchFilterType
NuGet.Protocol.Core.Types.SearchFilterType.IsAbsoluteLatestVersion = 1 -> NuGet.Protocol.Core.Types.SearchFilterType
NuGet.Protocol.Core.Types.SearchFilterType.IsLatestVersion = 0 -> NuGet.Protocol.Core.Types.SearchFilterType
NuGet.Protocol.Core.Types.SearchOrderBy
NuGet.Protocol.Core.Types.SearchOrderBy.Id = 0 -> NuGet.Protocol.Core.Types.SearchOrderBy
NuGet.Protocol.Core.Types.SourceCacheContext
NuGet.Protocol.Core.Types.SourceCacheContext.DirectDownload.get -> bool
NuGet.Protocol.Core.Types.SourceCacheContext.DirectDownload.set -> void
NuGet.Protocol.Core.Types.SourceCacheContext.Dispose() -> void
NuGet.Protocol.Core.Types.SourceCacheContext.IgnoreFailedSources.get -> bool
NuGet.Protocol.Core.Types.SourceCacheContext.IgnoreFailedSources.set -> void
NuGet.Protocol.Core.Types.SourceCacheContext.MaxAge.get -> System.DateTimeOffset?
NuGet.Protocol.Core.Types.SourceCacheContext.MaxAge.set -> void
NuGet.Protocol.Core.Types.SourceCacheContext.MaxAgeTimeSpan.get -> System.TimeSpan
NuGet.Protocol.Core.Types.SourceCacheContext.NoCache.get -> bool
NuGet.Protocol.Core.Types.SourceCacheContext.NoCache.set -> void
NuGet.Protocol.Core.Types.SourceCacheContext.RefreshMemoryCache.get -> bool
NuGet.Protocol.Core.Types.SourceCacheContext.RefreshMemoryCache.set -> void
NuGet.Protocol.Core.Types.SourceCacheContext.SessionId.get -> System.Guid
NuGet.Protocol.Core.Types.SourceCacheContext.SessionId.set -> void
NuGet.Protocol.Core.Types.SourceCacheContext.SourceCacheContext() -> void
NuGet.Protocol.Core.Types.SourcePackageDependencyInfo
~NuGet.Protocol.Core.Types.SourcePackageDependencyInfo.DownloadUri.get -> System.Uri
NuGet.Protocol.Core.Types.SourcePackageDependencyInfo.Listed.get -> bool
~NuGet.Protocol.Core.Types.SourcePackageDependencyInfo.PackageHash.get -> string
~NuGet.Protocol.Core.Types.SourcePackageDependencyInfo.Source.get -> NuGet.Protocol.Core.Types.SourceRepository
~NuGet.Protocol.Core.Types.SourcePackageDependencyInfo.SourcePackageDependencyInfo(NuGet.Packaging.Core.PackageIdentity identity, System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.PackageDependency> dependencies, bool listed, NuGet.Protocol.Core.Types.SourceRepository source, System.Uri downloadUri, string packageHash) -> void
~NuGet.Protocol.Core.Types.SourcePackageDependencyInfo.SourcePackageDependencyInfo(string id, NuGet.Versioning.NuGetVersion version, System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.PackageDependency> dependencies, bool listed, NuGet.Protocol.Core.Types.SourceRepository source) -> void
~NuGet.Protocol.Core.Types.SourcePackageDependencyInfo.SourcePackageDependencyInfo(string id, NuGet.Versioning.NuGetVersion version, System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.PackageDependency> dependencies, bool listed, NuGet.Protocol.Core.Types.SourceRepository source, System.Uri downloadUri, string packageHash) -> void
NuGet.Protocol.Core.Types.SourceRepository
NuGet.Protocol.Core.Types.SourceRepository.FeedTypeOverride.get -> NuGet.Protocol.FeedType
NuGet.Protocol.Core.Types.SourceRepository.SourceRepository() -> void
~NuGet.Protocol.Core.Types.SourceRepository.SourceRepository(NuGet.Configuration.PackageSource source, System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.INuGetResourceProvider> providers) -> void
~NuGet.Protocol.Core.Types.SourceRepository.SourceRepository(NuGet.Configuration.PackageSource source, System.Collections.Generic.IEnumerable<System.Lazy<NuGet.Protocol.Core.Types.INuGetResourceProvider>> providers) -> void
~NuGet.Protocol.Core.Types.SourceRepository.SourceRepository(NuGet.Configuration.PackageSource source, System.Collections.Generic.IEnumerable<System.Lazy<NuGet.Protocol.Core.Types.INuGetResourceProvider>> providers, NuGet.Protocol.FeedType feedTypeOverride) -> void
NuGet.Protocol.Core.Types.SourceRepositoryProvider
~NuGet.Protocol.Core.Types.SourceRepositoryProvider.CreateRepository(NuGet.Configuration.PackageSource source) -> NuGet.Protocol.Core.Types.SourceRepository
~NuGet.Protocol.Core.Types.SourceRepositoryProvider.CreateRepository(NuGet.Configuration.PackageSource source, NuGet.Protocol.FeedType type) -> NuGet.Protocol.Core.Types.SourceRepository
~NuGet.Protocol.Core.Types.SourceRepositoryProvider.GetRepositories() -> System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.SourceRepository>
~NuGet.Protocol.Core.Types.SourceRepositoryProvider.PackageSourceProvider.get -> NuGet.Configuration.IPackageSourceProvider
~NuGet.Protocol.Core.Types.SourceRepositoryProvider.SourceRepositoryProvider(NuGet.Configuration.IPackageSourceProvider packageSourceProvider, System.Collections.Generic.IEnumerable<System.Lazy<NuGet.Protocol.Core.Types.INuGetResourceProvider>> resourceProviders) -> void
~NuGet.Protocol.Core.Types.SourceRepositoryProvider.SourceRepositoryProvider(NuGet.Configuration.ISettings settings, System.Collections.Generic.IEnumerable<System.Lazy<NuGet.Protocol.Core.Types.INuGetResourceProvider>> resourceProviders) -> void
NuGet.Protocol.Core.Types.SymbolPackageUpdateResourceV3
~NuGet.Protocol.Core.Types.SymbolPackageUpdateResourceV3.SourceUri.get -> System.Uri
~NuGet.Protocol.Core.Types.SymbolPackageUpdateResourceV3.SymbolPackageUpdateResourceV3(string source, NuGet.Protocol.HttpSource httpSource) -> void
NuGet.Protocol.Core.Types.UserAgent
NuGet.Protocol.Core.Types.UserAgentStringBuilder
~NuGet.Protocol.Core.Types.UserAgentStringBuilder.Build() -> string
~NuGet.Protocol.Core.Types.UserAgentStringBuilder.NuGetClientVersion.get -> string
NuGet.Protocol.Core.Types.UserAgentStringBuilder.UserAgentStringBuilder() -> void
~NuGet.Protocol.Core.Types.UserAgentStringBuilder.UserAgentStringBuilder(string clientName) -> void
~NuGet.Protocol.Core.Types.UserAgentStringBuilder.WithOSDescription(string osInfo) -> NuGet.Protocol.Core.Types.UserAgentStringBuilder
~NuGet.Protocol.Core.Types.UserAgentStringBuilder.WithVisualStudioSKU(string vsInfo) -> NuGet.Protocol.Core.Types.UserAgentStringBuilder
NuGet.Protocol.Core.Types.VersionInfo
NuGet.Protocol.Core.Types.VersionInfo.DownloadCount.get -> long?
~NuGet.Protocol.Core.Types.VersionInfo.PackageSearchMetadata.get -> NuGet.Protocol.Core.Types.IPackageSearchMetadata
~NuGet.Protocol.Core.Types.VersionInfo.PackageSearchMetadata.set -> void
~NuGet.Protocol.Core.Types.VersionInfo.Version.get -> NuGet.Versioning.NuGetVersion
~NuGet.Protocol.Core.Types.VersionInfo.VersionInfo(NuGet.Versioning.NuGetVersion version) -> void
~NuGet.Protocol.Core.Types.VersionInfo.VersionInfo(NuGet.Versioning.NuGetVersion version, long? downloadCount) -> void
~NuGet.Protocol.Core.Types.VersionInfo.VersionInfo(NuGet.Versioning.NuGetVersion version, string downloadCount) -> void
NuGet.Protocol.DependencyInfoResourceV2Feed
~NuGet.Protocol.DependencyInfoResourceV2Feed.DependencyInfoResourceV2Feed(NuGet.Protocol.V2FeedParser feedParser, NuGet.Protocol.Core.Types.SourceRepository source) -> void
NuGet.Protocol.DependencyInfoResourceV2FeedProvider
NuGet.Protocol.DependencyInfoResourceV2FeedProvider.DependencyInfoResourceV2FeedProvider() -> void
NuGet.Protocol.DependencyInfoResourceV3
~NuGet.Protocol.DependencyInfoResourceV3.DependencyInfoResourceV3(NuGet.Protocol.HttpSource client, NuGet.Protocol.RegistrationResourceV3 regResource, NuGet.Protocol.Core.Types.SourceRepository source) -> void
NuGet.Protocol.DependencyInfoResourceV3Provider
NuGet.Protocol.DependencyInfoResourceV3Provider.DependencyInfoResourceV3Provider() -> void
NuGet.Protocol.DownloadResourcePlugin
~NuGet.Protocol.DownloadResourcePlugin.DownloadResourcePlugin(NuGet.Protocol.Plugins.IPlugin plugin, NuGet.Protocol.Plugins.IPluginMulticlientUtilities utilities, NuGet.Configuration.PackageSource packageSource) -> void
NuGet.Protocol.DownloadResourcePluginProvider
NuGet.Protocol.DownloadResourcePluginProvider.DownloadResourcePluginProvider() -> void
NuGet.Protocol.DownloadResourceV2Feed
~NuGet.Protocol.DownloadResourceV2Feed.DownloadResourceV2Feed(NuGet.Protocol.V2FeedParser feedParser) -> void
~NuGet.Protocol.DownloadResourceV2Feed.DownloadResourceV2Feed(NuGet.Protocol.V2FeedParser feedParser, string source) -> void
NuGet.Protocol.DownloadResourceV2FeedProvider
NuGet.Protocol.DownloadResourceV2FeedProvider.DownloadResourceV2FeedProvider() -> void
NuGet.Protocol.DownloadResourceV3
~NuGet.Protocol.DownloadResourceV3.DownloadResourceV3(NuGet.Protocol.HttpSource client, NuGet.Protocol.RegistrationResourceV3 regResource) -> void
~NuGet.Protocol.DownloadResourceV3.DownloadResourceV3(NuGet.Protocol.HttpSource client, string packageBaseAddress) -> void
~NuGet.Protocol.DownloadResourceV3.DownloadResourceV3(string source, NuGet.Protocol.HttpSource client, NuGet.Protocol.RegistrationResourceV3 regResource) -> void
~NuGet.Protocol.DownloadResourceV3.DownloadResourceV3(string source, NuGet.Protocol.HttpSource client, string packageBaseAddress) -> void
NuGet.Protocol.DownloadResourceV3Provider
NuGet.Protocol.DownloadResourceV3Provider.DownloadResourceV3Provider() -> void
NuGet.Protocol.DownloadTimeoutStream
~NuGet.Protocol.DownloadTimeoutStream.DownloadTimeoutStream(string downloadName, System.IO.Stream networkStream, System.TimeSpan timeout) -> void
NuGet.Protocol.DownloadTimeoutStreamContent
~NuGet.Protocol.DownloadTimeoutStreamContent.DownloadTimeoutStreamContent(string downloadName, System.IO.Stream networkStream, System.TimeSpan timeout) -> void
NuGet.Protocol.Events.ProtocolDiagnosticHttpEvent
NuGet.Protocol.Events.ProtocolDiagnosticHttpEvent.Bytes.get -> long
NuGet.Protocol.Events.ProtocolDiagnosticHttpEvent.EventDuration.get -> System.TimeSpan
NuGet.Protocol.Events.ProtocolDiagnosticHttpEvent.IsSuccess.get -> bool
NuGet.Protocol.Events.ProtocolDiagnosticHttpEvent.Timestamp.get -> System.DateTime
NuGet.Protocol.Events.ProtocolDiagnosticHttpEventBase
NuGet.Protocol.Events.ProtocolDiagnosticHttpEventBase.HeaderDuration.get -> System.TimeSpan?
NuGet.Protocol.Events.ProtocolDiagnosticHttpEventBase.HttpStatusCode.get -> int?
NuGet.Protocol.Events.ProtocolDiagnosticHttpEventBase.IsCancelled.get -> bool
NuGet.Protocol.Events.ProtocolDiagnosticHttpEventBase.IsLastAttempt.get -> bool
NuGet.Protocol.Events.ProtocolDiagnosticHttpEventBase.IsRetry.get -> bool
~NuGet.Protocol.Events.ProtocolDiagnosticHttpEventBase.ProtocolDiagnosticHttpEventBase(NuGet.Protocol.Events.ProtocolDiagnosticHttpEventBase other) -> void
~NuGet.Protocol.Events.ProtocolDiagnosticHttpEventBase.ProtocolDiagnosticHttpEventBase(string source, System.Uri url, System.TimeSpan? headerDuration, int? httpStatusCode, bool isRetry, bool isCancelled, bool isLastAttempt) -> void
~NuGet.Protocol.Events.ProtocolDiagnosticHttpEventBase.Source.get -> string
~NuGet.Protocol.Events.ProtocolDiagnosticHttpEventBase.Url.get -> System.Uri
NuGet.Protocol.Events.ProtocolDiagnosticNupkgCopiedEvent
NuGet.Protocol.Events.ProtocolDiagnosticNupkgCopiedEvent.FileSize.get -> long
~NuGet.Protocol.Events.ProtocolDiagnosticNupkgCopiedEvent.ProtocolDiagnosticNupkgCopiedEvent(string source, long fileSize) -> void
~NuGet.Protocol.Events.ProtocolDiagnosticNupkgCopiedEvent.Source.get -> string
NuGet.Protocol.Events.ProtocolDiagnosticResourceEvent
NuGet.Protocol.Events.ProtocolDiagnosticResourceEvent.Duration.get -> System.TimeSpan
~NuGet.Protocol.Events.ProtocolDiagnosticResourceEvent.Method.get -> string
~NuGet.Protocol.Events.ProtocolDiagnosticResourceEvent.ProtocolDiagnosticResourceEvent(string source, string resourceType, string type, string method, System.TimeSpan duration) -> void
~NuGet.Protocol.Events.ProtocolDiagnosticResourceEvent.ResourceType.get -> string
~NuGet.Protocol.Events.ProtocolDiagnosticResourceEvent.Source.get -> string
~NuGet.Protocol.Events.ProtocolDiagnosticResourceEvent.Type.get -> string
NuGet.Protocol.Events.ProtocolDiagnostics
NuGet.Protocol.Events.ProtocolDiagnostics.ProtocolDiagnosticHttpEventHandler
NuGet.Protocol.Events.ProtocolDiagnostics.ProtocolDiagnosticResourceEventHandler
NuGet.Protocol.Events.ProtocolDiagnostics.ProtocolDiagnosticsNupkgCopiedEventHandler
NuGet.Protocol.FactoryExtensionsV3
NuGet.Protocol.FeedType
NuGet.Protocol.FeedType.FileSystemPackagesConfig = 32 -> NuGet.Protocol.FeedType
NuGet.Protocol.FeedType.FileSystemUnknown = 1024 -> NuGet.Protocol.FeedType
NuGet.Protocol.FeedType.FileSystemUnzipped = 16 -> NuGet.Protocol.FeedType
NuGet.Protocol.FeedType.FileSystemV2 = 4 -> NuGet.Protocol.FeedType
NuGet.Protocol.FeedType.FileSystemV3 = 8 -> NuGet.Protocol.FeedType
NuGet.Protocol.FeedType.HttpV2 = 1 -> NuGet.Protocol.FeedType
NuGet.Protocol.FeedType.HttpV3 = 2 -> NuGet.Protocol.FeedType
NuGet.Protocol.FeedType.Undefined = 0 -> NuGet.Protocol.FeedType
NuGet.Protocol.FeedTypePackageSource
NuGet.Protocol.FeedTypePackageSource.FeedType.get -> NuGet.Protocol.FeedType
~NuGet.Protocol.FeedTypePackageSource.FeedTypePackageSource(string source, NuGet.Protocol.FeedType feedType) -> void
NuGet.Protocol.FeedTypeResource
NuGet.Protocol.FeedTypeResource.FeedType.get -> NuGet.Protocol.FeedType
NuGet.Protocol.FeedTypeResource.FeedTypeResource(NuGet.Protocol.FeedType feedType) -> void
NuGet.Protocol.FeedTypeResourceProvider
NuGet.Protocol.FeedTypeResourceProvider.FeedTypeResourceProvider() -> void
NuGet.Protocol.FeedTypeUtility
NuGet.Protocol.FindLocalPackagesResource
NuGet.Protocol.FindLocalPackagesResource.FindLocalPackagesResource() -> void
~NuGet.Protocol.FindLocalPackagesResource.Root.get -> string
~NuGet.Protocol.FindLocalPackagesResource.Root.set -> void
NuGet.Protocol.FindLocalPackagesResourcePackagesConfig
~NuGet.Protocol.FindLocalPackagesResourcePackagesConfig.FindLocalPackagesResourcePackagesConfig(string root) -> void
NuGet.Protocol.FindLocalPackagesResourcePackagesConfigProvider
NuGet.Protocol.FindLocalPackagesResourcePackagesConfigProvider.FindLocalPackagesResourcePackagesConfigProvider() -> void
NuGet.Protocol.FindLocalPackagesResourceUnzipped
~NuGet.Protocol.FindLocalPackagesResourceUnzipped.FindLocalPackagesResourceUnzipped(string root) -> void
NuGet.Protocol.FindLocalPackagesResourceUnzippedProvider
NuGet.Protocol.FindLocalPackagesResourceUnzippedProvider.FindLocalPackagesResourceUnzippedProvider() -> void
NuGet.Protocol.FindLocalPackagesResourceV2
~NuGet.Protocol.FindLocalPackagesResourceV2.FindLocalPackagesResourceV2(string root) -> void
NuGet.Protocol.FindLocalPackagesResourceV2Provider
NuGet.Protocol.FindLocalPackagesResourceV2Provider.FindLocalPackagesResourceV2Provider() -> void
NuGet.Protocol.FindLocalPackagesResourceV3
~NuGet.Protocol.FindLocalPackagesResourceV3.FindLocalPackagesResourceV3(string root) -> void
NuGet.Protocol.FindLocalPackagesResourceV3Provider
NuGet.Protocol.FindLocalPackagesResourceV3Provider.FindLocalPackagesResourceV3Provider() -> void
NuGet.Protocol.FindPackagesByIdNupkgDownloader
~NuGet.Protocol.FindPackagesByIdNupkgDownloader.CopyNupkgToStreamAsync(NuGet.Packaging.Core.PackageIdentity identity, string url, System.IO.Stream destination, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<bool>
~NuGet.Protocol.FindPackagesByIdNupkgDownloader.FindPackagesByIdNupkgDownloader(NuGet.Protocol.HttpSource httpSource) -> void
~NuGet.Protocol.FindPackagesByIdNupkgDownloader.GetNuspecReaderFromNupkgAsync(NuGet.Packaging.Core.PackageIdentity identity, string url, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Packaging.NuspecReader>
NuGet.Protocol.FingerprintsConverter
NuGet.Protocol.FingerprintsConverter.FingerprintsConverter() -> void
NuGet.Protocol.GetDownloadResultUtility
NuGet.Protocol.GlobalPackagesFolderUtility
NuGet.Protocol.HttpCacheResult
~NuGet.Protocol.HttpCacheResult.CacheFile.get -> string
~NuGet.Protocol.HttpCacheResult.HttpCacheResult(System.TimeSpan maxAge, string newFile, string cacheFule) -> void
NuGet.Protocol.HttpCacheResult.MaxAge.get -> System.TimeSpan
~NuGet.Protocol.HttpCacheResult.NewFile.get -> string
~NuGet.Protocol.HttpCacheResult.Stream.get -> System.IO.Stream
~NuGet.Protocol.HttpCacheResult.Stream.set -> void
NuGet.Protocol.HttpCacheUtility
NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource
~NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource.HttpFileSystemBasedFindPackageByIdResource(System.Collections.Generic.IReadOnlyList<System.Uri> baseUris, NuGet.Protocol.HttpSource httpSource) -> void
NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResourceProvider
NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResourceProvider.HttpFileSystemBasedFindPackageByIdResourceProvider() -> void
NuGet.Protocol.HttpHandlerResourceV3
~NuGet.Protocol.HttpHandlerResourceV3.HttpHandlerResourceV3(System.Net.Http.HttpClientHandler clientHandler, System.Net.Http.HttpMessageHandler messageHandler) -> void
NuGet.Protocol.HttpHandlerResourceV3Provider
NuGet.Protocol.HttpHandlerResourceV3Provider.HttpHandlerResourceV3Provider() -> void
NuGet.Protocol.HttpRequestMessageConfiguration
~NuGet.Protocol.HttpRequestMessageConfiguration.HttpRequestMessageConfiguration(NuGet.Common.ILogger logger = null, bool promptOn403 = true) -> void
~NuGet.Protocol.HttpRequestMessageConfiguration.Logger.get -> NuGet.Common.ILogger
NuGet.Protocol.HttpRequestMessageConfiguration.PromptOn403.get -> bool
NuGet.Protocol.HttpRequestMessageExtensions
NuGet.Protocol.HttpRequestMessageFactory
NuGet.Protocol.HttpResponseMessageExtensions
NuGet.Protocol.HttpRetryHandler
NuGet.Protocol.HttpRetryHandler.HttpRetryHandler() -> void
NuGet.Protocol.HttpRetryHandler.SendAsync(NuGet.Protocol.HttpRetryHandlerRequest! request, NuGet.Common.ILogger! log, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Net.Http.HttpResponseMessage!>!
NuGet.Protocol.HttpRetryHandler.SendAsync(NuGet.Protocol.HttpRetryHandlerRequest! request, string! source, NuGet.Common.ILogger! log, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Net.Http.HttpResponseMessage!>!
NuGet.Protocol.HttpRetryHandlerRequest
~NuGet.Protocol.HttpRetryHandlerRequest.AddHeaders.get -> System.Collections.Generic.IList<System.Collections.Generic.KeyValuePair<string, System.Collections.Generic.IEnumerable<string>>>
~NuGet.Protocol.HttpRetryHandlerRequest.AddHeaders.set -> void
NuGet.Protocol.HttpRetryHandlerRequest.CompletionOption.get -> System.Net.Http.HttpCompletionOption
NuGet.Protocol.HttpRetryHandlerRequest.CompletionOption.set -> void
NuGet.Protocol.HttpRetryHandlerRequest.DownloadTimeout.get -> System.TimeSpan
NuGet.Protocol.HttpRetryHandlerRequest.DownloadTimeout.set -> void
~NuGet.Protocol.HttpRetryHandlerRequest.HttpClient.get -> System.Net.Http.HttpClient
~NuGet.Protocol.HttpRetryHandlerRequest.HttpRetryHandlerRequest(System.Net.Http.HttpClient httpClient, System.Func<System.Net.Http.HttpRequestMessage> requestFactory) -> void
NuGet.Protocol.HttpRetryHandlerRequest.IsLastAttempt.get -> bool
NuGet.Protocol.HttpRetryHandlerRequest.IsLastAttempt.set -> void
NuGet.Protocol.HttpRetryHandlerRequest.IsRetry.get -> bool
NuGet.Protocol.HttpRetryHandlerRequest.IsRetry.set -> void
NuGet.Protocol.HttpRetryHandlerRequest.MaxTries.get -> int
NuGet.Protocol.HttpRetryHandlerRequest.MaxTries.set -> void
~NuGet.Protocol.HttpRetryHandlerRequest.RequestFactory.get -> System.Func<System.Net.Http.HttpRequestMessage>
NuGet.Protocol.HttpRetryHandlerRequest.RequestTimeout.get -> System.TimeSpan
NuGet.Protocol.HttpRetryHandlerRequest.RequestTimeout.set -> void
NuGet.Protocol.HttpRetryHandlerRequest.RetryDelay.get -> System.TimeSpan
NuGet.Protocol.HttpRetryHandlerRequest.RetryDelay.set -> void
NuGet.Protocol.HttpSource
NuGet.Protocol.HttpSource.Dispose() -> void
~NuGet.Protocol.HttpSource.GetJObjectAsync(NuGet.Protocol.HttpSourceRequest request, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<Newtonsoft.Json.Linq.JObject>
~NuGet.Protocol.HttpSource.HttpCacheDirectory.get -> string
~NuGet.Protocol.HttpSource.HttpCacheDirectory.set -> void
~NuGet.Protocol.HttpSource.HttpSource(NuGet.Configuration.PackageSource packageSource, System.Func<System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.HttpHandlerResource>> messageHandlerFactory, NuGet.Protocol.IThrottle throttle) -> void
~NuGet.Protocol.HttpSource.PackageSource.get -> string
~NuGet.Protocol.HttpSource.ProcessResponseAsync<T>(NuGet.Protocol.HttpSourceRequest request, System.Func<System.Net.Http.HttpResponseMessage, System.Threading.Tasks.Task<T>> processAsync, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<T>
~NuGet.Protocol.HttpSource.ProcessResponseAsync<T>(NuGet.Protocol.HttpSourceRequest request, System.Func<System.Net.Http.HttpResponseMessage, System.Threading.Tasks.Task<T>> processAsync, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<T>
~NuGet.Protocol.HttpSource.ProcessStreamAsync<T>(NuGet.Protocol.HttpSourceRequest request, System.Func<System.IO.Stream, System.Threading.Tasks.Task<T>> processAsync, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<T>
~NuGet.Protocol.HttpSource.ProcessStreamAsync<T>(NuGet.Protocol.HttpSourceRequest request, System.Func<System.IO.Stream, System.Threading.Tasks.Task<T>> processAsync, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<T>
~NuGet.Protocol.HttpSource.RetryHandler.get -> NuGet.Protocol.IHttpRetryHandler
~NuGet.Protocol.HttpSource.RetryHandler.set -> void
NuGet.Protocol.HttpSourceAuthenticationHandler
~NuGet.Protocol.HttpSourceAuthenticationHandler.HttpSourceAuthenticationHandler(NuGet.Configuration.PackageSource packageSource, System.Net.Http.HttpClientHandler clientHandler, NuGet.Configuration.ICredentialService credentialService) -> void
NuGet.Protocol.HttpSourceCachedRequest
~NuGet.Protocol.HttpSourceCachedRequest.AcceptHeaderValues.get -> System.Collections.Generic.IList<System.Net.Http.Headers.MediaTypeWithQualityHeaderValue>
~NuGet.Protocol.HttpSourceCachedRequest.CacheContext.get -> NuGet.Protocol.Core.Types.HttpSourceCacheContext
~NuGet.Protocol.HttpSourceCachedRequest.CacheKey.get -> string
NuGet.Protocol.HttpSourceCachedRequest.DownloadTimeout.get -> System.TimeSpan
NuGet.Protocol.HttpSourceCachedRequest.DownloadTimeout.set -> void
~NuGet.Protocol.HttpSourceCachedRequest.EnsureValidContents.get -> System.Action<System.IO.Stream>
~NuGet.Protocol.HttpSourceCachedRequest.EnsureValidContents.set -> void
~NuGet.Protocol.HttpSourceCachedRequest.HttpSourceCachedRequest(string uri, string cacheKey, NuGet.Protocol.Core.Types.HttpSourceCacheContext cacheContext) -> void
NuGet.Protocol.HttpSourceCachedRequest.IgnoreNotFounds.get -> bool
NuGet.Protocol.HttpSourceCachedRequest.IgnoreNotFounds.set -> void
NuGet.Protocol.HttpSourceCachedRequest.IsLastAttempt.get -> bool
NuGet.Protocol.HttpSourceCachedRequest.IsLastAttempt.set -> void
NuGet.Protocol.HttpSourceCachedRequest.IsRetry.get -> bool
NuGet.Protocol.HttpSourceCachedRequest.IsRetry.set -> void
NuGet.Protocol.HttpSourceCachedRequest.MaxTries.get -> int
NuGet.Protocol.HttpSourceCachedRequest.MaxTries.set -> void
NuGet.Protocol.HttpSourceCachedRequest.RequestTimeout.get -> System.TimeSpan
NuGet.Protocol.HttpSourceCachedRequest.RequestTimeout.set -> void
~NuGet.Protocol.HttpSourceCachedRequest.Uri.get -> string
NuGet.Protocol.HttpSourceCredentials
~NuGet.Protocol.HttpSourceCredentials.Credentials.get -> System.Net.ICredentials
~NuGet.Protocol.HttpSourceCredentials.Credentials.set -> void
NuGet.Protocol.HttpSourceCredentials.HttpSourceCredentials() -> void
~NuGet.Protocol.HttpSourceCredentials.HttpSourceCredentials(System.Net.ICredentials credentials = null) -> void
NuGet.Protocol.HttpSourceCredentials.Version.get -> System.Guid
NuGet.Protocol.HttpSourceRequest
NuGet.Protocol.HttpSourceRequest.DownloadTimeout.get -> System.TimeSpan
NuGet.Protocol.HttpSourceRequest.DownloadTimeout.set -> void
~NuGet.Protocol.HttpSourceRequest.HttpSourceRequest(System.Func<System.Net.Http.HttpRequestMessage> requestFactory) -> void
~NuGet.Protocol.HttpSourceRequest.HttpSourceRequest(System.Uri uri, NuGet.Common.ILogger log) -> void
~NuGet.Protocol.HttpSourceRequest.HttpSourceRequest(string uri, NuGet.Common.ILogger log) -> void
NuGet.Protocol.HttpSourceRequest.IgnoreNotFounds.get -> bool
NuGet.Protocol.HttpSourceRequest.IgnoreNotFounds.set -> void
NuGet.Protocol.HttpSourceRequest.IsLastAttempt.get -> bool
NuGet.Protocol.HttpSourceRequest.IsLastAttempt.set -> void
NuGet.Protocol.HttpSourceRequest.IsRetry.get -> bool
NuGet.Protocol.HttpSourceRequest.IsRetry.set -> void
NuGet.Protocol.HttpSourceRequest.MaxTries.get -> int
NuGet.Protocol.HttpSourceRequest.MaxTries.set -> void
~NuGet.Protocol.HttpSourceRequest.RequestFactory.get -> System.Func<System.Net.Http.HttpRequestMessage>
NuGet.Protocol.HttpSourceRequest.RequestTimeout.get -> System.TimeSpan
NuGet.Protocol.HttpSourceRequest.RequestTimeout.set -> void
NuGet.Protocol.HttpSourceResource
~NuGet.Protocol.HttpSourceResource.HttpSource.get -> NuGet.Protocol.HttpSource
~NuGet.Protocol.HttpSourceResource.HttpSourceResource(NuGet.Protocol.HttpSource httpSource) -> void
NuGet.Protocol.HttpSourceResourceProvider
NuGet.Protocol.HttpSourceResourceProvider.HttpSourceResourceProvider() -> void
NuGet.Protocol.HttpSourceResult
~NuGet.Protocol.HttpSourceResult.CacheFile.get -> string
NuGet.Protocol.HttpSourceResult.Dispose() -> void
NuGet.Protocol.HttpSourceResult.HttpSourceResult(NuGet.Protocol.HttpSourceResultStatus status) -> void
~NuGet.Protocol.HttpSourceResult.HttpSourceResult(NuGet.Protocol.HttpSourceResultStatus status, string cacheFileName, System.IO.Stream stream) -> void
NuGet.Protocol.HttpSourceResult.Status.get -> NuGet.Protocol.HttpSourceResultStatus
~NuGet.Protocol.HttpSourceResult.Stream.get -> System.IO.Stream
NuGet.Protocol.HttpSourceResultStatus
NuGet.Protocol.HttpSourceResultStatus.NoContent = 1 -> NuGet.Protocol.HttpSourceResultStatus
NuGet.Protocol.HttpSourceResultStatus.NotFound = 0 -> NuGet.Protocol.HttpSourceResultStatus
NuGet.Protocol.HttpSourceResultStatus.OpenedFromDisk = 2 -> NuGet.Protocol.HttpSourceResultStatus
NuGet.Protocol.HttpSourceResultStatus.OpenedFromNetwork = 3 -> NuGet.Protocol.HttpSourceResultStatus
NuGet.Protocol.HttpStreamValidation
NuGet.Protocol.IHttpRetryHandler
~NuGet.Protocol.IHttpRetryHandler.SendAsync(NuGet.Protocol.HttpRetryHandlerRequest request, NuGet.Common.ILogger log, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Net.Http.HttpResponseMessage>
~NuGet.Protocol.IHttpRetryHandler.SendAsync(NuGet.Protocol.HttpRetryHandlerRequest request, string sourceUri, NuGet.Common.ILogger log, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Net.Http.HttpResponseMessage>
NuGet.Protocol.IThrottle
NuGet.Protocol.IThrottle.Release() -> void
~NuGet.Protocol.IThrottle.WaitAsync() -> System.Threading.Tasks.Task
NuGet.Protocol.IV2FeedParser
~NuGet.Protocol.IV2FeedParser.GetPackagesPageAsync(string searchTerm, NuGet.Protocol.Core.Types.SearchFilter filters, int skip, int take, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Protocol.V2FeedPage>
~NuGet.Protocol.IV2FeedParser.GetSearchPageAsync(string searchTerm, NuGet.Protocol.Core.Types.SearchFilter filters, int skip, int take, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Protocol.V2FeedPage>
NuGet.Protocol.IVulnerabilityInfoResource
NuGet.Protocol.IVulnerabilityInfoResource.GetVulnerabilityInfoAsync(NuGet.Protocol.Core.Types.SourceCacheContext! cacheContext, NuGet.Common.ILogger! logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Protocol.Model.GetVulnerabilityInfoResult!>!
NuGet.Protocol.InvalidCacheProtocolException
~NuGet.Protocol.InvalidCacheProtocolException.InvalidCacheProtocolException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
~NuGet.Protocol.InvalidCacheProtocolException.InvalidCacheProtocolException(string message) -> void
~NuGet.Protocol.InvalidCacheProtocolException.InvalidCacheProtocolException(string message, System.Exception innerException) -> void
NuGet.Protocol.JsonExtensions
NuGet.Protocol.JsonProperties
NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed
~NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed.LegacyFeedCapabilityResourceV2Feed(NuGet.Protocol.V2FeedParser feedParser, string baseAddress) -> void
NuGet.Protocol.LocalAutoCompleteResource
~NuGet.Protocol.LocalAutoCompleteResource.GetPackageVersionsFromLocalPackageRepository(string packageId, string versionPrefix, bool includePrerelease, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Versioning.NuGetVersion>>
~NuGet.Protocol.LocalAutoCompleteResource.LocalAutoCompleteResource(NuGet.Protocol.FindLocalPackagesResource localResource) -> void
NuGet.Protocol.LocalAutoCompleteResourceProvider
NuGet.Protocol.LocalAutoCompleteResourceProvider.LocalAutoCompleteResourceProvider() -> void
NuGet.Protocol.LocalDependencyInfoResource
~NuGet.Protocol.LocalDependencyInfoResource.LocalDependencyInfoResource(NuGet.Protocol.FindLocalPackagesResource localResource, NuGet.Protocol.Core.Types.SourceRepository source) -> void
NuGet.Protocol.LocalDependencyInfoResourceProvider
NuGet.Protocol.LocalDependencyInfoResourceProvider.LocalDependencyInfoResourceProvider() -> void
NuGet.Protocol.LocalDownloadResource
~NuGet.Protocol.LocalDownloadResource.LocalDownloadResource(NuGet.Protocol.FindLocalPackagesResource localResource) -> void
~NuGet.Protocol.LocalDownloadResource.LocalDownloadResource(string source, NuGet.Protocol.FindLocalPackagesResource localResource) -> void
NuGet.Protocol.LocalDownloadResourceProvider
NuGet.Protocol.LocalDownloadResourceProvider.LocalDownloadResourceProvider() -> void
NuGet.Protocol.LocalFolderUtility
NuGet.Protocol.LocalMetadataResource
~NuGet.Protocol.LocalMetadataResource.LocalMetadataResource(NuGet.Protocol.FindLocalPackagesResource localResource) -> void
NuGet.Protocol.LocalMetadataResourceProvider
NuGet.Protocol.LocalMetadataResourceProvider.LocalMetadataResourceProvider() -> void
NuGet.Protocol.LocalPackageArchiveDownloader
~NuGet.Protocol.LocalPackageArchiveDownloader.ContentReader.get -> NuGet.Packaging.IAsyncPackageContentReader
~NuGet.Protocol.LocalPackageArchiveDownloader.CopyNupkgFileToAsync(string destinationFilePath, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>
~NuGet.Protocol.LocalPackageArchiveDownloader.CoreReader.get -> NuGet.Packaging.Core.IAsyncPackageCoreReader
NuGet.Protocol.LocalPackageArchiveDownloader.Dispose() -> void
~NuGet.Protocol.LocalPackageArchiveDownloader.GetPackageHashAsync(string hashAlgorithm, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<string>
~NuGet.Protocol.LocalPackageArchiveDownloader.LocalPackageArchiveDownloader(string source, string packageFilePath, NuGet.Packaging.Core.PackageIdentity packageIdentity, NuGet.Common.ILogger logger) -> void
~NuGet.Protocol.LocalPackageArchiveDownloader.SetExceptionHandler(System.Func<System.Exception, System.Threading.Tasks.Task<bool>> handleExceptionAsync) -> void
~NuGet.Protocol.LocalPackageArchiveDownloader.SetThrottle(System.Threading.SemaphoreSlim throttle) -> void
~NuGet.Protocol.LocalPackageArchiveDownloader.SignedPackageReader.get -> NuGet.Packaging.Signing.ISignedPackageReader
~NuGet.Protocol.LocalPackageArchiveDownloader.Source.get -> string
NuGet.Protocol.LocalPackageFileCache
NuGet.Protocol.LocalPackageFileCache.LocalPackageFileCache() -> void
~NuGet.Protocol.LocalPackageFileCache.UpdateLastAccessTime(string nupkgMetadataPath) -> void
NuGet.Protocol.LocalPackageInfo
NuGet.Protocol.LocalPackageInfo.LocalPackageInfo() -> void
~NuGet.Protocol.LocalPackageInfo.LocalPackageInfo(NuGet.Packaging.Core.PackageIdentity identity, string path, System.DateTime lastWriteTimeUtc, System.Lazy<NuGet.Packaging.NuspecReader> nuspec, System.Func<NuGet.Packaging.PackageReaderBase> getPackageReader) -> void
~NuGet.Protocol.LocalPackageInfo.LocalPackageInfo(NuGet.Packaging.Core.PackageIdentity identity, string path, System.DateTime lastWriteTimeUtc, System.Lazy<NuGet.Packaging.NuspecReader> nuspec, bool useFolder) -> void
NuGet.Protocol.LocalPackageListResource
~NuGet.Protocol.LocalPackageListResource.LocalPackageListResource(NuGet.Protocol.Core.Types.PackageSearchResource localPackageSearchResource, string baseAddress) -> void
NuGet.Protocol.LocalPackageMetadataResource
~NuGet.Protocol.LocalPackageMetadataResource.LocalPackageMetadataResource(NuGet.Protocol.FindLocalPackagesResource localResource) -> void
NuGet.Protocol.LocalPackageMetadataResourceProvider
NuGet.Protocol.LocalPackageMetadataResourceProvider.LocalPackageMetadataResourceProvider() -> void
NuGet.Protocol.LocalPackageSearchMetadata
~NuGet.Protocol.LocalPackageSearchMetadata.Authors.get -> string
~NuGet.Protocol.LocalPackageSearchMetadata.DependencySets.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageDependencyGroup>
~NuGet.Protocol.LocalPackageSearchMetadata.Description.get -> string
NuGet.Protocol.LocalPackageSearchMetadata.DownloadCount.get -> long?
~NuGet.Protocol.LocalPackageSearchMetadata.GetDeprecationMetadataAsync() -> System.Threading.Tasks.Task<NuGet.Protocol.PackageDeprecationMetadata>
~NuGet.Protocol.LocalPackageSearchMetadata.GetVersionsAsync() -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.VersionInfo>>
~NuGet.Protocol.LocalPackageSearchMetadata.IconUrl.get -> System.Uri
~NuGet.Protocol.LocalPackageSearchMetadata.Identity.get -> NuGet.Packaging.Core.PackageIdentity
NuGet.Protocol.LocalPackageSearchMetadata.IsListed.get -> bool
~NuGet.Protocol.LocalPackageSearchMetadata.LicenseMetadata.get -> NuGet.Packaging.LicenseMetadata
~NuGet.Protocol.LocalPackageSearchMetadata.LicenseUrl.get -> System.Uri
~NuGet.Protocol.LocalPackageSearchMetadata.LoadFileAsText(string path) -> string
~NuGet.Protocol.LocalPackageSearchMetadata.LocalPackageSearchMetadata(NuGet.Protocol.LocalPackageInfo package) -> void
~NuGet.Protocol.LocalPackageSearchMetadata.Owners.get -> string
~NuGet.Protocol.LocalPackageSearchMetadata.PackageDetailsUrl.get -> System.Uri
~NuGet.Protocol.LocalPackageSearchMetadata.PackagePath.get -> string
~NuGet.Protocol.LocalPackageSearchMetadata.PackageReader.get -> System.Func<NuGet.Packaging.PackageReaderBase>
NuGet.Protocol.LocalPackageSearchMetadata.PrefixReserved.get -> bool
~NuGet.Protocol.LocalPackageSearchMetadata.ProjectUrl.get -> System.Uri
NuGet.Protocol.LocalPackageSearchMetadata.Published.get -> System.DateTimeOffset?
~NuGet.Protocol.LocalPackageSearchMetadata.ReadmeUrl.get -> System.Uri
~NuGet.Protocol.LocalPackageSearchMetadata.ReportAbuseUrl.get -> System.Uri
NuGet.Protocol.LocalPackageSearchMetadata.RequireLicenseAcceptance.get -> bool
~NuGet.Protocol.LocalPackageSearchMetadata.Summary.get -> string
~NuGet.Protocol.LocalPackageSearchMetadata.Tags.get -> string
~NuGet.Protocol.LocalPackageSearchMetadata.Title.get -> string
~NuGet.Protocol.LocalPackageSearchMetadata.Vulnerabilities.get -> System.Collections.Generic.IEnumerable<NuGet.Protocol.PackageVulnerabilityMetadata>
NuGet.Protocol.LocalPackageSearchResource
~NuGet.Protocol.LocalPackageSearchResource.LocalPackageSearchResource(NuGet.Protocol.FindLocalPackagesResource localResource) -> void
NuGet.Protocol.LocalPackageSearchResourceProvider
NuGet.Protocol.LocalPackageSearchResourceProvider.LocalPackageSearchResourceProvider() -> void
NuGet.Protocol.LocalRepositories.LocalPackageListResourceProvider
NuGet.Protocol.LocalRepositories.LocalPackageListResourceProvider.LocalPackageListResourceProvider() -> void
NuGet.Protocol.LocalV2FindPackageByIdResource
~NuGet.Protocol.LocalV2FindPackageByIdResource.LocalV2FindPackageByIdResource(NuGet.Configuration.PackageSource packageSource) -> void
NuGet.Protocol.LocalV2FindPackageByIdResourceProvider
NuGet.Protocol.LocalV2FindPackageByIdResourceProvider.LocalV2FindPackageByIdResourceProvider() -> void
NuGet.Protocol.LocalV3FindPackageByIdResource
NuGet.Protocol.LocalV3FindPackageByIdResource.IsFallbackFolder.get -> bool
NuGet.Protocol.LocalV3FindPackageByIdResource.IsFallbackFolder.set -> void
~NuGet.Protocol.LocalV3FindPackageByIdResource.LocalV3FindPackageByIdResource(NuGet.Configuration.PackageSource packageSource) -> void
~NuGet.Protocol.LocalV3FindPackageByIdResource.PackageFileCache.get -> NuGet.Protocol.LocalPackageFileCache
~NuGet.Protocol.LocalV3FindPackageByIdResource.PackageFileCache.set -> void
NuGet.Protocol.LocalV3FindPackageByIdResourceProvider
NuGet.Protocol.LocalV3FindPackageByIdResourceProvider.LocalV3FindPackageByIdResourceProvider() -> void
NuGet.Protocol.MetadataFieldConverter
NuGet.Protocol.MetadataFieldConverter.MetadataFieldConverter() -> void
NuGet.Protocol.MetadataReferenceCache
NuGet.Protocol.MetadataReferenceCache.GetObject<T>(T input) -> T
~NuGet.Protocol.MetadataReferenceCache.GetString(string s) -> string
~NuGet.Protocol.MetadataReferenceCache.GetVersion(string s) -> NuGet.Versioning.NuGetVersion
NuGet.Protocol.MetadataReferenceCache.MetadataReferenceCache() -> void
NuGet.Protocol.MetadataResourceV2Feed
~NuGet.Protocol.MetadataResourceV2Feed.MetadataResourceV2Feed(NuGet.Protocol.V2FeedParser feedParser, NuGet.Protocol.Core.Types.SourceRepository source) -> void
NuGet.Protocol.MetadataResourceV2FeedProvider
NuGet.Protocol.MetadataResourceV2FeedProvider.MetadataResourceV2FeedProvider() -> void
NuGet.Protocol.MetadataResourceV3
~NuGet.Protocol.MetadataResourceV3.MetadataResourceV3(NuGet.Protocol.RegistrationResourceV3 regResource) -> void
NuGet.Protocol.MetadataResourceV3Provider
NuGet.Protocol.MetadataResourceV3Provider.MetadataResourceV3Provider() -> void
NuGet.Protocol.Model.GetVulnerabilityInfoResult
NuGet.Protocol.Model.GetVulnerabilityInfoResult.Exceptions.get -> System.AggregateException?
NuGet.Protocol.Model.GetVulnerabilityInfoResult.GetVulnerabilityInfoResult(System.Collections.Generic.IReadOnlyList<System.Collections.Generic.IReadOnlyDictionary<string!, System.Collections.Generic.IReadOnlyList<NuGet.Protocol.Model.PackageVulnerabilityInfo!>!>!>? knownVulnerabilities, System.AggregateException? exceptions) -> void
NuGet.Protocol.Model.GetVulnerabilityInfoResult.KnownVulnerabilities.get -> System.Collections.Generic.IReadOnlyList<System.Collections.Generic.IReadOnlyDictionary<string!, System.Collections.Generic.IReadOnlyList<NuGet.Protocol.Model.PackageVulnerabilityInfo!>!>!>?
NuGet.Protocol.Model.PackageVulnerabilityInfo
NuGet.Protocol.Model.PackageVulnerabilityInfo.Equals(NuGet.Protocol.Model.PackageVulnerabilityInfo? other) -> bool
NuGet.Protocol.Model.PackageVulnerabilityInfo.PackageVulnerabilityInfo(System.Uri! url, int severity, NuGet.Versioning.VersionRange! versions) -> void
NuGet.Protocol.Model.PackageVulnerabilityInfo.Severity.get -> int
NuGet.Protocol.Model.PackageVulnerabilityInfo.Url.get -> System.Uri!
NuGet.Protocol.Model.PackageVulnerabilityInfo.Versions.get -> NuGet.Versioning.VersionRange!
NuGet.Protocol.Model.V3VulnerabilityIndexEntry
NuGet.Protocol.Model.V3VulnerabilityIndexEntry.Comment.get -> string?
NuGet.Protocol.Model.V3VulnerabilityIndexEntry.Name.get -> string!
NuGet.Protocol.Model.V3VulnerabilityIndexEntry.Updated.get -> string!
NuGet.Protocol.Model.V3VulnerabilityIndexEntry.Url.get -> System.Uri!
NuGet.Protocol.Model.V3VulnerabilityIndexEntry.V3VulnerabilityIndexEntry(string! name, System.Uri! url, string! updated, string? comment) -> void
NuGet.Protocol.NuGetVersionConverter
NuGet.Protocol.NuGetVersionConverter.NuGetVersionConverter() -> void
NuGet.Protocol.NullThrottle
NuGet.Protocol.NullThrottle.NullThrottle() -> void
NuGet.Protocol.NullThrottle.Release() -> void
~NuGet.Protocol.NullThrottle.WaitAsync() -> System.Threading.Tasks.Task
NuGet.Protocol.ODataServiceDocumentResourceV2
~NuGet.Protocol.ODataServiceDocumentResourceV2.BaseAddress.get -> string
~NuGet.Protocol.ODataServiceDocumentResourceV2.ODataServiceDocumentResourceV2(string baseAddress, System.DateTime requestTime) -> void
NuGet.Protocol.ODataServiceDocumentResourceV2Provider
NuGet.Protocol.ODataServiceDocumentResourceV2Provider.MaxCacheDuration.get -> System.TimeSpan
NuGet.Protocol.ODataServiceDocumentResourceV2Provider.MaxCacheDuration.set -> void
NuGet.Protocol.ODataServiceDocumentResourceV2Provider.ODataServiceDocumentCacheInfo
NuGet.Protocol.ODataServiceDocumentResourceV2Provider.ODataServiceDocumentCacheInfo.CachedTime.get -> System.DateTime
NuGet.Protocol.ODataServiceDocumentResourceV2Provider.ODataServiceDocumentCacheInfo.CachedTime.set -> void
NuGet.Protocol.ODataServiceDocumentResourceV2Provider.ODataServiceDocumentCacheInfo.ODataServiceDocumentCacheInfo() -> void
~NuGet.Protocol.ODataServiceDocumentResourceV2Provider.ODataServiceDocumentCacheInfo.ServiceDocument.get -> NuGet.Protocol.ODataServiceDocumentResourceV2
~NuGet.Protocol.ODataServiceDocumentResourceV2Provider.ODataServiceDocumentCacheInfo.ServiceDocument.set -> void
NuGet.Protocol.ODataServiceDocumentResourceV2Provider.ODataServiceDocumentResourceV2Provider() -> void
NuGet.Protocol.PackageDependencyGroupConverter
NuGet.Protocol.PackageDependencyGroupConverter.PackageDependencyGroupConverter() -> void
NuGet.Protocol.PackageDeprecationMetadata
~NuGet.Protocol.PackageDeprecationMetadata.AlternatePackage.get -> NuGet.Protocol.AlternatePackageMetadata
~NuGet.Protocol.PackageDeprecationMetadata.Message.get -> string
NuGet.Protocol.PackageDeprecationMetadata.PackageDeprecationMetadata() -> void
~NuGet.Protocol.PackageDeprecationMetadata.Reasons.get -> System.Collections.Generic.IEnumerable<string>
NuGet.Protocol.PackageDetailsUriResourceV3
~NuGet.Protocol.PackageDetailsUriResourceV3.GetUri(string id, NuGet.Versioning.NuGetVersion version) -> System.Uri
NuGet.Protocol.PackageDetailsUriResourceV3Provider
NuGet.Protocol.PackageDetailsUriResourceV3Provider.PackageDetailsUriResourceV3Provider() -> void
NuGet.Protocol.PackageMetadataResourceV2Feed
~NuGet.Protocol.PackageMetadataResourceV2Feed.PackageMetadataResourceV2Feed(NuGet.Protocol.HttpSourceResource httpSourceResource, string baseAddress, NuGet.Configuration.PackageSource packageSource) -> void
NuGet.Protocol.PackageMetadataResourceV2FeedProvider
NuGet.Protocol.PackageMetadataResourceV2FeedProvider.PackageMetadataResourceV2FeedProvider() -> void
NuGet.Protocol.PackageMetadataResourceV3
~NuGet.Protocol.PackageMetadataResourceV3.PackageMetadataResourceV3(NuGet.Protocol.HttpSource client, NuGet.Protocol.RegistrationResourceV3 regResource, NuGet.Protocol.ReportAbuseResourceV3 reportAbuseResource, NuGet.Protocol.PackageDetailsUriResourceV3 packageDetailsUriResource) -> void
NuGet.Protocol.PackageMetadataResourceV3Provider
NuGet.Protocol.PackageMetadataResourceV3Provider.PackageMetadataResourceV3Provider() -> void
NuGet.Protocol.PackageNotFoundProtocolException
~NuGet.Protocol.PackageNotFoundProtocolException.PackageIdentity.get -> NuGet.Packaging.Core.PackageIdentity
~NuGet.Protocol.PackageNotFoundProtocolException.PackageNotFoundProtocolException(NuGet.Packaging.Core.PackageIdentity package) -> void
~NuGet.Protocol.PackageNotFoundProtocolException.PackageNotFoundProtocolException(NuGet.Packaging.Core.PackageIdentity package, System.Exception innerException) -> void
NuGet.Protocol.PackageSearchMetadata
~NuGet.Protocol.PackageSearchMetadata.Authors.get -> string
~NuGet.Protocol.PackageSearchMetadata.DependencySets.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageDependencyGroup>
~NuGet.Protocol.PackageSearchMetadata.DependencySetsInternal.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageDependencyGroup>
~NuGet.Protocol.PackageSearchMetadata.DeprecationMetadata.get -> NuGet.Protocol.PackageDeprecationMetadata
~NuGet.Protocol.PackageSearchMetadata.Description.get -> string
NuGet.Protocol.PackageSearchMetadata.DownloadCount.get -> long?
~NuGet.Protocol.PackageSearchMetadata.GetDeprecationMetadataAsync() -> System.Threading.Tasks.Task<NuGet.Protocol.PackageDeprecationMetadata>
~NuGet.Protocol.PackageSearchMetadata.GetVersionsAsync() -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.VersionInfo>>
~NuGet.Protocol.PackageSearchMetadata.IconUrl.get -> System.Uri
~NuGet.Protocol.PackageSearchMetadata.Identity.get -> NuGet.Packaging.Core.PackageIdentity
NuGet.Protocol.PackageSearchMetadata.IsListed.get -> bool
~NuGet.Protocol.PackageSearchMetadata.LicenseExpression.get -> string
~NuGet.Protocol.PackageSearchMetadata.LicenseExpressionVersion.get -> string
~NuGet.Protocol.PackageSearchMetadata.LicenseMetadata.get -> NuGet.Packaging.LicenseMetadata
~NuGet.Protocol.PackageSearchMetadata.LicenseUrl.get -> System.Uri
~NuGet.Protocol.PackageSearchMetadata.Owners.get -> string
~NuGet.Protocol.PackageSearchMetadata.PackageDetailsUrl.get -> System.Uri
~NuGet.Protocol.PackageSearchMetadata.PackageDetailsUrl.set -> void
~NuGet.Protocol.PackageSearchMetadata.PackageId.get -> string
NuGet.Protocol.PackageSearchMetadata.PackageSearchMetadata() -> void
~NuGet.Protocol.PackageSearchMetadata.ParsedVersions.get -> NuGet.Protocol.Core.Types.VersionInfo[]
NuGet.Protocol.PackageSearchMetadata.PrefixReserved.get -> bool
~NuGet.Protocol.PackageSearchMetadata.ProjectUrl.get -> System.Uri
NuGet.Protocol.PackageSearchMetadata.Published.get -> System.DateTimeOffset?
~NuGet.Protocol.PackageSearchMetadata.ReadmeUrl.get -> System.Uri
~NuGet.Protocol.PackageSearchMetadata.ReportAbuseUrl.get -> System.Uri
~NuGet.Protocol.PackageSearchMetadata.ReportAbuseUrl.set -> void
NuGet.Protocol.PackageSearchMetadata.RequireLicenseAcceptance.get -> bool
~NuGet.Protocol.PackageSearchMetadata.Summary.get -> string
~NuGet.Protocol.PackageSearchMetadata.Tags.get -> string
~NuGet.Protocol.PackageSearchMetadata.Title.get -> string
~NuGet.Protocol.PackageSearchMetadata.Version.get -> NuGet.Versioning.NuGetVersion
~NuGet.Protocol.PackageSearchMetadata.Vulnerabilities.get -> System.Collections.Generic.IEnumerable<NuGet.Protocol.PackageVulnerabilityMetadata>
NuGet.Protocol.PackageSearchMetadataRegistration
~NuGet.Protocol.PackageSearchMetadataRegistration.CatalogUri.get -> System.Uri
NuGet.Protocol.PackageSearchMetadataRegistration.PackageSearchMetadataRegistration() -> void
NuGet.Protocol.PackageSearchMetadataV2Feed
~NuGet.Protocol.PackageSearchMetadataV2Feed.Authors.get -> string
NuGet.Protocol.PackageSearchMetadataV2Feed.Created.get -> System.DateTimeOffset?
~NuGet.Protocol.PackageSearchMetadataV2Feed.DependencySets.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageDependencyGroup>
~NuGet.Protocol.PackageSearchMetadataV2Feed.DeprecationMetadata.get -> NuGet.Protocol.PackageDeprecationMetadata
~NuGet.Protocol.PackageSearchMetadataV2Feed.Description.get -> string
NuGet.Protocol.PackageSearchMetadataV2Feed.DownloadCount.get -> long?
~NuGet.Protocol.PackageSearchMetadataV2Feed.GetDeprecationMetadataAsync() -> System.Threading.Tasks.Task<NuGet.Protocol.PackageDeprecationMetadata>
~NuGet.Protocol.PackageSearchMetadataV2Feed.GetVersionsAsync() -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.VersionInfo>>
~NuGet.Protocol.PackageSearchMetadataV2Feed.IconUrl.get -> System.Uri
~NuGet.Protocol.PackageSearchMetadataV2Feed.Identity.get -> NuGet.Packaging.Core.PackageIdentity
NuGet.Protocol.PackageSearchMetadataV2Feed.IsListed.get -> bool
NuGet.Protocol.PackageSearchMetadataV2Feed.LastEdited.get -> System.DateTimeOffset?
~NuGet.Protocol.PackageSearchMetadataV2Feed.LicenseMetadata.get -> NuGet.Packaging.LicenseMetadata
~NuGet.Protocol.PackageSearchMetadataV2Feed.LicenseUrl.get -> System.Uri
~NuGet.Protocol.PackageSearchMetadataV2Feed.Owners.get -> string
~NuGet.Protocol.PackageSearchMetadataV2Feed.PackageDetailsUrl.get -> System.Uri
~NuGet.Protocol.PackageSearchMetadataV2Feed.PackageId.get -> string
~NuGet.Protocol.PackageSearchMetadataV2Feed.PackageSearchMetadataV2Feed(NuGet.Protocol.V2FeedPackageInfo package) -> void
~NuGet.Protocol.PackageSearchMetadataV2Feed.PackageSearchMetadataV2Feed(NuGet.Protocol.V2FeedPackageInfo package, NuGet.Protocol.MetadataReferenceCache metadataCache) -> void
NuGet.Protocol.PackageSearchMetadataV2Feed.PrefixReserved.get -> bool
~NuGet.Protocol.PackageSearchMetadataV2Feed.ProjectUrl.get -> System.Uri
NuGet.Protocol.PackageSearchMetadataV2Feed.Published.get -> System.DateTimeOffset?
~NuGet.Protocol.PackageSearchMetadataV2Feed.ReadmeUrl.get -> System.Uri
~NuGet.Protocol.PackageSearchMetadataV2Feed.ReportAbuseUrl.get -> System.Uri
NuGet.Protocol.PackageSearchMetadataV2Feed.RequireLicenseAcceptance.get -> bool
~NuGet.Protocol.PackageSearchMetadataV2Feed.Summary.get -> string
~NuGet.Protocol.PackageSearchMetadataV2Feed.Tags.get -> string
~NuGet.Protocol.PackageSearchMetadataV2Feed.Title.get -> string
~NuGet.Protocol.PackageSearchMetadataV2Feed.Version.get -> NuGet.Versioning.NuGetVersion
~NuGet.Protocol.PackageSearchMetadataV2Feed.Vulnerabilities.get -> System.Collections.Generic.IEnumerable<NuGet.Protocol.PackageVulnerabilityMetadata>
NuGet.Protocol.PackageSearchResourceV2Feed
~NuGet.Protocol.PackageSearchResourceV2Feed.PackageSearchResourceV2Feed(NuGet.Protocol.HttpSourceResource httpSourceResource, string baseAddress, NuGet.Configuration.PackageSource packageSource) -> void
NuGet.Protocol.PackageSearchResourceV2FeedProvider
NuGet.Protocol.PackageSearchResourceV2FeedProvider.PackageSearchResourceV2FeedProvider() -> void
NuGet.Protocol.PackageSearchResourceV3
~NuGet.Protocol.PackageSearchResourceV3.PackageSearchResourceV3(NuGet.Protocol.RawSearchResourceV3 searchResource) -> void
NuGet.Protocol.PackageSearchResourceV3Provider
NuGet.Protocol.PackageSearchResourceV3Provider.PackageSearchResourceV3Provider() -> void
NuGet.Protocol.PackageUpdateResourceV2Provider
NuGet.Protocol.PackageUpdateResourceV2Provider.PackageUpdateResourceV2Provider() -> void
NuGet.Protocol.PackageUpdateResourceV3Provider
NuGet.Protocol.PackageUpdateResourceV3Provider.PackageUpdateResourceV3Provider() -> void
NuGet.Protocol.PackageVulnerabilityMetadata
~NuGet.Protocol.PackageVulnerabilityMetadata.AdvisoryUrl.get -> System.Uri
NuGet.Protocol.PackageVulnerabilityMetadata.PackageVulnerabilityMetadata() -> void
NuGet.Protocol.PackageVulnerabilityMetadata.Severity.get -> int
NuGet.Protocol.PluginFindPackageByIdResourceProvider
NuGet.Protocol.PluginFindPackageByIdResourceProvider.PluginFindPackageByIdResourceProvider() -> void
NuGet.Protocol.Plugins.AutomaticProgressReporter
NuGet.Protocol.Plugins.AutomaticProgressReporter.Dispose() -> void
NuGet.Protocol.Plugins.CloseRequestHandler
NuGet.Protocol.Plugins.CloseRequestHandler.CancellationToken.get -> System.Threading.CancellationToken
~NuGet.Protocol.Plugins.CloseRequestHandler.CloseRequestHandler(NuGet.Protocol.Plugins.IPlugin plugin) -> void
NuGet.Protocol.Plugins.CloseRequestHandler.Dispose() -> void
~NuGet.Protocol.Plugins.CloseRequestHandler.HandleResponseAsync(NuGet.Protocol.Plugins.IConnection connection, NuGet.Protocol.Plugins.Message request, NuGet.Protocol.Plugins.IResponseHandler responseHandler, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
NuGet.Protocol.Plugins.Connection
NuGet.Protocol.Plugins.Connection.Close() -> void
~NuGet.Protocol.Plugins.Connection.ConnectAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
~NuGet.Protocol.Plugins.Connection.Connection(NuGet.Protocol.Plugins.IMessageDispatcher dispatcher, NuGet.Protocol.Plugins.ISender sender, NuGet.Protocol.Plugins.IReceiver receiver, NuGet.Protocol.Plugins.ConnectionOptions options) -> void
NuGet.Protocol.Plugins.Connection.Dispose() -> void
NuGet.Protocol.Plugins.Connection.Faulted -> System.EventHandler<NuGet.Protocol.Plugins.ProtocolErrorEventArgs>
~NuGet.Protocol.Plugins.Connection.MessageDispatcher.get -> NuGet.Protocol.Plugins.IMessageDispatcher
NuGet.Protocol.Plugins.Connection.MessageReceived -> System.EventHandler<NuGet.Protocol.Plugins.MessageEventArgs>
~NuGet.Protocol.Plugins.Connection.Options.get -> NuGet.Protocol.Plugins.ConnectionOptions
~NuGet.Protocol.Plugins.Connection.ProtocolVersion.get -> NuGet.Versioning.SemanticVersion
~NuGet.Protocol.Plugins.Connection.SendAsync(NuGet.Protocol.Plugins.Message message, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
~NuGet.Protocol.Plugins.Connection.SendRequestAndReceiveResponseAsync<TOutbound, TInbound>(NuGet.Protocol.Plugins.MessageMethod method, TOutbound payload, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<TInbound>
NuGet.Protocol.Plugins.Connection.State.get -> NuGet.Protocol.Plugins.ConnectionState
NuGet.Protocol.Plugins.ConnectionOptions
~NuGet.Protocol.Plugins.ConnectionOptions.ConnectionOptions(NuGet.Versioning.SemanticVersion protocolVersion, NuGet.Versioning.SemanticVersion minimumProtocolVersion, System.TimeSpan handshakeTimeout, System.TimeSpan requestTimeout) -> void
NuGet.Protocol.Plugins.ConnectionOptions.HandshakeTimeout.get -> System.TimeSpan
~NuGet.Protocol.Plugins.ConnectionOptions.MinimumProtocolVersion.get -> NuGet.Versioning.SemanticVersion
~NuGet.Protocol.Plugins.ConnectionOptions.ProtocolVersion.get -> NuGet.Versioning.SemanticVersion
NuGet.Protocol.Plugins.ConnectionOptions.RequestTimeout.get -> System.TimeSpan
NuGet.Protocol.Plugins.ConnectionOptions.SetRequestTimeout(System.TimeSpan requestTimeout) -> void
NuGet.Protocol.Plugins.ConnectionState
NuGet.Protocol.Plugins.ConnectionState.Closed = 2 -> NuGet.Protocol.Plugins.ConnectionState
NuGet.Protocol.Plugins.ConnectionState.Closing = 1 -> NuGet.Protocol.Plugins.ConnectionState
NuGet.Protocol.Plugins.ConnectionState.Connected = 6 -> NuGet.Protocol.Plugins.ConnectionState
NuGet.Protocol.Plugins.ConnectionState.Connecting = 4 -> NuGet.Protocol.Plugins.ConnectionState
NuGet.Protocol.Plugins.ConnectionState.FailedToHandshake = 0 -> NuGet.Protocol.Plugins.ConnectionState
NuGet.Protocol.Plugins.ConnectionState.Handshaking = 5 -> NuGet.Protocol.Plugins.ConnectionState
NuGet.Protocol.Plugins.ConnectionState.ReadyToConnect = 3 -> NuGet.Protocol.Plugins.ConnectionState
NuGet.Protocol.Plugins.CopyFilesInPackageRequest
~NuGet.Protocol.Plugins.CopyFilesInPackageRequest.CopyFilesInPackageRequest(string packageSourceRepository, string packageId, string packageVersion, System.Collections.Generic.IEnumerable<string> filesInPackage, string destinationFolderPath) -> void
~NuGet.Protocol.Plugins.CopyFilesInPackageRequest.DestinationFolderPath.get -> string
~NuGet.Protocol.Plugins.CopyFilesInPackageRequest.FilesInPackage.get -> System.Collections.Generic.IEnumerable<string>
~NuGet.Protocol.Plugins.CopyFilesInPackageRequest.PackageId.get -> string
~NuGet.Protocol.Plugins.CopyFilesInPackageRequest.PackageSourceRepository.get -> string
~NuGet.Protocol.Plugins.CopyFilesInPackageRequest.PackageVersion.get -> string
NuGet.Protocol.Plugins.CopyFilesInPackageResponse
~NuGet.Protocol.Plugins.CopyFilesInPackageResponse.CopiedFiles.get -> System.Collections.Generic.IEnumerable<string>
~NuGet.Protocol.Plugins.CopyFilesInPackageResponse.CopyFilesInPackageResponse(NuGet.Protocol.Plugins.MessageResponseCode responseCode, System.Collections.Generic.IEnumerable<string> copiedFiles) -> void
NuGet.Protocol.Plugins.CopyFilesInPackageResponse.ResponseCode.get -> NuGet.Protocol.Plugins.MessageResponseCode
NuGet.Protocol.Plugins.CopyNupkgFileRequest
~NuGet.Protocol.Plugins.CopyNupkgFileRequest.CopyNupkgFileRequest(string packageSourceRepository, string packageId, string packageVersion, string destinationFilePath) -> void
~NuGet.Protocol.Plugins.CopyNupkgFileRequest.DestinationFilePath.get -> string
~NuGet.Protocol.Plugins.CopyNupkgFileRequest.PackageId.get -> string
~NuGet.Protocol.Plugins.CopyNupkgFileRequest.PackageSourceRepository.get -> string
~NuGet.Protocol.Plugins.CopyNupkgFileRequest.PackageVersion.get -> string
NuGet.Protocol.Plugins.CopyNupkgFileResponse
NuGet.Protocol.Plugins.CopyNupkgFileResponse.CopyNupkgFileResponse(NuGet.Protocol.Plugins.MessageResponseCode responseCode) -> void
NuGet.Protocol.Plugins.CopyNupkgFileResponse.ResponseCode.get -> NuGet.Protocol.Plugins.MessageResponseCode
NuGet.Protocol.Plugins.EmbeddedSignatureVerifier
NuGet.Protocol.Plugins.EmbeddedSignatureVerifier.EmbeddedSignatureVerifier() -> void
NuGet.Protocol.Plugins.FallbackEmbeddedSignatureVerifier
NuGet.Protocol.Plugins.FallbackEmbeddedSignatureVerifier.FallbackEmbeddedSignatureVerifier() -> void
NuGet.Protocol.Plugins.Fault
~NuGet.Protocol.Plugins.Fault.Fault(string message) -> void
~NuGet.Protocol.Plugins.Fault.Message.get -> string
NuGet.Protocol.Plugins.FaultedPluginEventArgs
~NuGet.Protocol.Plugins.FaultedPluginEventArgs.Exception.get -> System.Exception
~NuGet.Protocol.Plugins.FaultedPluginEventArgs.FaultedPluginEventArgs(NuGet.Protocol.Plugins.IPlugin plugin, System.Exception exception) -> void
~NuGet.Protocol.Plugins.FaultedPluginEventArgs.Plugin.get -> NuGet.Protocol.Plugins.IPlugin
NuGet.Protocol.Plugins.GetAuthenticationCredentialsRequest
NuGet.Protocol.Plugins.GetAuthenticationCredentialsRequest.CanShowDialog.get -> bool
~NuGet.Protocol.Plugins.GetAuthenticationCredentialsRequest.GetAuthenticationCredentialsRequest(System.Uri uri, bool isRetry, bool isNonInteractive, bool canShowDialog) -> void
NuGet.Protocol.Plugins.GetAuthenticationCredentialsRequest.IsNonInteractive.get -> bool
NuGet.Protocol.Plugins.GetAuthenticationCredentialsRequest.IsRetry.get -> bool
~NuGet.Protocol.Plugins.GetAuthenticationCredentialsRequest.Uri.get -> System.Uri
NuGet.Protocol.Plugins.GetAuthenticationCredentialsResponse
~NuGet.Protocol.Plugins.GetAuthenticationCredentialsResponse.AuthenticationTypes.get -> System.Collections.Generic.IList<string>
~NuGet.Protocol.Plugins.GetAuthenticationCredentialsResponse.GetAuthenticationCredentialsResponse(string username, string password, string message, System.Collections.Generic.IList<string> authenticationTypes, NuGet.Protocol.Plugins.MessageResponseCode responseCode) -> void
NuGet.Protocol.Plugins.GetAuthenticationCredentialsResponse.IsValid() -> bool
~NuGet.Protocol.Plugins.GetAuthenticationCredentialsResponse.Message.get -> string
~NuGet.Protocol.Plugins.GetAuthenticationCredentialsResponse.Password.get -> string
NuGet.Protocol.Plugins.GetAuthenticationCredentialsResponse.ResponseCode.get -> NuGet.Protocol.Plugins.MessageResponseCode
~NuGet.Protocol.Plugins.GetAuthenticationCredentialsResponse.Username.get -> string
NuGet.Protocol.Plugins.GetCredentialsRequest
~NuGet.Protocol.Plugins.GetCredentialsRequest.GetCredentialsRequest(string packageSourceRepository, System.Net.HttpStatusCode statusCode) -> void
~NuGet.Protocol.Plugins.GetCredentialsRequest.PackageSourceRepository.get -> string
NuGet.Protocol.Plugins.GetCredentialsRequest.StatusCode.get -> System.Net.HttpStatusCode
NuGet.Protocol.Plugins.GetCredentialsRequestHandler
~NuGet.Protocol.Plugins.GetCredentialsRequestHandler.AddOrUpdateSourceRepository(NuGet.Protocol.Core.Types.SourceRepository sourceRepository) -> void
NuGet.Protocol.Plugins.GetCredentialsRequestHandler.CancellationToken.get -> System.Threading.CancellationToken
NuGet.Protocol.Plugins.GetCredentialsRequestHandler.Dispose() -> void
~NuGet.Protocol.Plugins.GetCredentialsRequestHandler.GetCredentialsRequestHandler(NuGet.Protocol.Plugins.IPlugin plugin, System.Net.IWebProxy proxy, NuGet.Configuration.ICredentialService credentialService) -> void
~NuGet.Protocol.Plugins.GetCredentialsRequestHandler.HandleResponseAsync(NuGet.Protocol.Plugins.IConnection connection, NuGet.Protocol.Plugins.Message request, NuGet.Protocol.Plugins.IResponseHandler responseHandler, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
NuGet.Protocol.Plugins.GetCredentialsResponse
~NuGet.Protocol.Plugins.GetCredentialsResponse.AuthenticationTypes.get -> System.Collections.Generic.IReadOnlyList<string>
~NuGet.Protocol.Plugins.GetCredentialsResponse.GetCredentialsResponse(NuGet.Protocol.Plugins.MessageResponseCode responseCode, string username, string password, System.Collections.Generic.IReadOnlyList<string> authenticationTypes = null) -> void
~NuGet.Protocol.Plugins.GetCredentialsResponse.Password.get -> string
NuGet.Protocol.Plugins.GetCredentialsResponse.ResponseCode.get -> NuGet.Protocol.Plugins.MessageResponseCode
~NuGet.Protocol.Plugins.GetCredentialsResponse.Username.get -> string
NuGet.Protocol.Plugins.GetFilesInPackageRequest
~NuGet.Protocol.Plugins.GetFilesInPackageRequest.GetFilesInPackageRequest(string packageSourceRepository, string packageId, string packageVersion) -> void
~NuGet.Protocol.Plugins.GetFilesInPackageRequest.PackageId.get -> string
~NuGet.Protocol.Plugins.GetFilesInPackageRequest.PackageSourceRepository.get -> string
~NuGet.Protocol.Plugins.GetFilesInPackageRequest.PackageVersion.get -> string
NuGet.Protocol.Plugins.GetFilesInPackageResponse
~NuGet.Protocol.Plugins.GetFilesInPackageResponse.Files.get -> System.Collections.Generic.IEnumerable<string>
~NuGet.Protocol.Plugins.GetFilesInPackageResponse.GetFilesInPackageResponse(NuGet.Protocol.Plugins.MessageResponseCode responseCode, System.Collections.Generic.IEnumerable<string> files) -> void
NuGet.Protocol.Plugins.GetFilesInPackageResponse.ResponseCode.get -> NuGet.Protocol.Plugins.MessageResponseCode
NuGet.Protocol.Plugins.GetOperationClaimsRequest
~NuGet.Protocol.Plugins.GetOperationClaimsRequest.GetOperationClaimsRequest(string packageSourceRepository, Newtonsoft.Json.Linq.JObject serviceIndex) -> void
~NuGet.Protocol.Plugins.GetOperationClaimsRequest.PackageSourceRepository.get -> string
~NuGet.Protocol.Plugins.GetOperationClaimsRequest.ServiceIndex.get -> Newtonsoft.Json.Linq.JObject
NuGet.Protocol.Plugins.GetOperationClaimsResponse
~NuGet.Protocol.Plugins.GetOperationClaimsResponse.Claims.get -> System.Collections.Generic.IReadOnlyList<NuGet.Protocol.Plugins.OperationClaim>
~NuGet.Protocol.Plugins.GetOperationClaimsResponse.GetOperationClaimsResponse(System.Collections.Generic.IEnumerable<NuGet.Protocol.Plugins.OperationClaim> claims) -> void
NuGet.Protocol.Plugins.GetPackageHashRequest
~NuGet.Protocol.Plugins.GetPackageHashRequest.GetPackageHashRequest(string packageSourceRepository, string packageId, string packageVersion, string hashAlgorithm) -> void
~NuGet.Protocol.Plugins.GetPackageHashRequest.HashAlgorithm.get -> string
~NuGet.Protocol.Plugins.GetPackageHashRequest.PackageId.get -> string
~NuGet.Protocol.Plugins.GetPackageHashRequest.PackageSourceRepository.get -> string
~NuGet.Protocol.Plugins.GetPackageHashRequest.PackageVersion.get -> string
NuGet.Protocol.Plugins.GetPackageHashResponse
~NuGet.Protocol.Plugins.GetPackageHashResponse.GetPackageHashResponse(NuGet.Protocol.Plugins.MessageResponseCode responseCode, string hash) -> void
~NuGet.Protocol.Plugins.GetPackageHashResponse.Hash.get -> string
NuGet.Protocol.Plugins.GetPackageHashResponse.ResponseCode.get -> NuGet.Protocol.Plugins.MessageResponseCode
NuGet.Protocol.Plugins.GetPackageVersionsRequest
~NuGet.Protocol.Plugins.GetPackageVersionsRequest.GetPackageVersionsRequest(string packageSourceRepository, string packageId) -> void
~NuGet.Protocol.Plugins.GetPackageVersionsRequest.PackageId.get -> string
~NuGet.Protocol.Plugins.GetPackageVersionsRequest.PackageSourceRepository.get -> string
NuGet.Protocol.Plugins.GetPackageVersionsResponse
~NuGet.Protocol.Plugins.GetPackageVersionsResponse.GetPackageVersionsResponse(NuGet.Protocol.Plugins.MessageResponseCode responseCode, System.Collections.Generic.IEnumerable<string> versions) -> void
NuGet.Protocol.Plugins.GetPackageVersionsResponse.ResponseCode.get -> NuGet.Protocol.Plugins.MessageResponseCode
~NuGet.Protocol.Plugins.GetPackageVersionsResponse.Versions.get -> System.Collections.Generic.IEnumerable<string>
NuGet.Protocol.Plugins.GetServiceIndexRequest
~NuGet.Protocol.Plugins.GetServiceIndexRequest.GetServiceIndexRequest(string packageSourceRepository) -> void
~NuGet.Protocol.Plugins.GetServiceIndexRequest.PackageSourceRepository.get -> string
NuGet.Protocol.Plugins.GetServiceIndexRequestHandler
~NuGet.Protocol.Plugins.GetServiceIndexRequestHandler.AddOrUpdateSourceRepository(NuGet.Protocol.Core.Types.SourceRepository sourceRepository) -> void
NuGet.Protocol.Plugins.GetServiceIndexRequestHandler.CancellationToken.get -> System.Threading.CancellationToken
NuGet.Protocol.Plugins.GetServiceIndexRequestHandler.Dispose() -> void
~NuGet.Protocol.Plugins.GetServiceIndexRequestHandler.GetServiceIndexRequestHandler(NuGet.Protocol.Plugins.IPlugin plugin) -> void
~NuGet.Protocol.Plugins.GetServiceIndexRequestHandler.HandleResponseAsync(NuGet.Protocol.Plugins.IConnection connection, NuGet.Protocol.Plugins.Message request, NuGet.Protocol.Plugins.IResponseHandler responseHandler, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
NuGet.Protocol.Plugins.GetServiceIndexResponse
~NuGet.Protocol.Plugins.GetServiceIndexResponse.GetServiceIndexResponse(NuGet.Protocol.Plugins.MessageResponseCode responseCode, Newtonsoft.Json.Linq.JObject serviceIndex) -> void
NuGet.Protocol.Plugins.GetServiceIndexResponse.ResponseCode.get -> NuGet.Protocol.Plugins.MessageResponseCode
~NuGet.Protocol.Plugins.GetServiceIndexResponse.ServiceIndex.get -> Newtonsoft.Json.Linq.JObject
NuGet.Protocol.Plugins.HandshakeRequest
~NuGet.Protocol.Plugins.HandshakeRequest.HandshakeRequest(NuGet.Versioning.SemanticVersion protocolVersion, NuGet.Versioning.SemanticVersion minimumProtocolVersion) -> void
~NuGet.Protocol.Plugins.HandshakeRequest.MinimumProtocolVersion.get -> NuGet.Versioning.SemanticVersion
~NuGet.Protocol.Plugins.HandshakeRequest.ProtocolVersion.get -> NuGet.Versioning.SemanticVersion
NuGet.Protocol.Plugins.HandshakeResponse
~NuGet.Protocol.Plugins.HandshakeResponse.HandshakeResponse(NuGet.Protocol.Plugins.MessageResponseCode responseCode, NuGet.Versioning.SemanticVersion protocolVersion) -> void
~NuGet.Protocol.Plugins.HandshakeResponse.ProtocolVersion.get -> NuGet.Versioning.SemanticVersion
NuGet.Protocol.Plugins.HandshakeResponse.ResponseCode.get -> NuGet.Protocol.Plugins.MessageResponseCode
NuGet.Protocol.Plugins.IConnection
NuGet.Protocol.Plugins.IConnection.Close() -> void
NuGet.Protocol.Plugins.IConnection.Faulted -> System.EventHandler<NuGet.Protocol.Plugins.ProtocolErrorEventArgs>
~NuGet.Protocol.Plugins.IConnection.MessageDispatcher.get -> NuGet.Protocol.Plugins.IMessageDispatcher
NuGet.Protocol.Plugins.IConnection.MessageReceived -> System.EventHandler<NuGet.Protocol.Plugins.MessageEventArgs>
~NuGet.Protocol.Plugins.IConnection.Options.get -> NuGet.Protocol.Plugins.ConnectionOptions
~NuGet.Protocol.Plugins.IConnection.ProtocolVersion.get -> NuGet.Versioning.SemanticVersion
~NuGet.Protocol.Plugins.IConnection.SendAsync(NuGet.Protocol.Plugins.Message message, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
~NuGet.Protocol.Plugins.IConnection.SendRequestAndReceiveResponseAsync<TOutbound, TInbound>(NuGet.Protocol.Plugins.MessageMethod method, TOutbound payload, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<TInbound>
NuGet.Protocol.Plugins.IIdGenerator
~NuGet.Protocol.Plugins.IIdGenerator.GenerateUniqueId() -> string
NuGet.Protocol.Plugins.IMessageDispatcher
NuGet.Protocol.Plugins.IMessageDispatcher.Close() -> void
~NuGet.Protocol.Plugins.IMessageDispatcher.CreateMessage(NuGet.Protocol.Plugins.MessageType type, NuGet.Protocol.Plugins.MessageMethod method) -> NuGet.Protocol.Plugins.Message
~NuGet.Protocol.Plugins.IMessageDispatcher.CreateMessage<TPayload>(NuGet.Protocol.Plugins.MessageType type, NuGet.Protocol.Plugins.MessageMethod method, TPayload payload) -> NuGet.Protocol.Plugins.Message
~NuGet.Protocol.Plugins.IMessageDispatcher.DispatchCancelAsync(NuGet.Protocol.Plugins.Message request, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
~NuGet.Protocol.Plugins.IMessageDispatcher.DispatchFaultAsync(NuGet.Protocol.Plugins.Message request, NuGet.Protocol.Plugins.Fault fault, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
~NuGet.Protocol.Plugins.IMessageDispatcher.DispatchProgressAsync(NuGet.Protocol.Plugins.Message request, NuGet.Protocol.Plugins.Progress progress, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
~NuGet.Protocol.Plugins.IMessageDispatcher.DispatchRequestAsync<TOutbound, TInbound>(NuGet.Protocol.Plugins.MessageMethod method, TOutbound payload, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<TInbound>
~NuGet.Protocol.Plugins.IMessageDispatcher.DispatchResponseAsync<TOutbound>(NuGet.Protocol.Plugins.Message request, TOutbound responsePayload, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
~NuGet.Protocol.Plugins.IMessageDispatcher.RequestHandlers.get -> NuGet.Protocol.Plugins.IRequestHandlers
~NuGet.Protocol.Plugins.IMessageDispatcher.SetConnection(NuGet.Protocol.Plugins.IConnection connection) -> void
NuGet.Protocol.Plugins.IPlugin
NuGet.Protocol.Plugins.IPlugin.BeforeClose -> System.EventHandler
NuGet.Protocol.Plugins.IPlugin.Close() -> void
NuGet.Protocol.Plugins.IPlugin.Closed -> System.EventHandler
~NuGet.Protocol.Plugins.IPlugin.Connection.get -> NuGet.Protocol.Plugins.IConnection
~NuGet.Protocol.Plugins.IPlugin.FilePath.get -> string
~NuGet.Protocol.Plugins.IPlugin.Id.get -> string
~NuGet.Protocol.Plugins.IPlugin.Name.get -> string
NuGet.Protocol.Plugins.IPluginDiscoverer
~NuGet.Protocol.Plugins.IPluginDiscoverer.DiscoverAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Plugins.PluginDiscoveryResult>>
NuGet.Protocol.Plugins.IPluginFactory
~NuGet.Protocol.Plugins.IPluginFactory.GetOrCreateAsync(string filePath, System.Collections.Generic.IEnumerable<string> arguments, NuGet.Protocol.Plugins.IRequestHandlers requestHandlers, NuGet.Protocol.Plugins.ConnectionOptions options, System.Threading.CancellationToken sessionCancellationToken) -> System.Threading.Tasks.Task<NuGet.Protocol.Plugins.IPlugin>
NuGet.Protocol.Plugins.IPluginManager
~NuGet.Protocol.Plugins.IPluginManager.CreatePluginsAsync(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Plugins.PluginCreationResult>>
~NuGet.Protocol.Plugins.IPluginManager.FindAvailablePluginsAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Plugins.PluginDiscoveryResult>>
~NuGet.Protocol.Plugins.IPluginManager.TryGetSourceAgnosticPluginAsync(NuGet.Protocol.Plugins.PluginDiscoveryResult pluginDiscoveryResult, NuGet.Protocol.Plugins.OperationClaim requestedOperationClaim, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Plugins.PluginCreationResult>>
NuGet.Protocol.Plugins.IPluginMulticlientUtilities
~NuGet.Protocol.Plugins.IPluginMulticlientUtilities.DoOncePerPluginLifetimeAsync(string key, System.Func<System.Threading.Tasks.Task> taskFunc, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
NuGet.Protocol.Plugins.IPluginProcess
NuGet.Protocol.Plugins.IPluginProcess.BeginReadLine() -> void
NuGet.Protocol.Plugins.IPluginProcess.CancelRead() -> void
NuGet.Protocol.Plugins.IPluginProcess.ExitCode.get -> int?
NuGet.Protocol.Plugins.IPluginProcess.Exited -> System.EventHandler<NuGet.Protocol.Plugins.IPluginProcess>
NuGet.Protocol.Plugins.IPluginProcess.Id.get -> int?
NuGet.Protocol.Plugins.IPluginProcess.Kill() -> void
NuGet.Protocol.Plugins.IPluginProcess.LineRead -> System.EventHandler<NuGet.Protocol.Plugins.LineReadEventArgs>
NuGet.Protocol.Plugins.IReceiver
NuGet.Protocol.Plugins.IReceiver.Close() -> void
NuGet.Protocol.Plugins.IReceiver.Connect() -> void
NuGet.Protocol.Plugins.IReceiver.Faulted -> System.EventHandler<NuGet.Protocol.Plugins.ProtocolErrorEventArgs>
NuGet.Protocol.Plugins.IReceiver.MessageReceived -> System.EventHandler<NuGet.Protocol.Plugins.MessageEventArgs>
NuGet.Protocol.Plugins.IRequestHandler
NuGet.Protocol.Plugins.IRequestHandler.CancellationToken.get -> System.Threading.CancellationToken
~NuGet.Protocol.Plugins.IRequestHandler.HandleResponseAsync(NuGet.Protocol.Plugins.IConnection connection, NuGet.Protocol.Plugins.Message request, NuGet.Protocol.Plugins.IResponseHandler responseHandler, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
NuGet.Protocol.Plugins.IRequestHandlers
~NuGet.Protocol.Plugins.IRequestHandlers.AddOrUpdate(NuGet.Protocol.Plugins.MessageMethod method, System.Func<NuGet.Protocol.Plugins.IRequestHandler> addHandlerFunc, System.Func<NuGet.Protocol.Plugins.IRequestHandler, NuGet.Protocol.Plugins.IRequestHandler> updateHandlerFunc) -> void
~NuGet.Protocol.Plugins.IRequestHandlers.TryAdd(NuGet.Protocol.Plugins.MessageMethod method, NuGet.Protocol.Plugins.IRequestHandler handler) -> bool
~NuGet.Protocol.Plugins.IRequestHandlers.TryGet(NuGet.Protocol.Plugins.MessageMethod method, out NuGet.Protocol.Plugins.IRequestHandler handler) -> bool
NuGet.Protocol.Plugins.IRequestHandlers.TryRemove(NuGet.Protocol.Plugins.MessageMethod method) -> bool
NuGet.Protocol.Plugins.IResponseHandler
~NuGet.Protocol.Plugins.IResponseHandler.SendResponseAsync<TPayload>(NuGet.Protocol.Plugins.Message request, TPayload payload, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
NuGet.Protocol.Plugins.ISender
NuGet.Protocol.Plugins.ISender.Close() -> void
NuGet.Protocol.Plugins.ISender.Connect() -> void
~NuGet.Protocol.Plugins.ISender.SendAsync(NuGet.Protocol.Plugins.Message message, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
NuGet.Protocol.Plugins.InboundRequestContext
~NuGet.Protocol.Plugins.InboundRequestContext.BeginFaultAsync(NuGet.Protocol.Plugins.Message request, System.Exception exception) -> void
~NuGet.Protocol.Plugins.InboundRequestContext.BeginResponseAsync(NuGet.Protocol.Plugins.Message request, NuGet.Protocol.Plugins.IRequestHandler requestHandler, NuGet.Protocol.Plugins.IResponseHandler responseHandler) -> void
NuGet.Protocol.Plugins.InboundRequestContext.Cancel() -> void
NuGet.Protocol.Plugins.InboundRequestContext.Dispose() -> void
~NuGet.Protocol.Plugins.InboundRequestContext.InboundRequestContext(NuGet.Protocol.Plugins.IConnection connection, string requestId, System.Threading.CancellationToken cancellationToken) -> void
~NuGet.Protocol.Plugins.InboundRequestContext.RequestId.get -> string
NuGet.Protocol.Plugins.InitializeRequest
~NuGet.Protocol.Plugins.InitializeRequest.ClientVersion.get -> string
~NuGet.Protocol.Plugins.InitializeRequest.Culture.get -> string
~NuGet.Protocol.Plugins.InitializeRequest.InitializeRequest(string clientVersion, string culture, System.TimeSpan requestTimeout) -> void
NuGet.Protocol.Plugins.InitializeRequest.RequestTimeout.get -> System.TimeSpan
NuGet.Protocol.Plugins.InitializeResponse
NuGet.Protocol.Plugins.InitializeResponse.InitializeResponse(NuGet.Protocol.Plugins.MessageResponseCode responseCode) -> void
NuGet.Protocol.Plugins.InitializeResponse.ResponseCode.get -> NuGet.Protocol.Plugins.MessageResponseCode
NuGet.Protocol.Plugins.JsonSerializationUtilities
NuGet.Protocol.Plugins.LineReadEventArgs
~NuGet.Protocol.Plugins.LineReadEventArgs.Line.get -> string
~NuGet.Protocol.Plugins.LineReadEventArgs.LineReadEventArgs(string line) -> void
NuGet.Protocol.Plugins.LogRequest
NuGet.Protocol.Plugins.LogRequest.LogLevel.get -> NuGet.Common.LogLevel
~NuGet.Protocol.Plugins.LogRequest.LogRequest(NuGet.Common.LogLevel logLevel, string message) -> void
~NuGet.Protocol.Plugins.LogRequest.Message.get -> string
NuGet.Protocol.Plugins.LogRequestHandler
NuGet.Protocol.Plugins.LogRequestHandler.CancellationToken.get -> System.Threading.CancellationToken
~NuGet.Protocol.Plugins.LogRequestHandler.HandleResponseAsync(NuGet.Protocol.Plugins.IConnection connection, NuGet.Protocol.Plugins.Message request, NuGet.Protocol.Plugins.IResponseHandler responseHandler, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
~NuGet.Protocol.Plugins.LogRequestHandler.LogRequestHandler(NuGet.Common.ILogger logger) -> void
~NuGet.Protocol.Plugins.LogRequestHandler.SetLogger(NuGet.Common.ILogger logger) -> void
NuGet.Protocol.Plugins.LogResponse
NuGet.Protocol.Plugins.LogResponse.LogResponse(NuGet.Protocol.Plugins.MessageResponseCode responseCode) -> void
NuGet.Protocol.Plugins.LogResponse.ResponseCode.get -> NuGet.Protocol.Plugins.MessageResponseCode
NuGet.Protocol.Plugins.Message
~NuGet.Protocol.Plugins.Message.Message(string requestId, NuGet.Protocol.Plugins.MessageType type, NuGet.Protocol.Plugins.MessageMethod method, Newtonsoft.Json.Linq.JObject payload = null) -> void
NuGet.Protocol.Plugins.Message.Method.get -> NuGet.Protocol.Plugins.MessageMethod
~NuGet.Protocol.Plugins.Message.Payload.get -> Newtonsoft.Json.Linq.JObject
~NuGet.Protocol.Plugins.Message.RequestId.get -> string
NuGet.Protocol.Plugins.Message.Type.get -> NuGet.Protocol.Plugins.MessageType
NuGet.Protocol.Plugins.MessageDispatcher
NuGet.Protocol.Plugins.MessageDispatcher.Close() -> void
~NuGet.Protocol.Plugins.MessageDispatcher.CreateMessage(NuGet.Protocol.Plugins.MessageType type, NuGet.Protocol.Plugins.MessageMethod method) -> NuGet.Protocol.Plugins.Message
~NuGet.Protocol.Plugins.MessageDispatcher.CreateMessage<TPayload>(NuGet.Protocol.Plugins.MessageType type, NuGet.Protocol.Plugins.MessageMethod method, TPayload payload) -> NuGet.Protocol.Plugins.Message
~NuGet.Protocol.Plugins.MessageDispatcher.DispatchCancelAsync(NuGet.Protocol.Plugins.Message request, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
~NuGet.Protocol.Plugins.MessageDispatcher.DispatchFaultAsync(NuGet.Protocol.Plugins.Message request, NuGet.Protocol.Plugins.Fault fault, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
~NuGet.Protocol.Plugins.MessageDispatcher.DispatchProgressAsync(NuGet.Protocol.Plugins.Message request, NuGet.Protocol.Plugins.Progress progress, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
~NuGet.Protocol.Plugins.MessageDispatcher.DispatchRequestAsync<TOutbound, TInbound>(NuGet.Protocol.Plugins.MessageMethod method, TOutbound payload, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<TInbound>
~NuGet.Protocol.Plugins.MessageDispatcher.DispatchResponseAsync<TOutbound>(NuGet.Protocol.Plugins.Message request, TOutbound responsePayload, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
NuGet.Protocol.Plugins.MessageDispatcher.Dispose() -> void
~NuGet.Protocol.Plugins.MessageDispatcher.MessageDispatcher(NuGet.Protocol.Plugins.IRequestHandlers requestHandlers, NuGet.Protocol.Plugins.IIdGenerator idGenerator) -> void
~NuGet.Protocol.Plugins.MessageDispatcher.RequestHandlers.get -> NuGet.Protocol.Plugins.IRequestHandlers
~NuGet.Protocol.Plugins.MessageDispatcher.SetConnection(NuGet.Protocol.Plugins.IConnection connection) -> void
NuGet.Protocol.Plugins.MessageEventArgs
~NuGet.Protocol.Plugins.MessageEventArgs.Message.get -> NuGet.Protocol.Plugins.Message
~NuGet.Protocol.Plugins.MessageEventArgs.MessageEventArgs(NuGet.Protocol.Plugins.Message message) -> void
NuGet.Protocol.Plugins.MessageMethod
NuGet.Protocol.Plugins.MessageMethod.Close = 1 -> NuGet.Protocol.Plugins.MessageMethod
NuGet.Protocol.Plugins.MessageMethod.CopyFilesInPackage = 2 -> NuGet.Protocol.Plugins.MessageMethod
NuGet.Protocol.Plugins.MessageMethod.CopyNupkgFile = 3 -> NuGet.Protocol.Plugins.MessageMethod
NuGet.Protocol.Plugins.MessageMethod.GetAuthenticationCredentials = 17 -> NuGet.Protocol.Plugins.MessageMethod
NuGet.Protocol.Plugins.MessageMethod.GetCredentials = 4 -> NuGet.Protocol.Plugins.MessageMethod
NuGet.Protocol.Plugins.MessageMethod.GetFilesInPackage = 5 -> NuGet.Protocol.Plugins.MessageMethod
NuGet.Protocol.Plugins.MessageMethod.GetOperationClaims = 6 -> NuGet.Protocol.Plugins.MessageMethod
NuGet.Protocol.Plugins.MessageMethod.GetPackageHash = 7 -> NuGet.Protocol.Plugins.MessageMethod
NuGet.Protocol.Plugins.MessageMethod.GetPackageVersions = 8 -> NuGet.Protocol.Plugins.MessageMethod
NuGet.Protocol.Plugins.MessageMethod.GetServiceIndex = 9 -> NuGet.Protocol.Plugins.MessageMethod
NuGet.Protocol.Plugins.MessageMethod.Handshake = 10 -> NuGet.Protocol.Plugins.MessageMethod
NuGet.Protocol.Plugins.MessageMethod.Initialize = 11 -> NuGet.Protocol.Plugins.MessageMethod
NuGet.Protocol.Plugins.MessageMethod.Log = 12 -> NuGet.Protocol.Plugins.MessageMethod
NuGet.Protocol.Plugins.MessageMethod.MonitorNuGetProcessExit = 13 -> NuGet.Protocol.Plugins.MessageMethod
NuGet.Protocol.Plugins.MessageMethod.None = 0 -> NuGet.Protocol.Plugins.MessageMethod
NuGet.Protocol.Plugins.MessageMethod.PrefetchPackage = 14 -> NuGet.Protocol.Plugins.MessageMethod
NuGet.Protocol.Plugins.MessageMethod.SetCredentials = 15 -> NuGet.Protocol.Plugins.MessageMethod
NuGet.Protocol.Plugins.MessageMethod.SetLogLevel = 16 -> NuGet.Protocol.Plugins.MessageMethod
NuGet.Protocol.Plugins.MessageResponseCode
NuGet.Protocol.Plugins.MessageResponseCode.Error = 1 -> NuGet.Protocol.Plugins.MessageResponseCode
NuGet.Protocol.Plugins.MessageResponseCode.NotFound = 2 -> NuGet.Protocol.Plugins.MessageResponseCode
NuGet.Protocol.Plugins.MessageResponseCode.Success = 0 -> NuGet.Protocol.Plugins.MessageResponseCode
NuGet.Protocol.Plugins.MessageType
NuGet.Protocol.Plugins.MessageType.Cancel = 0 -> NuGet.Protocol.Plugins.MessageType
NuGet.Protocol.Plugins.MessageType.Fault = 1 -> NuGet.Protocol.Plugins.MessageType
NuGet.Protocol.Plugins.MessageType.Progress = 2 -> NuGet.Protocol.Plugins.MessageType
NuGet.Protocol.Plugins.MessageType.Request = 3 -> NuGet.Protocol.Plugins.MessageType
NuGet.Protocol.Plugins.MessageType.Response = 4 -> NuGet.Protocol.Plugins.MessageType
NuGet.Protocol.Plugins.MessageUtilities
NuGet.Protocol.Plugins.MonitorNuGetProcessExitRequest
NuGet.Protocol.Plugins.MonitorNuGetProcessExitRequest.MonitorNuGetProcessExitRequest(int processId) -> void
NuGet.Protocol.Plugins.MonitorNuGetProcessExitRequest.ProcessId.get -> int
NuGet.Protocol.Plugins.MonitorNuGetProcessExitRequestHandler
NuGet.Protocol.Plugins.MonitorNuGetProcessExitRequestHandler.CancellationToken.get -> System.Threading.CancellationToken
NuGet.Protocol.Plugins.MonitorNuGetProcessExitRequestHandler.Dispose() -> void
~NuGet.Protocol.Plugins.MonitorNuGetProcessExitRequestHandler.HandleResponseAsync(NuGet.Protocol.Plugins.IConnection connection, NuGet.Protocol.Plugins.Message request, NuGet.Protocol.Plugins.IResponseHandler responseHandler, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
~NuGet.Protocol.Plugins.MonitorNuGetProcessExitRequestHandler.MonitorNuGetProcessExitRequestHandler(NuGet.Protocol.Plugins.IPlugin plugin) -> void
NuGet.Protocol.Plugins.MonitorNuGetProcessExitResponse
NuGet.Protocol.Plugins.MonitorNuGetProcessExitResponse.MonitorNuGetProcessExitResponse(NuGet.Protocol.Plugins.MessageResponseCode responseCode) -> void
NuGet.Protocol.Plugins.MonitorNuGetProcessExitResponse.ResponseCode.get -> NuGet.Protocol.Plugins.MessageResponseCode
NuGet.Protocol.Plugins.NoOpDisposePlugin
NuGet.Protocol.Plugins.NoOpDisposePlugin.BeforeClose -> System.EventHandler
NuGet.Protocol.Plugins.NoOpDisposePlugin.Close() -> void
NuGet.Protocol.Plugins.NoOpDisposePlugin.Closed -> System.EventHandler
~NuGet.Protocol.Plugins.NoOpDisposePlugin.Connection.get -> NuGet.Protocol.Plugins.IConnection
NuGet.Protocol.Plugins.NoOpDisposePlugin.Dispose() -> void
~NuGet.Protocol.Plugins.NoOpDisposePlugin.FilePath.get -> string
~NuGet.Protocol.Plugins.NoOpDisposePlugin.Id.get -> string
~NuGet.Protocol.Plugins.NoOpDisposePlugin.Name.get -> string
~NuGet.Protocol.Plugins.NoOpDisposePlugin.NoOpDisposePlugin(NuGet.Protocol.Plugins.IPlugin plugin) -> void
NuGet.Protocol.Plugins.OperationClaim
NuGet.Protocol.Plugins.OperationClaim.Authentication = 1 -> NuGet.Protocol.Plugins.OperationClaim
NuGet.Protocol.Plugins.OperationClaim.DownloadPackage = 0 -> NuGet.Protocol.Plugins.OperationClaim
NuGet.Protocol.Plugins.OutboundRequestContext
NuGet.Protocol.Plugins.OutboundRequestContext.CancellationToken.get -> System.Threading.CancellationToken
NuGet.Protocol.Plugins.OutboundRequestContext.CancellationToken.set -> void
NuGet.Protocol.Plugins.OutboundRequestContext.Dispose() -> void
NuGet.Protocol.Plugins.OutboundRequestContext.OutboundRequestContext() -> void
~NuGet.Protocol.Plugins.OutboundRequestContext.RequestId.get -> string
~NuGet.Protocol.Plugins.OutboundRequestContext.RequestId.set -> void
NuGet.Protocol.Plugins.OutboundRequestContext<TResult>
~NuGet.Protocol.Plugins.OutboundRequestContext<TResult>.CompletionTask.get -> System.Threading.Tasks.Task<TResult>
~NuGet.Protocol.Plugins.OutboundRequestContext<TResult>.OutboundRequestContext(NuGet.Protocol.Plugins.IConnection connection, NuGet.Protocol.Plugins.Message request, System.TimeSpan? timeout, bool isKeepAlive, System.Threading.CancellationToken cancellationToken) -> void
NuGet.Protocol.Plugins.Plugin
NuGet.Protocol.Plugins.Plugin.BeforeClose -> System.EventHandler
NuGet.Protocol.Plugins.Plugin.Close() -> void
NuGet.Protocol.Plugins.Plugin.Closed -> System.EventHandler
~NuGet.Protocol.Plugins.Plugin.Connection.get -> NuGet.Protocol.Plugins.IConnection
NuGet.Protocol.Plugins.Plugin.Dispose() -> void
NuGet.Protocol.Plugins.Plugin.Exited -> System.EventHandler<NuGet.Protocol.Plugins.PluginEventArgs>
NuGet.Protocol.Plugins.Plugin.Faulted -> System.EventHandler<NuGet.Protocol.Plugins.FaultedPluginEventArgs>
~NuGet.Protocol.Plugins.Plugin.FilePath.get -> string
~NuGet.Protocol.Plugins.Plugin.Id.get -> string
NuGet.Protocol.Plugins.Plugin.Idle -> System.EventHandler<NuGet.Protocol.Plugins.PluginEventArgs>
~NuGet.Protocol.Plugins.Plugin.Name.get -> string
~NuGet.Protocol.Plugins.Plugin.Plugin(string filePath, NuGet.Protocol.Plugins.IConnection connection, NuGet.Protocol.Plugins.IPluginProcess process, bool isOwnProcess, System.TimeSpan idleTimeout) -> void
NuGet.Protocol.Plugins.PluginCacheEntry
NuGet.Protocol.Plugins.PluginCacheEntry.LoadFromFile() -> void
~NuGet.Protocol.Plugins.PluginCacheEntry.OperationClaims.get -> System.Collections.Generic.IReadOnlyList<NuGet.Protocol.Plugins.OperationClaim>
~NuGet.Protocol.Plugins.PluginCacheEntry.OperationClaims.set -> void
~NuGet.Protocol.Plugins.PluginCacheEntry.PluginCacheEntry(string rootCacheFolder, string pluginFilePath, string requestKey) -> void
~NuGet.Protocol.Plugins.PluginCacheEntry.UpdateCacheFileAsync() -> System.Threading.Tasks.Task
NuGet.Protocol.Plugins.PluginConstants
NuGet.Protocol.Plugins.PluginCreationResult
~NuGet.Protocol.Plugins.PluginCreationResult.Claims.get -> System.Collections.Generic.IReadOnlyList<NuGet.Protocol.Plugins.OperationClaim>
~NuGet.Protocol.Plugins.PluginCreationResult.Exception.get -> System.Exception
~NuGet.Protocol.Plugins.PluginCreationResult.Message.get -> string
~NuGet.Protocol.Plugins.PluginCreationResult.Plugin.get -> NuGet.Protocol.Plugins.IPlugin
~NuGet.Protocol.Plugins.PluginCreationResult.PluginCreationResult(NuGet.Protocol.Plugins.IPlugin plugin, NuGet.Protocol.Plugins.IPluginMulticlientUtilities utilities, System.Collections.Generic.IReadOnlyList<NuGet.Protocol.Plugins.OperationClaim> claims) -> void
~NuGet.Protocol.Plugins.PluginCreationResult.PluginCreationResult(string message) -> void
~NuGet.Protocol.Plugins.PluginCreationResult.PluginCreationResult(string message, System.Exception exception) -> void
~NuGet.Protocol.Plugins.PluginCreationResult.PluginMulticlientUtilities.get -> NuGet.Protocol.Plugins.IPluginMulticlientUtilities
NuGet.Protocol.Plugins.PluginDiscoverer
~NuGet.Protocol.Plugins.PluginDiscoverer.DiscoverAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Plugins.PluginDiscoveryResult>>
NuGet.Protocol.Plugins.PluginDiscoverer.Dispose() -> void
~NuGet.Protocol.Plugins.PluginDiscoverer.PluginDiscoverer(string rawPluginPaths, NuGet.Protocol.Plugins.EmbeddedSignatureVerifier verifier) -> void
NuGet.Protocol.Plugins.PluginDiscoveryResult
~NuGet.Protocol.Plugins.PluginDiscoveryResult.Message.get -> string
~NuGet.Protocol.Plugins.PluginDiscoveryResult.PluginDiscoveryResult(NuGet.Protocol.Plugins.PluginFile pluginFile) -> void
~NuGet.Protocol.Plugins.PluginDiscoveryResult.PluginFile.get -> NuGet.Protocol.Plugins.PluginFile
NuGet.Protocol.Plugins.PluginDiscoveryUtility
NuGet.Protocol.Plugins.PluginEventArgs
~NuGet.Protocol.Plugins.PluginEventArgs.Plugin.get -> NuGet.Protocol.Plugins.IPlugin
~NuGet.Protocol.Plugins.PluginEventArgs.PluginEventArgs(NuGet.Protocol.Plugins.IPlugin plugin) -> void
NuGet.Protocol.Plugins.PluginException
~NuGet.Protocol.Plugins.PluginException.PluginException(string message) -> void
~NuGet.Protocol.Plugins.PluginException.PluginException(string message, System.Exception innerException) -> void
NuGet.Protocol.Plugins.PluginFactory
NuGet.Protocol.Plugins.PluginFactory.Dispose() -> void
~NuGet.Protocol.Plugins.PluginFactory.GetOrCreateAsync(string filePath, System.Collections.Generic.IEnumerable<string> arguments, NuGet.Protocol.Plugins.IRequestHandlers requestHandlers, NuGet.Protocol.Plugins.ConnectionOptions options, System.Threading.CancellationToken sessionCancellationToken) -> System.Threading.Tasks.Task<NuGet.Protocol.Plugins.IPlugin>
NuGet.Protocol.Plugins.PluginFactory.PluginFactory(System.TimeSpan pluginIdleTimeout) -> void
NuGet.Protocol.Plugins.PluginFile
~NuGet.Protocol.Plugins.PluginFile.Path.get -> string
~NuGet.Protocol.Plugins.PluginFile.PluginFile(string filePath, System.Lazy<NuGet.Protocol.Plugins.PluginFileState> state) -> void
~NuGet.Protocol.Plugins.PluginFile.State.get -> System.Lazy<NuGet.Protocol.Plugins.PluginFileState>
NuGet.Protocol.Plugins.PluginFileState
NuGet.Protocol.Plugins.PluginFileState.InvalidEmbeddedSignature = 3 -> NuGet.Protocol.Plugins.PluginFileState
NuGet.Protocol.Plugins.PluginFileState.InvalidFilePath = 2 -> NuGet.Protocol.Plugins.PluginFileState
NuGet.Protocol.Plugins.PluginFileState.NotFound = 1 -> NuGet.Protocol.Plugins.PluginFileState
NuGet.Protocol.Plugins.PluginFileState.Valid = 0 -> NuGet.Protocol.Plugins.PluginFileState
NuGet.Protocol.Plugins.PluginManager
~NuGet.Protocol.Plugins.PluginManager.CreatePluginsAsync(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Plugins.PluginCreationResult>>
NuGet.Protocol.Plugins.PluginManager.Dispose() -> void
~NuGet.Protocol.Plugins.PluginManager.EnvironmentVariableReader.get -> NuGet.Common.IEnvironmentVariableReader
~NuGet.Protocol.Plugins.PluginManager.FindAvailablePluginsAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Plugins.PluginDiscoveryResult>>
~NuGet.Protocol.Plugins.PluginManager.PluginManager(NuGet.Common.IEnvironmentVariableReader reader, System.Lazy<NuGet.Protocol.Plugins.IPluginDiscoverer> pluginDiscoverer, System.Func<System.TimeSpan, NuGet.Protocol.Plugins.IPluginFactory> pluginFactoryCreator, System.Lazy<string> pluginsCacheDirectoryPath) -> void
~NuGet.Protocol.Plugins.PluginManager.TryGetSourceAgnosticPluginAsync(NuGet.Protocol.Plugins.PluginDiscoveryResult pluginDiscoveryResult, NuGet.Protocol.Plugins.OperationClaim requestedOperationClaim, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Plugins.PluginCreationResult>>
NuGet.Protocol.Plugins.PluginMulticlientUtilities
~NuGet.Protocol.Plugins.PluginMulticlientUtilities.DoOncePerPluginLifetimeAsync(string key, System.Func<System.Threading.Tasks.Task> taskFunc, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
NuGet.Protocol.Plugins.PluginMulticlientUtilities.PluginMulticlientUtilities() -> void
NuGet.Protocol.Plugins.PluginPackageDownloader
~NuGet.Protocol.Plugins.PluginPackageDownloader.ContentReader.get -> NuGet.Packaging.IAsyncPackageContentReader
~NuGet.Protocol.Plugins.PluginPackageDownloader.CopyNupkgFileToAsync(string destinationFilePath, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>
~NuGet.Protocol.Plugins.PluginPackageDownloader.CoreReader.get -> NuGet.Packaging.Core.IAsyncPackageCoreReader
NuGet.Protocol.Plugins.PluginPackageDownloader.Dispose() -> void
~NuGet.Protocol.Plugins.PluginPackageDownloader.GetPackageHashAsync(string hashAlgorithm, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<string>
~NuGet.Protocol.Plugins.PluginPackageDownloader.PluginPackageDownloader(NuGet.Protocol.Plugins.IPlugin plugin, NuGet.Packaging.Core.PackageIdentity packageIdentity, NuGet.Protocol.Plugins.PluginPackageReader packageReader, string packageSourceRepository) -> void
~NuGet.Protocol.Plugins.PluginPackageDownloader.SetExceptionHandler(System.Func<System.Exception, System.Threading.Tasks.Task<bool>> handleExceptionAsync) -> void
~NuGet.Protocol.Plugins.PluginPackageDownloader.SetThrottle(System.Threading.SemaphoreSlim throttle) -> void
~NuGet.Protocol.Plugins.PluginPackageDownloader.SignedPackageReader.get -> NuGet.Packaging.Signing.ISignedPackageReader
~NuGet.Protocol.Plugins.PluginPackageDownloader.Source.get -> string
NuGet.Protocol.Plugins.PluginPackageReader
~NuGet.Protocol.Plugins.PluginPackageReader.PluginPackageReader(NuGet.Protocol.Plugins.IPlugin plugin, NuGet.Packaging.Core.PackageIdentity packageIdentity, string packageSourceRepository) -> void
NuGet.Protocol.Plugins.PluginProcess
NuGet.Protocol.Plugins.PluginProcess.BeginReadLine() -> void
NuGet.Protocol.Plugins.PluginProcess.CancelRead() -> void
NuGet.Protocol.Plugins.PluginProcess.Dispose() -> void
NuGet.Protocol.Plugins.PluginProcess.ExitCode.get -> int?
NuGet.Protocol.Plugins.PluginProcess.Exited -> System.EventHandler<NuGet.Protocol.Plugins.IPluginProcess>
NuGet.Protocol.Plugins.PluginProcess.Id.get -> int?
NuGet.Protocol.Plugins.PluginProcess.Kill() -> void
NuGet.Protocol.Plugins.PluginProcess.LineRead -> System.EventHandler<NuGet.Protocol.Plugins.LineReadEventArgs>
NuGet.Protocol.Plugins.PluginProcess.PluginProcess() -> void
~NuGet.Protocol.Plugins.PluginProcess.PluginProcess(System.Diagnostics.ProcessStartInfo startInfo) -> void
NuGet.Protocol.Plugins.PluginProcess.Start() -> void
NuGet.Protocol.Plugins.PrefetchPackageRequest
~NuGet.Protocol.Plugins.PrefetchPackageRequest.PackageId.get -> string
~NuGet.Protocol.Plugins.PrefetchPackageRequest.PackageSourceRepository.get -> string
~NuGet.Protocol.Plugins.PrefetchPackageRequest.PackageVersion.get -> string
~NuGet.Protocol.Plugins.PrefetchPackageRequest.PrefetchPackageRequest(string packageSourceRepository, string packageId, string packageVersion) -> void
NuGet.Protocol.Plugins.PrefetchPackageResponse
NuGet.Protocol.Plugins.PrefetchPackageResponse.PrefetchPackageResponse(NuGet.Protocol.Plugins.MessageResponseCode responseCode) -> void
NuGet.Protocol.Plugins.PrefetchPackageResponse.ResponseCode.get -> NuGet.Protocol.Plugins.MessageResponseCode
NuGet.Protocol.Plugins.Progress
NuGet.Protocol.Plugins.Progress.Percentage.get -> double?
NuGet.Protocol.Plugins.Progress.Progress(double? percentage = null) -> void
NuGet.Protocol.Plugins.ProtocolConstants
NuGet.Protocol.Plugins.ProtocolErrorEventArgs
~NuGet.Protocol.Plugins.ProtocolErrorEventArgs.Exception.get -> System.Exception
~NuGet.Protocol.Plugins.ProtocolErrorEventArgs.Message.get -> NuGet.Protocol.Plugins.Message
~NuGet.Protocol.Plugins.ProtocolErrorEventArgs.ProtocolErrorEventArgs(System.Exception exception) -> void
~NuGet.Protocol.Plugins.ProtocolErrorEventArgs.ProtocolErrorEventArgs(System.Exception exception, NuGet.Protocol.Plugins.Message message) -> void
NuGet.Protocol.Plugins.ProtocolException
~NuGet.Protocol.Plugins.ProtocolException.ProtocolException(string message) -> void
~NuGet.Protocol.Plugins.ProtocolException.ProtocolException(string message, System.Exception innerException) -> void
NuGet.Protocol.Plugins.Receiver
NuGet.Protocol.Plugins.Receiver.Dispose() -> void
NuGet.Protocol.Plugins.Receiver.Faulted -> System.EventHandler<NuGet.Protocol.Plugins.ProtocolErrorEventArgs>
~NuGet.Protocol.Plugins.Receiver.FireFaultEvent(System.Exception exception, NuGet.Protocol.Plugins.Message message) -> void
~NuGet.Protocol.Plugins.Receiver.FireMessageReceivedEvent(NuGet.Protocol.Plugins.Message message) -> void
NuGet.Protocol.Plugins.Receiver.IsClosed.get -> bool
NuGet.Protocol.Plugins.Receiver.IsDisposed.get -> bool
NuGet.Protocol.Plugins.Receiver.IsDisposed.set -> void
NuGet.Protocol.Plugins.Receiver.MessageReceived -> System.EventHandler<NuGet.Protocol.Plugins.MessageEventArgs>
NuGet.Protocol.Plugins.Receiver.Receiver() -> void
NuGet.Protocol.Plugins.Receiver.ThrowIfClosed() -> void
NuGet.Protocol.Plugins.Receiver.ThrowIfDisposed() -> void
NuGet.Protocol.Plugins.RequestHandlers
~NuGet.Protocol.Plugins.RequestHandlers.AddOrUpdate(NuGet.Protocol.Plugins.MessageMethod method, System.Func<NuGet.Protocol.Plugins.IRequestHandler> addHandlerFunc, System.Func<NuGet.Protocol.Plugins.IRequestHandler, NuGet.Protocol.Plugins.IRequestHandler> updateHandlerFunc) -> void
NuGet.Protocol.Plugins.RequestHandlers.RequestHandlers() -> void
~NuGet.Protocol.Plugins.RequestHandlers.TryAdd(NuGet.Protocol.Plugins.MessageMethod method, NuGet.Protocol.Plugins.IRequestHandler handler) -> bool
~NuGet.Protocol.Plugins.RequestHandlers.TryGet(NuGet.Protocol.Plugins.MessageMethod method, out NuGet.Protocol.Plugins.IRequestHandler handler) -> bool
NuGet.Protocol.Plugins.RequestHandlers.TryRemove(NuGet.Protocol.Plugins.MessageMethod method) -> bool
NuGet.Protocol.Plugins.RequestIdGenerator
~NuGet.Protocol.Plugins.RequestIdGenerator.GenerateUniqueId() -> string
NuGet.Protocol.Plugins.RequestIdGenerator.RequestIdGenerator() -> void
NuGet.Protocol.Plugins.Sender
NuGet.Protocol.Plugins.Sender.Close() -> void
NuGet.Protocol.Plugins.Sender.Connect() -> void
NuGet.Protocol.Plugins.Sender.Dispose() -> void
~NuGet.Protocol.Plugins.Sender.SendAsync(NuGet.Protocol.Plugins.Message message, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
~NuGet.Protocol.Plugins.Sender.Sender(System.IO.TextWriter writer) -> void
NuGet.Protocol.Plugins.SetCredentialsRequest
~NuGet.Protocol.Plugins.SetCredentialsRequest.PackageSourceRepository.get -> string
~NuGet.Protocol.Plugins.SetCredentialsRequest.Password.get -> string
~NuGet.Protocol.Plugins.SetCredentialsRequest.ProxyPassword.get -> string
~NuGet.Protocol.Plugins.SetCredentialsRequest.ProxyUsername.get -> string
~NuGet.Protocol.Plugins.SetCredentialsRequest.SetCredentialsRequest(string packageSourceRepository, string proxyUsername, string proxyPassword, string username, string password) -> void
~NuGet.Protocol.Plugins.SetCredentialsRequest.Username.get -> string
NuGet.Protocol.Plugins.SetCredentialsResponse
NuGet.Protocol.Plugins.SetCredentialsResponse.ResponseCode.get -> NuGet.Protocol.Plugins.MessageResponseCode
NuGet.Protocol.Plugins.SetCredentialsResponse.SetCredentialsResponse(NuGet.Protocol.Plugins.MessageResponseCode responseCode) -> void
NuGet.Protocol.Plugins.SetLogLevelRequest
NuGet.Protocol.Plugins.SetLogLevelRequest.LogLevel.get -> NuGet.Common.LogLevel
NuGet.Protocol.Plugins.SetLogLevelRequest.SetLogLevelRequest(NuGet.Common.LogLevel logLevel) -> void
NuGet.Protocol.Plugins.SetLogLevelResponse
NuGet.Protocol.Plugins.SetLogLevelResponse.ResponseCode.get -> NuGet.Protocol.Plugins.MessageResponseCode
NuGet.Protocol.Plugins.SetLogLevelResponse.SetLogLevelResponse(NuGet.Protocol.Plugins.MessageResponseCode responseCode) -> void
NuGet.Protocol.Plugins.StandardInputReceiver
~NuGet.Protocol.Plugins.StandardInputReceiver.StandardInputReceiver(System.IO.TextReader reader) -> void
NuGet.Protocol.Plugins.StandardOutputReceiver
~NuGet.Protocol.Plugins.StandardOutputReceiver.StandardOutputReceiver(NuGet.Protocol.Plugins.IPluginProcess process) -> void
NuGet.Protocol.Plugins.SymmetricHandshake
NuGet.Protocol.Plugins.SymmetricHandshake.CancellationToken.get -> System.Threading.CancellationToken
NuGet.Protocol.Plugins.SymmetricHandshake.Dispose() -> void
~NuGet.Protocol.Plugins.SymmetricHandshake.HandleResponseAsync(NuGet.Protocol.Plugins.IConnection connection, NuGet.Protocol.Plugins.Message request, NuGet.Protocol.Plugins.IResponseHandler responseHandler, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
~NuGet.Protocol.Plugins.SymmetricHandshake.HandshakeAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Versioning.SemanticVersion>
~NuGet.Protocol.Plugins.SymmetricHandshake.SymmetricHandshake(NuGet.Protocol.Plugins.IConnection connection, System.TimeSpan handshakeTimeout, NuGet.Versioning.SemanticVersion protocolVersion, NuGet.Versioning.SemanticVersion minimumProtocolVersion) -> void
NuGet.Protocol.Plugins.TimeoutUtilities
NuGet.Protocol.Plugins.UnixAndMonoPlatformsEmbeddedSignatureVerifier
NuGet.Protocol.Plugins.UnixAndMonoPlatformsEmbeddedSignatureVerifier.UnixAndMonoPlatformsEmbeddedSignatureVerifier() -> void
NuGet.Protocol.Plugins.WindowsEmbeddedSignatureVerifier
NuGet.Protocol.Plugins.WindowsEmbeddedSignatureVerifier.WindowsEmbeddedSignatureVerifier() -> void
NuGet.Protocol.ProtocolConstants
NuGet.Protocol.Providers.VulnerabilityInfoResourceV3Provider
NuGet.Protocol.Providers.VulnerabilityInfoResourceV3Provider.VulnerabilityInfoResourceV3Provider() -> void
NuGet.Protocol.ProxyAuthenticationHandler
~NuGet.Protocol.ProxyAuthenticationHandler.ProxyAuthenticationHandler(System.Net.Http.HttpClientHandler clientHandler, NuGet.Configuration.ICredentialService credentialService, NuGet.Configuration.IProxyCredentialCache credentialCache) -> void
NuGet.Protocol.RawSearchResourceV3
~NuGet.Protocol.RawSearchResourceV3.RawSearchResourceV3(NuGet.Protocol.HttpSource client, System.Collections.Generic.IEnumerable<System.Uri> searchEndpoints) -> void
NuGet.Protocol.RawSearchResourceV3Provider
NuGet.Protocol.RawSearchResourceV3Provider.RawSearchResourceV3Provider() -> void
NuGet.Protocol.RegistrationResourceV3
~NuGet.Protocol.RegistrationResourceV3.BaseUri.get -> System.Uri
~NuGet.Protocol.RegistrationResourceV3.RegistrationResourceV3(NuGet.Protocol.HttpSource client, System.Uri baseUrl) -> void
NuGet.Protocol.RegistrationResourceV3Provider
NuGet.Protocol.RegistrationResourceV3Provider.RegistrationResourceV3Provider() -> void
NuGet.Protocol.RegistrationUtility
NuGet.Protocol.RemotePackageArchiveDownloader
~NuGet.Protocol.RemotePackageArchiveDownloader.ContentReader.get -> NuGet.Packaging.IAsyncPackageContentReader
~NuGet.Protocol.RemotePackageArchiveDownloader.CopyNupkgFileToAsync(string destinationFilePath, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>
~NuGet.Protocol.RemotePackageArchiveDownloader.CoreReader.get -> NuGet.Packaging.Core.IAsyncPackageCoreReader
NuGet.Protocol.RemotePackageArchiveDownloader.Dispose() -> void
~NuGet.Protocol.RemotePackageArchiveDownloader.GetPackageHashAsync(string hashAlgorithm, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<string>
~NuGet.Protocol.RemotePackageArchiveDownloader.RemotePackageArchiveDownloader(string source, NuGet.Protocol.Core.Types.FindPackageByIdResource resource, NuGet.Packaging.Core.PackageIdentity packageIdentity, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger) -> void
~NuGet.Protocol.RemotePackageArchiveDownloader.SetExceptionHandler(System.Func<System.Exception, System.Threading.Tasks.Task<bool>> handleExceptionAsync) -> void
~NuGet.Protocol.RemotePackageArchiveDownloader.SetThrottle(System.Threading.SemaphoreSlim throttle) -> void
~NuGet.Protocol.RemotePackageArchiveDownloader.SignedPackageReader.get -> NuGet.Packaging.Signing.ISignedPackageReader
~NuGet.Protocol.RemotePackageArchiveDownloader.Source.get -> string
NuGet.Protocol.RemoteV2FindPackageByIdResource
~NuGet.Protocol.RemoteV2FindPackageByIdResource.PackageSource.get -> NuGet.Configuration.PackageSource
~NuGet.Protocol.RemoteV2FindPackageByIdResource.RemoteV2FindPackageByIdResource(NuGet.Configuration.PackageSource packageSource, NuGet.Protocol.HttpSource httpSource) -> void
NuGet.Protocol.RemoteV2FindPackageByIdResourceProvider
NuGet.Protocol.RemoteV2FindPackageByIdResourceProvider.RemoteV2FindPackageByIdResourceProvider() -> void
NuGet.Protocol.RemoteV3FindPackageByIdResource
~NuGet.Protocol.RemoteV3FindPackageByIdResource.RemoteV3FindPackageByIdResource(NuGet.Protocol.Core.Types.SourceRepository sourceRepository, NuGet.Protocol.HttpSource httpSource) -> void
~NuGet.Protocol.RemoteV3FindPackageByIdResource.SourceRepository.get -> NuGet.Protocol.Core.Types.SourceRepository
NuGet.Protocol.RemoteV3FindPackageByIdResourceProvider
NuGet.Protocol.RemoteV3FindPackageByIdResourceProvider.RemoteV3FindPackageByIdResourceProvider() -> void
NuGet.Protocol.ReportAbuseResourceV3
~NuGet.Protocol.ReportAbuseResourceV3.GetReportAbuseUrl(string id, NuGet.Versioning.NuGetVersion version) -> System.Uri
~NuGet.Protocol.ReportAbuseResourceV3.ReportAbuseResourceV3(string uriTemplate) -> void
NuGet.Protocol.ReportAbuseResourceV3Provider
NuGet.Protocol.ReportAbuseResourceV3Provider.ReportAbuseResourceV3Provider() -> void
NuGet.Protocol.RepositoryCertificateInfo
~NuGet.Protocol.RepositoryCertificateInfo.ContentUrl.get -> string
~NuGet.Protocol.RepositoryCertificateInfo.Fingerprints.get -> NuGet.Packaging.Core.Fingerprints
~NuGet.Protocol.RepositoryCertificateInfo.Issuer.get -> string
NuGet.Protocol.RepositoryCertificateInfo.NotAfter.get -> System.DateTimeOffset
NuGet.Protocol.RepositoryCertificateInfo.NotBefore.get -> System.DateTimeOffset
NuGet.Protocol.RepositoryCertificateInfo.RepositoryCertificateInfo() -> void
~NuGet.Protocol.RepositoryCertificateInfo.Subject.get -> string
NuGet.Protocol.RepositorySignatureResource
NuGet.Protocol.RepositorySignatureResource.AllRepositorySigned.get -> bool
~NuGet.Protocol.RepositorySignatureResource.RepositoryCertificateInfos.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.IRepositoryCertificateInfo>
~NuGet.Protocol.RepositorySignatureResource.RepositorySignatureResource(Newtonsoft.Json.Linq.JObject repoSignInformationContent, NuGet.Protocol.Core.Types.SourceRepository source) -> void
~NuGet.Protocol.RepositorySignatureResource.RepositorySignatureResource(bool allRepositorySigned, System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.IRepositoryCertificateInfo> repositoryCertInfos) -> void
~NuGet.Protocol.RepositorySignatureResource.Source.get -> string
NuGet.Protocol.RepositorySignatureResource.UpdateRepositorySignatureInfo() -> void
NuGet.Protocol.RepositorySignatureResourceProvider
NuGet.Protocol.RepositorySignatureResourceProvider.RepositorySignatureResourceProvider() -> void
NuGet.Protocol.Resources.VulnerabilityInfoResourceV3
NuGet.Protocol.Resources.VulnerabilityInfoResourceV3.GetVulnerabilityDataAsync(NuGet.Protocol.Model.V3VulnerabilityIndexEntry! vulnerabilityPage, NuGet.Protocol.Core.Types.SourceCacheContext! cacheContext, NuGet.Common.ILogger! logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyDictionary<string!, System.Collections.Generic.IReadOnlyList<NuGet.Protocol.Model.PackageVulnerabilityInfo!>!>!>!
NuGet.Protocol.Resources.VulnerabilityInfoResourceV3.GetVulnerabilityFilesAsync(NuGet.Protocol.Core.Types.SourceCacheContext! cacheContext, NuGet.Common.ILogger! log, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<NuGet.Protocol.Model.V3VulnerabilityIndexEntry!>!>!
NuGet.Protocol.Resources.VulnerabilityInfoResourceV3.GetVulnerabilityInfoAsync(NuGet.Protocol.Core.Types.SourceCacheContext! cacheContext, NuGet.Common.ILogger! logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Protocol.Model.GetVulnerabilityInfoResult!>!
NuGet.Protocol.SafeBoolConverter
NuGet.Protocol.SafeBoolConverter.SafeBoolConverter() -> void
NuGet.Protocol.SafeUriConverter
NuGet.Protocol.SafeUriConverter.SafeUriConverter() -> void
NuGet.Protocol.SemanticVersionConverter
NuGet.Protocol.SemanticVersionConverter.SemanticVersionConverter() -> void
NuGet.Protocol.SemaphoreSlimThrottle
NuGet.Protocol.SemaphoreSlimThrottle.CurrentCount.get -> int
NuGet.Protocol.SemaphoreSlimThrottle.Release() -> void
~NuGet.Protocol.SemaphoreSlimThrottle.SemaphoreSlimThrottle(System.Threading.SemaphoreSlim semaphore) -> void
~NuGet.Protocol.SemaphoreSlimThrottle.WaitAsync() -> System.Threading.Tasks.Task
NuGet.Protocol.ServerWarningLogHandler
~NuGet.Protocol.ServerWarningLogHandler.ServerWarningLogHandler(System.Net.Http.HttpClientHandler clientHandler) -> void
NuGet.Protocol.ServiceIndexEntry
~NuGet.Protocol.ServiceIndexEntry.ClientVersion.get -> NuGet.Versioning.SemanticVersion
~NuGet.Protocol.ServiceIndexEntry.ServiceIndexEntry(System.Uri serviceUri, string serviceType, NuGet.Versioning.SemanticVersion clientVersion) -> void
~NuGet.Protocol.ServiceIndexEntry.Type.get -> string
~NuGet.Protocol.ServiceIndexEntry.Uri.get -> System.Uri
NuGet.Protocol.ServiceIndexResourceV3
~NuGet.Protocol.ServiceIndexResourceV3.ServiceIndexResourceV3(Newtonsoft.Json.Linq.JObject index, System.DateTime requestTime) -> void
NuGet.Protocol.ServiceIndexResourceV3Provider
NuGet.Protocol.ServiceIndexResourceV3Provider.MaxCacheDuration.get -> System.TimeSpan
NuGet.Protocol.ServiceIndexResourceV3Provider.MaxCacheDuration.set -> void
NuGet.Protocol.ServiceIndexResourceV3Provider.ServiceIndexCacheInfo
NuGet.Protocol.ServiceIndexResourceV3Provider.ServiceIndexCacheInfo.CachedTime.get -> System.DateTime
NuGet.Protocol.ServiceIndexResourceV3Provider.ServiceIndexCacheInfo.CachedTime.set -> void
~NuGet.Protocol.ServiceIndexResourceV3Provider.ServiceIndexCacheInfo.Index.get -> NuGet.Protocol.ServiceIndexResourceV3
~NuGet.Protocol.ServiceIndexResourceV3Provider.ServiceIndexCacheInfo.Index.set -> void
NuGet.Protocol.ServiceIndexResourceV3Provider.ServiceIndexCacheInfo.ServiceIndexCacheInfo() -> void
NuGet.Protocol.ServiceIndexResourceV3Provider.ServiceIndexResourceV3Provider() -> void
NuGet.Protocol.ServiceTypes
NuGet.Protocol.StreamExtensions
NuGet.Protocol.StsAuthenticationHandler
~NuGet.Protocol.StsAuthenticationHandler.StsAuthenticationHandler(NuGet.Configuration.PackageSource packageSource, NuGet.Protocol.TokenStore tokenStore) -> void
~NuGet.Protocol.StsAuthenticationHandler.StsAuthenticationHandler(NuGet.Configuration.PackageSource packageSource, NuGet.Protocol.TokenStore tokenStore, System.Func<string, string, string> tokenFactory) -> void
~NuGet.Protocol.StsAuthenticationHandler.TryRetrieveSTSToken(System.Net.Http.HttpResponseMessage response) -> bool
NuGet.Protocol.SymbolPackageUpdateResourceV3Provider
NuGet.Protocol.SymbolPackageUpdateResourceV3Provider.SymbolPackageUpdateResourceV3Provider() -> void
NuGet.Protocol.TimeoutUtility
NuGet.Protocol.TokenStore
~NuGet.Protocol.TokenStore.AddToken(System.Uri sourceUri, string token) -> void
~NuGet.Protocol.TokenStore.GetToken(System.Uri sourceUri) -> string
NuGet.Protocol.TokenStore.TokenStore() -> void
NuGet.Protocol.TokenStore.Version.get -> System.Guid
NuGet.Protocol.V2FeedListResource
~NuGet.Protocol.V2FeedListResource.V2FeedListResource(NuGet.Protocol.IV2FeedParser feedParser, NuGet.Protocol.Core.Types.ILegacyFeedCapabilityResource feedCapabilities, string baseAddress) -> void
NuGet.Protocol.V2FeedListResourceProvider
NuGet.Protocol.V2FeedListResourceProvider.V2FeedListResourceProvider() -> void
NuGet.Protocol.V2FeedPackageInfo
~NuGet.Protocol.V2FeedPackageInfo.Authors.get -> System.Collections.Generic.IEnumerable<string>
NuGet.Protocol.V2FeedPackageInfo.Created.get -> System.DateTimeOffset?
~NuGet.Protocol.V2FeedPackageInfo.Dependencies.get -> string
~NuGet.Protocol.V2FeedPackageInfo.DependencySets.get -> System.Collections.Generic.IReadOnlyList<NuGet.Packaging.PackageDependencyGroup>
~NuGet.Protocol.V2FeedPackageInfo.Description.get -> string
~NuGet.Protocol.V2FeedPackageInfo.DownloadCount.get -> string
NuGet.Protocol.V2FeedPackageInfo.DownloadCountAsInt.get -> int
~NuGet.Protocol.V2FeedPackageInfo.DownloadUrl.get -> string
~NuGet.Protocol.V2FeedPackageInfo.GalleryDetailsUrl.get -> string
~NuGet.Protocol.V2FeedPackageInfo.IconUrl.get -> string
NuGet.Protocol.V2FeedPackageInfo.IsListed.get -> bool
NuGet.Protocol.V2FeedPackageInfo.LastEdited.get -> System.DateTimeOffset?
~NuGet.Protocol.V2FeedPackageInfo.LicenseUrl.get -> string
~NuGet.Protocol.V2FeedPackageInfo.MinClientVersion.get -> NuGet.Versioning.NuGetVersion
~NuGet.Protocol.V2FeedPackageInfo.Owners.get -> System.Collections.Generic.IEnumerable<string>
~NuGet.Protocol.V2FeedPackageInfo.PackageHash.get -> string
~NuGet.Protocol.V2FeedPackageInfo.PackageHashAlgorithm.get -> string
~NuGet.Protocol.V2FeedPackageInfo.ProjectUrl.get -> string
NuGet.Protocol.V2FeedPackageInfo.Published.get -> System.DateTimeOffset?
~NuGet.Protocol.V2FeedPackageInfo.ReportAbuseUrl.get -> string
NuGet.Protocol.V2FeedPackageInfo.RequireLicenseAcceptance.get -> bool
~NuGet.Protocol.V2FeedPackageInfo.Summary.get -> string
~NuGet.Protocol.V2FeedPackageInfo.Tags.get -> string
~NuGet.Protocol.V2FeedPackageInfo.Title.get -> string
~NuGet.Protocol.V2FeedPackageInfo.V2FeedPackageInfo(NuGet.Packaging.Core.PackageIdentity identity, string title, string summary, string description, System.Collections.Generic.IEnumerable<string> authors, System.Collections.Generic.IEnumerable<string> owners, string iconUrl, string licenseUrl, string projectUrl, string reportAbuseUrl, string galleryDetailsUrl, string tags, System.DateTimeOffset? created, System.DateTimeOffset? lastEdited, System.DateTimeOffset? published, string dependencies, bool requireLicenseAccept, string downloadUrl, string downloadCount, string packageHash, string packageHashAlgorithm, NuGet.Versioning.NuGetVersion minClientVersion) -> void
NuGet.Protocol.V2FeedPage
~NuGet.Protocol.V2FeedPage.Items.get -> System.Collections.Generic.IReadOnlyList<NuGet.Protocol.V2FeedPackageInfo>
~NuGet.Protocol.V2FeedPage.NextUri.get -> string
~NuGet.Protocol.V2FeedPage.V2FeedPage(System.Collections.Generic.List<NuGet.Protocol.V2FeedPackageInfo> items, string nextUri) -> void
NuGet.Protocol.V2FeedParser
~NuGet.Protocol.V2FeedParser.DownloadFromIdentity(NuGet.Packaging.Core.PackageIdentity package, NuGet.Protocol.Core.Types.PackageDownloadContext downloadContext, string globalPackagesFolder, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.DownloadResourceResult>
~NuGet.Protocol.V2FeedParser.DownloadFromUrl(NuGet.Packaging.Core.PackageIdentity package, System.Uri downloadUri, NuGet.Protocol.Core.Types.PackageDownloadContext downloadContext, string globalPackagesFolder, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.DownloadResourceResult>
~NuGet.Protocol.V2FeedParser.FindPackagesByIdAsync(string id, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<NuGet.Protocol.V2FeedPackageInfo>>
~NuGet.Protocol.V2FeedParser.FindPackagesByIdAsync(string id, bool includeUnlisted, bool includePrerelease, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<NuGet.Protocol.V2FeedPackageInfo>>
~NuGet.Protocol.V2FeedParser.GetPackage(NuGet.Packaging.Core.PackageIdentity package, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Protocol.V2FeedPackageInfo>
~NuGet.Protocol.V2FeedParser.GetPackagesPageAsync(string searchTerm, NuGet.Protocol.Core.Types.SearchFilter filters, int skip, int take, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Protocol.V2FeedPage>
~NuGet.Protocol.V2FeedParser.GetSearchPageAsync(string searchTerm, NuGet.Protocol.Core.Types.SearchFilter filters, int skip, int take, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Protocol.V2FeedPage>
~NuGet.Protocol.V2FeedParser.QueryV2FeedAsync(string relativeUri, string id, int max, bool ignoreNotFounds, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Protocol.V2FeedPage>
~NuGet.Protocol.V2FeedParser.Search(string searchTerm, NuGet.Protocol.Core.Types.SearchFilter filters, int skip, int take, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<NuGet.Protocol.V2FeedPackageInfo>>
~NuGet.Protocol.V2FeedParser.Source.get -> string
~NuGet.Protocol.V2FeedParser.V2FeedParser(NuGet.Protocol.HttpSource httpSource, string baseAddress) -> void
~NuGet.Protocol.V2FeedParser.V2FeedParser(NuGet.Protocol.HttpSource httpSource, string baseAddress, string source) -> void
NuGet.Protocol.V2FeedQueryBuilder
~NuGet.Protocol.V2FeedQueryBuilder.BuildFindPackagesByIdUri(string id) -> string
~NuGet.Protocol.V2FeedQueryBuilder.BuildGetPackageUri(NuGet.Packaging.Core.PackageIdentity package) -> string
~NuGet.Protocol.V2FeedQueryBuilder.BuildGetPackagesUri(string searchTerm, NuGet.Protocol.Core.Types.SearchFilter filters, int? skip, int? take) -> string
~NuGet.Protocol.V2FeedQueryBuilder.BuildSearchUri(string searchTerm, NuGet.Protocol.Core.Types.SearchFilter filters, int skip, int take) -> string
NuGet.Protocol.V2FeedQueryBuilder.V2FeedQueryBuilder() -> void
NuGet.Protocol.V2FeedUtilities
NuGet.Protocol.V3FeedListResourceProvider
NuGet.Protocol.V3FeedListResourceProvider.V3FeedListResourceProvider() -> void
NuGet.Protocol.VersionInfoConverter
NuGet.Protocol.VersionInfoConverter.VersionInfoConverter() -> void
NuGet.Protocol.VersionRangeConverter
NuGet.Protocol.VersionRangeConverter.VersionRangeConverter() -> void
NuGet.Protocol.VisualStudio.FactoryExtensionsVS
NuGet.Repositories.LocalPackageInfo
~NuGet.Repositories.LocalPackageInfo.ExpandedPath.get -> string
~NuGet.Repositories.LocalPackageInfo.ExpandedPath.set -> void
~NuGet.Repositories.LocalPackageInfo.Files.get -> System.Collections.Generic.IReadOnlyList<string>
~NuGet.Repositories.LocalPackageInfo.Id.get -> string
~NuGet.Repositories.LocalPackageInfo.LocalPackageInfo(string packageId, NuGet.Versioning.NuGetVersion version, string path, string manifestPath, string zipPath, string sha512Path, System.Lazy<NuGet.Packaging.NuspecReader> nuspec, System.Lazy<System.Collections.Generic.IReadOnlyList<string>> files, System.Lazy<string> sha512, System.Lazy<NuGet.RuntimeModel.RuntimeGraph> runtimeGraph) -> void
~NuGet.Repositories.LocalPackageInfo.ManifestPath.get -> string
~NuGet.Repositories.LocalPackageInfo.Nuspec.get -> NuGet.Packaging.NuspecReader
~NuGet.Repositories.LocalPackageInfo.RuntimeGraph.get -> NuGet.RuntimeModel.RuntimeGraph
~NuGet.Repositories.LocalPackageInfo.Sha512.get -> string
~NuGet.Repositories.LocalPackageInfo.Sha512Path.get -> string
~NuGet.Repositories.LocalPackageInfo.Version.get -> NuGet.Versioning.NuGetVersion
~NuGet.Repositories.LocalPackageInfo.ZipPath.get -> string
NuGet.Repositories.LocalPackageSourceInfo
~NuGet.Repositories.LocalPackageSourceInfo.LocalPackageSourceInfo(NuGet.Repositories.NuGetv3LocalRepository repository, NuGet.Repositories.LocalPackageInfo package) -> void
~NuGet.Repositories.LocalPackageSourceInfo.Package.get -> NuGet.Repositories.LocalPackageInfo
~NuGet.Repositories.LocalPackageSourceInfo.Repository.get -> NuGet.Repositories.NuGetv3LocalRepository
NuGet.Repositories.NuGetv3LocalRepository
~NuGet.Repositories.NuGetv3LocalRepository.ClearCacheForIds(System.Collections.Generic.IEnumerable<string> packageIds) -> void
~NuGet.Repositories.NuGetv3LocalRepository.Exists(string packageId, NuGet.Versioning.NuGetVersion version) -> bool
~NuGet.Repositories.NuGetv3LocalRepository.FindPackage(string packageId, NuGet.Versioning.NuGetVersion version) -> NuGet.Repositories.LocalPackageInfo
~NuGet.Repositories.NuGetv3LocalRepository.FindPackagesById(string packageId) -> System.Collections.Generic.IEnumerable<NuGet.Repositories.LocalPackageInfo>
~NuGet.Repositories.NuGetv3LocalRepository.NuGetv3LocalRepository(string path) -> void
~NuGet.Repositories.NuGetv3LocalRepository.NuGetv3LocalRepository(string path, NuGet.Protocol.LocalPackageFileCache packageFileCache, bool isFallbackFolder) -> void
~NuGet.Repositories.NuGetv3LocalRepository.NuGetv3LocalRepository(string path, NuGet.Protocol.LocalPackageFileCache packageFileCache, bool isFallbackFolder, bool updateLastAccessTime) -> void
~NuGet.Repositories.NuGetv3LocalRepository.PathResolver.get -> NuGet.Packaging.VersionFolderPathResolver
~NuGet.Repositories.NuGetv3LocalRepository.RepositoryRoot.get -> string
NuGet.Repositories.NuGetv3LocalRepositoryUtility
~abstract NuGet.Protocol.Core.Types.AutoCompleteResource.IdStartsWith(string packageIdPrefix, bool includePrerelease, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<string>>
~abstract NuGet.Protocol.Core.Types.AutoCompleteResource.VersionStartsWith(string packageId, string versionPrefix, bool includePrerelease, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Versioning.NuGetVersion>>
~abstract NuGet.Protocol.Core.Types.DependencyInfoResource.ResolvePackage(NuGet.Packaging.Core.PackageIdentity package, NuGet.Frameworks.NuGetFramework projectFramework, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.SourcePackageDependencyInfo>
~abstract NuGet.Protocol.Core.Types.DependencyInfoResource.ResolvePackages(string packageId, NuGet.Frameworks.NuGetFramework projectFramework, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.SourcePackageDependencyInfo>>
~abstract NuGet.Protocol.Core.Types.DownloadResource.GetDownloadResourceResultAsync(NuGet.Packaging.Core.PackageIdentity identity, NuGet.Protocol.Core.Types.PackageDownloadContext downloadContext, string globalPackagesFolder, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.DownloadResourceResult>
~abstract NuGet.Protocol.Core.Types.FindPackageByIdResource.CopyNupkgToStreamAsync(string id, NuGet.Versioning.NuGetVersion version, System.IO.Stream destination, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>
~abstract NuGet.Protocol.Core.Types.FindPackageByIdResource.DoesPackageExistAsync(string id, NuGet.Versioning.NuGetVersion version, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>
~abstract NuGet.Protocol.Core.Types.FindPackageByIdResource.GetAllVersionsAsync(string id, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Versioning.NuGetVersion>>
~abstract NuGet.Protocol.Core.Types.FindPackageByIdResource.GetDependencyInfoAsync(string id, NuGet.Versioning.NuGetVersion version, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo>
~abstract NuGet.Protocol.Core.Types.FindPackageByIdResource.GetPackageDownloaderAsync(NuGet.Packaging.Core.PackageIdentity packageIdentity, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Packaging.IPackageDownloader>
~abstract NuGet.Protocol.Core.Types.HttpHandlerResource.ClientHandler.get -> System.Net.Http.HttpClientHandler
~abstract NuGet.Protocol.Core.Types.HttpHandlerResource.MessageHandler.get -> System.Net.Http.HttpMessageHandler
~abstract NuGet.Protocol.Core.Types.LegacyFeedCapabilityResource.SupportsIsAbsoluteLatestVersionAsync(NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<bool>
~abstract NuGet.Protocol.Core.Types.LegacyFeedCapabilityResource.SupportsSearchAsync(NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<bool>
~abstract NuGet.Protocol.Core.Types.ListResource.ListAsync(string searchTerm, bool prerelease, bool allVersions, bool includeDelisted, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Common.IEnumerableAsync<NuGet.Protocol.Core.Types.IPackageSearchMetadata>>
~abstract NuGet.Protocol.Core.Types.ListResource.Source.get -> string
~abstract NuGet.Protocol.Core.Types.MetadataResource.Exists(NuGet.Packaging.Core.PackageIdentity identity, bool includeUnlisted, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<bool>
~abstract NuGet.Protocol.Core.Types.MetadataResource.Exists(string packageId, bool includePrerelease, bool includeUnlisted, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<bool>
~abstract NuGet.Protocol.Core.Types.MetadataResource.GetLatestVersions(System.Collections.Generic.IEnumerable<string> packageIds, bool includePrerelease, bool includeUnlisted, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, NuGet.Versioning.NuGetVersion>>>
~abstract NuGet.Protocol.Core.Types.MetadataResource.GetVersions(string packageId, bool includePrerelease, bool includeUnlisted, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Versioning.NuGetVersion>>
~abstract NuGet.Protocol.Core.Types.PackageMetadataResource.GetMetadataAsync(NuGet.Packaging.Core.PackageIdentity package, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.IPackageSearchMetadata>
~abstract NuGet.Protocol.Core.Types.PackageMetadataResource.GetMetadataAsync(string packageId, bool includePrerelease, bool includeUnlisted, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.IPackageSearchMetadata>>
~abstract NuGet.Protocol.Core.Types.PackageSearchResource.SearchAsync(string searchTerm, NuGet.Protocol.Core.Types.SearchFilter filters, int skip, int take, NuGet.Common.ILogger log, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.IPackageSearchMetadata>>
abstract NuGet.Protocol.Core.Types.ResourceProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository! source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource?>!>!
~abstract NuGet.Protocol.FindLocalPackagesResource.FindPackagesById(string id, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Collections.Generic.IEnumerable<NuGet.Protocol.LocalPackageInfo>
~abstract NuGet.Protocol.FindLocalPackagesResource.GetPackage(NuGet.Packaging.Core.PackageIdentity identity, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> NuGet.Protocol.LocalPackageInfo
~abstract NuGet.Protocol.FindLocalPackagesResource.GetPackage(System.Uri path, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> NuGet.Protocol.LocalPackageInfo
~abstract NuGet.Protocol.FindLocalPackagesResource.GetPackages(NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Collections.Generic.IEnumerable<NuGet.Protocol.LocalPackageInfo>
~abstract NuGet.Protocol.Plugins.EmbeddedSignatureVerifier.IsValid(string filePath) -> bool
abstract NuGet.Protocol.Plugins.OutboundRequestContext.Dispose(bool disposing) -> void
abstract NuGet.Protocol.Plugins.OutboundRequestContext.HandleCancelResponse() -> void
~abstract NuGet.Protocol.Plugins.OutboundRequestContext.HandleFault(NuGet.Protocol.Plugins.Message fault) -> void
~abstract NuGet.Protocol.Plugins.OutboundRequestContext.HandleProgress(NuGet.Protocol.Plugins.Message progress) -> void
~abstract NuGet.Protocol.Plugins.OutboundRequestContext.HandleResponse(NuGet.Protocol.Plugins.Message response) -> void
abstract NuGet.Protocol.Plugins.Receiver.Connect() -> void
abstract NuGet.Protocol.Plugins.Receiver.Dispose(bool disposing) -> void
const NuGet.Protocol.CachingUtility.BufferSize = 8192 -> int
~const NuGet.Protocol.Core.Types.NuGetResourceProviderPositions.First = "First" -> string
~const NuGet.Protocol.Core.Types.NuGetResourceProviderPositions.Last = "Last" -> string
~const NuGet.Protocol.Core.Types.NuGetTestMode.NuGetTestClientName = "NuGet Test Client" -> string
const NuGet.Protocol.JsonExtensions.JsonSerializationMaxDepth = 512 -> int
~const NuGet.Protocol.JsonProperties.AdvisoryUrl = "advisoryUrl" -> string
~const NuGet.Protocol.JsonProperties.AllRepositorySigned = "allRepositorySigned" -> string
~const NuGet.Protocol.JsonProperties.AlternatePackage = "alternatePackage" -> string
~const NuGet.Protocol.JsonProperties.Authors = "authors" -> string
~const NuGet.Protocol.JsonProperties.ContentUrl = "contentUrl" -> string
~const NuGet.Protocol.JsonProperties.Created = "created" -> string
~const NuGet.Protocol.JsonProperties.Data = "data" -> string
~const NuGet.Protocol.JsonProperties.Dependencies = "dependencies" -> string
~const NuGet.Protocol.JsonProperties.DependencyGroups = "dependencyGroups" -> string
~const NuGet.Protocol.JsonProperties.Deprecation = "deprecation" -> string
~const NuGet.Protocol.JsonProperties.DeprecationMessage = "message" -> string
~const NuGet.Protocol.JsonProperties.DeprecationReasons = "reasons" -> string
~const NuGet.Protocol.JsonProperties.Description = "description" -> string
~const NuGet.Protocol.JsonProperties.DownloadCount = "totalDownloads" -> string
~const NuGet.Protocol.JsonProperties.Fingerprints = "fingerprints" -> string
~const NuGet.Protocol.JsonProperties.IconUrl = "iconUrl" -> string
~const NuGet.Protocol.JsonProperties.Issuer = "issuer" -> string
~const NuGet.Protocol.JsonProperties.Language = "language" -> string
~const NuGet.Protocol.JsonProperties.LastEdited = "lastEdited" -> string
~const NuGet.Protocol.JsonProperties.LatestVersion = "latestVersion" -> string
~const NuGet.Protocol.JsonProperties.LicenseExpression = "licenseExpression" -> string
~const NuGet.Protocol.JsonProperties.LicenseExpressionVersion = "licenseExpressionVersion" -> string
~const NuGet.Protocol.JsonProperties.LicenseUrl = "licenseUrl" -> string
~const NuGet.Protocol.JsonProperties.Listed = "listed" -> string
~const NuGet.Protocol.JsonProperties.MinimumClientVersion = "minClientVersion" -> string
~const NuGet.Protocol.JsonProperties.NotAfter = "notAfter" -> string
~const NuGet.Protocol.JsonProperties.NotBefore = "notBefore" -> string
~const NuGet.Protocol.JsonProperties.Owners = "owners" -> string
~const NuGet.Protocol.JsonProperties.PackageContent = "packageContent" -> string
~const NuGet.Protocol.JsonProperties.PackageId = "id" -> string
~const NuGet.Protocol.JsonProperties.PrefixReserved = "verified" -> string
~const NuGet.Protocol.JsonProperties.ProjectUrl = "projectUrl" -> string
~const NuGet.Protocol.JsonProperties.Published = "published" -> string
~const NuGet.Protocol.JsonProperties.Range = "range" -> string
~const NuGet.Protocol.JsonProperties.ReadmeUrl = "readmeUrl" -> string
~const NuGet.Protocol.JsonProperties.RequireLicenseAcceptance = "requireLicenseAcceptance" -> string
~const NuGet.Protocol.JsonProperties.Severity = "severity" -> string
~const NuGet.Protocol.JsonProperties.SigningCertificates = "signingCertificates" -> string
~const NuGet.Protocol.JsonProperties.Subject = "subject" -> string
~const NuGet.Protocol.JsonProperties.SubjectId = "@id" -> string
~const NuGet.Protocol.JsonProperties.Summary = "summary" -> string
~const NuGet.Protocol.JsonProperties.Tags = "tags" -> string
~const NuGet.Protocol.JsonProperties.TargetFramework = "targetFramework" -> string
~const NuGet.Protocol.JsonProperties.Title = "title" -> string
~const NuGet.Protocol.JsonProperties.Type = "@type" -> string
~const NuGet.Protocol.JsonProperties.Version = "version" -> string
~const NuGet.Protocol.JsonProperties.Versions = "versions" -> string
~const NuGet.Protocol.JsonProperties.Vulnerabilities = "vulnerabilities" -> string
~const NuGet.Protocol.StsAuthenticationHandler.STSEndPointHeader = "X-NuGet-STS-EndPoint" -> string
~const NuGet.Protocol.StsAuthenticationHandler.STSRealmHeader = "X-NuGet-STS-Realm" -> string
~const NuGet.Protocol.StsAuthenticationHandler.STSTokenHeader = "X-NuGet-STS-Token" -> string
~override NuGet.Protocol.AutoCompleteResourceV2Feed.IdStartsWith(string packageIdPrefix, bool includePrerelease, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<string>>
~override NuGet.Protocol.AutoCompleteResourceV2Feed.VersionStartsWith(string packageId, string versionPrefix, bool includePrerelease, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Versioning.NuGetVersion>>
~override NuGet.Protocol.AutoCompleteResourceV2FeedProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.AutoCompleteResourceV3.IdStartsWith(string packageIdPrefix, bool includePrerelease, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<string>>
~override NuGet.Protocol.AutoCompleteResourceV3.VersionStartsWith(string packageId, string versionPrefix, bool includePrerelease, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Versioning.NuGetVersion>>
~override NuGet.Protocol.AutoCompleteResourceV3Provider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.Core.Types.NullSourceCacheContext.Clone() -> NuGet.Protocol.Core.Types.SourceCacheContext
~override NuGet.Protocol.Core.Types.NullSourceCacheContext.GeneratedTempFolder.get -> string
~override NuGet.Protocol.Core.Types.NullSourceCacheContext.WithRefreshCacheTrue() -> NuGet.Protocol.Core.Types.SourceCacheContext
~override NuGet.Protocol.Core.Types.PluginFindPackageByIdResource.CopyNupkgToStreamAsync(string id, NuGet.Versioning.NuGetVersion version, System.IO.Stream destination, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>
~override NuGet.Protocol.Core.Types.PluginFindPackageByIdResource.DoesPackageExistAsync(string id, NuGet.Versioning.NuGetVersion version, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>
~override NuGet.Protocol.Core.Types.PluginFindPackageByIdResource.GetAllVersionsAsync(string id, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Versioning.NuGetVersion>>
~override NuGet.Protocol.Core.Types.PluginFindPackageByIdResource.GetDependencyInfoAsync(string id, NuGet.Versioning.NuGetVersion version, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo>
~override NuGet.Protocol.Core.Types.PluginFindPackageByIdResource.GetPackageDownloaderAsync(NuGet.Packaging.Core.PackageIdentity packageIdentity, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Packaging.IPackageDownloader>
~override NuGet.Protocol.Core.Types.PluginResourceProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo.Equals(object obj) -> bool
override NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo.GetHashCode() -> int
~override NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo.ToString() -> string
~override NuGet.Protocol.Core.Types.SourceRepository.ToString() -> string
~override NuGet.Protocol.DependencyInfoResourceV2Feed.ResolvePackage(NuGet.Packaging.Core.PackageIdentity package, NuGet.Frameworks.NuGetFramework projectFramework, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.SourcePackageDependencyInfo>
~override NuGet.Protocol.DependencyInfoResourceV2Feed.ResolvePackages(string packageId, NuGet.Frameworks.NuGetFramework projectFramework, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.SourcePackageDependencyInfo>>
~override NuGet.Protocol.DependencyInfoResourceV2FeedProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.DependencyInfoResourceV3.ResolvePackage(NuGet.Packaging.Core.PackageIdentity package, NuGet.Frameworks.NuGetFramework projectFramework, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.SourcePackageDependencyInfo>
~override NuGet.Protocol.DependencyInfoResourceV3.ResolvePackages(string packageId, NuGet.Frameworks.NuGetFramework projectFramework, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.SourcePackageDependencyInfo>>
~override NuGet.Protocol.DependencyInfoResourceV3.ResolvePackages(string packageId, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo>>
~override NuGet.Protocol.DependencyInfoResourceV3Provider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.DownloadResourcePlugin.GetDownloadResourceResultAsync(NuGet.Packaging.Core.PackageIdentity identity, NuGet.Protocol.Core.Types.PackageDownloadContext downloadContext, string globalPackagesFolder, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.DownloadResourceResult>
~override NuGet.Protocol.DownloadResourcePluginProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.DownloadResourceV2Feed.GetDownloadResourceResultAsync(NuGet.Packaging.Core.PackageIdentity identity, NuGet.Protocol.Core.Types.PackageDownloadContext downloadContext, string globalPackagesFolder, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.DownloadResourceResult>
~override NuGet.Protocol.DownloadResourceV2FeedProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.DownloadResourceV3.GetDownloadResourceResultAsync(NuGet.Packaging.Core.PackageIdentity identity, NuGet.Protocol.Core.Types.PackageDownloadContext downloadContext, string globalPackagesFolder, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.DownloadResourceResult>
~override NuGet.Protocol.DownloadResourceV3Provider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.DownloadTimeoutStream.BeginRead(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state) -> System.IAsyncResult
override NuGet.Protocol.DownloadTimeoutStream.CanRead.get -> bool
override NuGet.Protocol.DownloadTimeoutStream.CanSeek.get -> bool
override NuGet.Protocol.DownloadTimeoutStream.CanWrite.get -> bool
override NuGet.Protocol.DownloadTimeoutStream.Dispose(bool disposing) -> void
~override NuGet.Protocol.DownloadTimeoutStream.EndRead(System.IAsyncResult asyncResult) -> int
override NuGet.Protocol.DownloadTimeoutStream.Flush() -> void
override NuGet.Protocol.DownloadTimeoutStream.Length.get -> long
override NuGet.Protocol.DownloadTimeoutStream.Position.get -> long
override NuGet.Protocol.DownloadTimeoutStream.Position.set -> void
~override NuGet.Protocol.DownloadTimeoutStream.Read(byte[] buffer, int offset, int count) -> int
~override NuGet.Protocol.DownloadTimeoutStream.ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<int>
override NuGet.Protocol.DownloadTimeoutStream.Seek(long offset, System.IO.SeekOrigin origin) -> long
override NuGet.Protocol.DownloadTimeoutStream.SetLength(long value) -> void
~override NuGet.Protocol.DownloadTimeoutStream.Write(byte[] buffer, int offset, int count) -> void
~override NuGet.Protocol.FeedTypeResourceProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.FindLocalPackagesResourcePackagesConfig.FindPackagesById(string id, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Collections.Generic.IEnumerable<NuGet.Protocol.LocalPackageInfo>
~override NuGet.Protocol.FindLocalPackagesResourcePackagesConfig.GetPackage(NuGet.Packaging.Core.PackageIdentity identity, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> NuGet.Protocol.LocalPackageInfo
~override NuGet.Protocol.FindLocalPackagesResourcePackagesConfig.GetPackage(System.Uri path, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> NuGet.Protocol.LocalPackageInfo
~override NuGet.Protocol.FindLocalPackagesResourcePackagesConfig.GetPackages(NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Collections.Generic.IEnumerable<NuGet.Protocol.LocalPackageInfo>
~override NuGet.Protocol.FindLocalPackagesResourcePackagesConfigProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.FindLocalPackagesResourceUnzipped.Exists(NuGet.Packaging.Core.PackageIdentity identity, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> bool
~override NuGet.Protocol.FindLocalPackagesResourceUnzipped.FindPackagesById(string id, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Collections.Generic.IEnumerable<NuGet.Protocol.LocalPackageInfo>
~override NuGet.Protocol.FindLocalPackagesResourceUnzipped.GetPackage(NuGet.Packaging.Core.PackageIdentity identity, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> NuGet.Protocol.LocalPackageInfo
~override NuGet.Protocol.FindLocalPackagesResourceUnzipped.GetPackage(System.Uri path, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> NuGet.Protocol.LocalPackageInfo
~override NuGet.Protocol.FindLocalPackagesResourceUnzipped.GetPackages(NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Collections.Generic.IEnumerable<NuGet.Protocol.LocalPackageInfo>
~override NuGet.Protocol.FindLocalPackagesResourceUnzippedProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.FindLocalPackagesResourceV2.FindPackagesById(string id, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Collections.Generic.IEnumerable<NuGet.Protocol.LocalPackageInfo>
~override NuGet.Protocol.FindLocalPackagesResourceV2.GetPackage(NuGet.Packaging.Core.PackageIdentity identity, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> NuGet.Protocol.LocalPackageInfo
~override NuGet.Protocol.FindLocalPackagesResourceV2.GetPackage(System.Uri path, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> NuGet.Protocol.LocalPackageInfo
~override NuGet.Protocol.FindLocalPackagesResourceV2.GetPackages(NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Collections.Generic.IEnumerable<NuGet.Protocol.LocalPackageInfo>
~override NuGet.Protocol.FindLocalPackagesResourceV2Provider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.FindLocalPackagesResourceV3.FindPackagesById(string id, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Collections.Generic.IEnumerable<NuGet.Protocol.LocalPackageInfo>
~override NuGet.Protocol.FindLocalPackagesResourceV3.GetPackage(NuGet.Packaging.Core.PackageIdentity identity, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> NuGet.Protocol.LocalPackageInfo
~override NuGet.Protocol.FindLocalPackagesResourceV3.GetPackage(System.Uri path, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> NuGet.Protocol.LocalPackageInfo
~override NuGet.Protocol.FindLocalPackagesResourceV3.GetPackages(NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Collections.Generic.IEnumerable<NuGet.Protocol.LocalPackageInfo>
~override NuGet.Protocol.FindLocalPackagesResourceV3Provider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.FingerprintsConverter.CanConvert(System.Type objectType) -> bool
override NuGet.Protocol.FingerprintsConverter.CanWrite.get -> bool
~override NuGet.Protocol.FingerprintsConverter.ReadJson(Newtonsoft.Json.JsonReader reader, System.Type objectType, object existingValue, Newtonsoft.Json.JsonSerializer serializer) -> object
~override NuGet.Protocol.FingerprintsConverter.WriteJson(Newtonsoft.Json.JsonWriter writer, object value, Newtonsoft.Json.JsonSerializer serializer) -> void
~override NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource.CopyNupkgToStreamAsync(string id, NuGet.Versioning.NuGetVersion version, System.IO.Stream destination, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>
~override NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource.DoesPackageExistAsync(string id, NuGet.Versioning.NuGetVersion version, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>
~override NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource.GetAllVersionsAsync(string id, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Versioning.NuGetVersion>>
~override NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource.GetDependencyInfoAsync(string id, NuGet.Versioning.NuGetVersion version, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo>
~override NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource.GetPackageDownloaderAsync(NuGet.Packaging.Core.PackageIdentity packageIdentity, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Packaging.IPackageDownloader>
~override NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResourceProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository sourceRepository, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.HttpHandlerResourceV3.ClientHandler.get -> System.Net.Http.HttpClientHandler
~override NuGet.Protocol.HttpHandlerResourceV3.MessageHandler.get -> System.Net.Http.HttpMessageHandler
~override NuGet.Protocol.HttpHandlerResourceV3Provider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
override NuGet.Protocol.HttpSourceAuthenticationHandler.Dispose(bool disposing) -> void
~override NuGet.Protocol.HttpSourceAuthenticationHandler.SendAsync(System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Net.Http.HttpResponseMessage>
~override NuGet.Protocol.HttpSourceResourceProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed.SupportsIsAbsoluteLatestVersionAsync(NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<bool>
~override NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed.SupportsSearchAsync(NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<bool>
~override NuGet.Protocol.LocalAutoCompleteResource.IdStartsWith(string packageIdPrefix, bool includePrerelease, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<string>>
~override NuGet.Protocol.LocalAutoCompleteResource.VersionStartsWith(string packageId, string versionPrefix, bool includePrerelease, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Versioning.NuGetVersion>>
~override NuGet.Protocol.LocalAutoCompleteResourceProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.LocalDependencyInfoResource.ResolvePackage(NuGet.Packaging.Core.PackageIdentity package, NuGet.Frameworks.NuGetFramework projectFramework, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.SourcePackageDependencyInfo>
~override NuGet.Protocol.LocalDependencyInfoResource.ResolvePackages(string packageId, NuGet.Frameworks.NuGetFramework projectFramework, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.SourcePackageDependencyInfo>>
~override NuGet.Protocol.LocalDependencyInfoResourceProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.LocalDownloadResource.GetDownloadResourceResultAsync(NuGet.Packaging.Core.PackageIdentity identity, NuGet.Protocol.Core.Types.PackageDownloadContext downloadContext, string globalPackagesFolder, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.DownloadResourceResult>
~override NuGet.Protocol.LocalDownloadResourceProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.LocalMetadataResource.Exists(NuGet.Packaging.Core.PackageIdentity identity, bool includeUnlisted, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<bool>
~override NuGet.Protocol.LocalMetadataResource.Exists(string packageId, bool includePrerelease, bool includeUnlisted, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<bool>
~override NuGet.Protocol.LocalMetadataResource.GetLatestVersions(System.Collections.Generic.IEnumerable<string> packageIds, bool includePrerelease, bool includeUnlisted, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, NuGet.Versioning.NuGetVersion>>>
~override NuGet.Protocol.LocalMetadataResource.GetVersions(string packageId, bool includePrerelease, bool includeUnlisted, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Versioning.NuGetVersion>>
~override NuGet.Protocol.LocalMetadataResourceProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.LocalPackageListResource.ListAsync(string searchTerm, bool prerelease, bool allVersions, bool includeDelisted, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Common.IEnumerableAsync<NuGet.Protocol.Core.Types.IPackageSearchMetadata>>
~override NuGet.Protocol.LocalPackageListResource.Source.get -> string
~override NuGet.Protocol.LocalPackageMetadataResource.GetMetadataAsync(NuGet.Packaging.Core.PackageIdentity package, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.IPackageSearchMetadata>
~override NuGet.Protocol.LocalPackageMetadataResource.GetMetadataAsync(string packageId, bool includePrerelease, bool includeUnlisted, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.IPackageSearchMetadata>>
~override NuGet.Protocol.LocalPackageMetadataResourceProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.LocalPackageSearchResource.SearchAsync(string searchTerm, NuGet.Protocol.Core.Types.SearchFilter filters, int skip, int take, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.IPackageSearchMetadata>>
~override NuGet.Protocol.LocalPackageSearchResourceProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.LocalRepositories.LocalPackageListResourceProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.LocalV2FindPackageByIdResource.CopyNupkgToStreamAsync(string id, NuGet.Versioning.NuGetVersion version, System.IO.Stream destination, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>
~override NuGet.Protocol.LocalV2FindPackageByIdResource.DoesPackageExistAsync(string id, NuGet.Versioning.NuGetVersion version, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>
~override NuGet.Protocol.LocalV2FindPackageByIdResource.GetAllVersionsAsync(string id, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Versioning.NuGetVersion>>
~override NuGet.Protocol.LocalV2FindPackageByIdResource.GetDependencyInfoAsync(string id, NuGet.Versioning.NuGetVersion version, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo>
~override NuGet.Protocol.LocalV2FindPackageByIdResource.GetPackageDownloaderAsync(NuGet.Packaging.Core.PackageIdentity packageIdentity, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Packaging.IPackageDownloader>
~override NuGet.Protocol.LocalV2FindPackageByIdResourceProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.LocalV3FindPackageByIdResource.CopyNupkgToStreamAsync(string id, NuGet.Versioning.NuGetVersion version, System.IO.Stream destination, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>
~override NuGet.Protocol.LocalV3FindPackageByIdResource.DoesPackageExistAsync(string id, NuGet.Versioning.NuGetVersion version, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>
~override NuGet.Protocol.LocalV3FindPackageByIdResource.GetAllVersionsAsync(string id, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Versioning.NuGetVersion>>
~override NuGet.Protocol.LocalV3FindPackageByIdResource.GetDependencyInfoAsync(string id, NuGet.Versioning.NuGetVersion version, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo>
~override NuGet.Protocol.LocalV3FindPackageByIdResource.GetPackageDownloaderAsync(NuGet.Packaging.Core.PackageIdentity packageIdentity, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Packaging.IPackageDownloader>
~override NuGet.Protocol.LocalV3FindPackageByIdResourceProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.MetadataFieldConverter.CanConvert(System.Type objectType) -> bool
override NuGet.Protocol.MetadataFieldConverter.CanWrite.get -> bool
~override NuGet.Protocol.MetadataFieldConverter.ReadJson(Newtonsoft.Json.JsonReader reader, System.Type objectType, object existingValue, Newtonsoft.Json.JsonSerializer serializer) -> object
~override NuGet.Protocol.MetadataFieldConverter.WriteJson(Newtonsoft.Json.JsonWriter writer, object value, Newtonsoft.Json.JsonSerializer serializer) -> void
~override NuGet.Protocol.MetadataResourceV2Feed.Exists(NuGet.Packaging.Core.PackageIdentity identity, bool includeUnlisted, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<bool>
~override NuGet.Protocol.MetadataResourceV2Feed.Exists(string packageId, bool includePrerelease, bool includeUnlisted, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<bool>
~override NuGet.Protocol.MetadataResourceV2Feed.GetLatestVersions(System.Collections.Generic.IEnumerable<string> packageIds, bool includePrerelease, bool includeUnlisted, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, NuGet.Versioning.NuGetVersion>>>
~override NuGet.Protocol.MetadataResourceV2Feed.GetVersions(string packageId, bool includePrerelease, bool includeUnlisted, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Versioning.NuGetVersion>>
~override NuGet.Protocol.MetadataResourceV2FeedProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.MetadataResourceV3.Exists(NuGet.Packaging.Core.PackageIdentity identity, bool includeUnlisted, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<bool>
~override NuGet.Protocol.MetadataResourceV3.Exists(string packageId, bool includePrerelease, bool includeUnlisted, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<bool>
~override NuGet.Protocol.MetadataResourceV3.GetLatestVersions(System.Collections.Generic.IEnumerable<string> packageIds, bool includePrerelease, bool includeUnlisted, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, NuGet.Versioning.NuGetVersion>>>
~override NuGet.Protocol.MetadataResourceV3.GetVersions(string packageId, bool includePrerelease, bool includeUnlisted, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Versioning.NuGetVersion>>
~override NuGet.Protocol.MetadataResourceV3Provider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
override NuGet.Protocol.Model.PackageVulnerabilityInfo.Equals(object? obj) -> bool
override NuGet.Protocol.Model.PackageVulnerabilityInfo.GetHashCode() -> int
~override NuGet.Protocol.NuGetVersionConverter.CanConvert(System.Type objectType) -> bool
~override NuGet.Protocol.NuGetVersionConverter.ReadJson(Newtonsoft.Json.JsonReader reader, System.Type objectType, object existingValue, Newtonsoft.Json.JsonSerializer serializer) -> object
~override NuGet.Protocol.NuGetVersionConverter.WriteJson(Newtonsoft.Json.JsonWriter writer, object value, Newtonsoft.Json.JsonSerializer serializer) -> void
~override NuGet.Protocol.ODataServiceDocumentResourceV2Provider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.PackageDependencyGroupConverter.CanConvert(System.Type objectType) -> bool
override NuGet.Protocol.PackageDependencyGroupConverter.CanWrite.get -> bool
~override NuGet.Protocol.PackageDependencyGroupConverter.ReadJson(Newtonsoft.Json.JsonReader reader, System.Type objectType, object existingValue, Newtonsoft.Json.JsonSerializer serializer) -> object
~override NuGet.Protocol.PackageDependencyGroupConverter.WriteJson(Newtonsoft.Json.JsonWriter writer, object value, Newtonsoft.Json.JsonSerializer serializer) -> void
~override NuGet.Protocol.PackageDetailsUriResourceV3Provider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.PackageMetadataResourceV2Feed.GetMetadataAsync(NuGet.Packaging.Core.PackageIdentity package, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.IPackageSearchMetadata>
~override NuGet.Protocol.PackageMetadataResourceV2Feed.GetMetadataAsync(string packageId, bool includePrerelease, bool includeUnlisted, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.IPackageSearchMetadata>>
~override NuGet.Protocol.PackageMetadataResourceV2FeedProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.PackageMetadataResourceV3.GetMetadataAsync(NuGet.Packaging.Core.PackageIdentity package, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.IPackageSearchMetadata>
~override NuGet.Protocol.PackageMetadataResourceV3.GetMetadataAsync(string packageId, bool includePrerelease, bool includeUnlisted, NuGet.Protocol.Core.Types.SourceCacheContext sourceCacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.IPackageSearchMetadata>>
~override NuGet.Protocol.PackageMetadataResourceV3Provider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.PackageSearchResourceV2Feed.SearchAsync(string searchTerm, NuGet.Protocol.Core.Types.SearchFilter filters, int skip, int take, NuGet.Common.ILogger log, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.IPackageSearchMetadata>>
~override NuGet.Protocol.PackageSearchResourceV2FeedProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.PackageSearchResourceV3.SearchAsync(string searchTerm, NuGet.Protocol.Core.Types.SearchFilter filter, int skip, int take, NuGet.Common.ILogger log, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.IPackageSearchMetadata>>
~override NuGet.Protocol.PackageSearchResourceV3Provider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.PackageUpdateResourceV2Provider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.PackageUpdateResourceV3Provider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.PluginFindPackageByIdResourceProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.Plugins.FallbackEmbeddedSignatureVerifier.IsValid(string filePath) -> bool
override NuGet.Protocol.Plugins.OutboundRequestContext<TResult>.HandleCancelResponse() -> void
~override NuGet.Protocol.Plugins.OutboundRequestContext<TResult>.HandleFault(NuGet.Protocol.Plugins.Message fault) -> void
~override NuGet.Protocol.Plugins.OutboundRequestContext<TResult>.HandleProgress(NuGet.Protocol.Plugins.Message progress) -> void
~override NuGet.Protocol.Plugins.OutboundRequestContext<TResult>.HandleResponse(NuGet.Protocol.Plugins.Message response) -> void
~override NuGet.Protocol.Plugins.PluginFile.ToString() -> string
~override NuGet.Protocol.Plugins.PluginPackageReader.CanVerifySignedPackages(NuGet.Packaging.Signing.SignedPackageVerifierSettings verifierSettings) -> bool
~override NuGet.Protocol.Plugins.PluginPackageReader.CopyFiles(string destination, System.Collections.Generic.IEnumerable<string> packageFiles, NuGet.Packaging.Core.ExtractPackageFileDelegate extractFile, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Collections.Generic.IEnumerable<string>
~override NuGet.Protocol.Plugins.PluginPackageReader.CopyFilesAsync(string destination, System.Collections.Generic.IEnumerable<string> packageFiles, NuGet.Packaging.Core.ExtractPackageFileDelegate extractFile, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<string>>
~override NuGet.Protocol.Plugins.PluginPackageReader.CopyNupkgAsync(string nupkgFilePath, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<string>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetArchiveHashAsync(NuGet.Common.HashAlgorithmName hashAlgorithm, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<byte[]>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetBuildItems() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetBuildItemsAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetContentHash(System.Threading.CancellationToken token, System.Func<string> GetUnsignedPackageHash = null) -> string
~override NuGet.Protocol.Plugins.PluginPackageReader.GetContentItems() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetContentItemsAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>>
override NuGet.Protocol.Plugins.PluginPackageReader.GetDevelopmentDependency() -> bool
~override NuGet.Protocol.Plugins.PluginPackageReader.GetDevelopmentDependencyAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetFiles() -> System.Collections.Generic.IEnumerable<string>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetFiles(string folder) -> System.Collections.Generic.IEnumerable<string>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetFilesAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<string>>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetFilesAsync(string folder, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<string>>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetFrameworkItems() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetFrameworkItemsAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetIdentity() -> NuGet.Packaging.Core.PackageIdentity
~override NuGet.Protocol.Plugins.PluginPackageReader.GetIdentityAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Packaging.Core.PackageIdentity>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetItems(string folderName) -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetItemsAsync(string folderName, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetLibItems() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetLibItemsAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetMinClientVersion() -> NuGet.Versioning.NuGetVersion
~override NuGet.Protocol.Plugins.PluginPackageReader.GetMinClientVersionAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Versioning.NuGetVersion>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetNuspec() -> System.IO.Stream
~override NuGet.Protocol.Plugins.PluginPackageReader.GetNuspecAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.IO.Stream>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetNuspecFile() -> string
~override NuGet.Protocol.Plugins.PluginPackageReader.GetNuspecFileAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<string>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetNuspecReaderAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Packaging.NuspecReader>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetPackageDependencies() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageDependencyGroup>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetPackageDependenciesAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageDependencyGroup>>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetPackageTypes() -> System.Collections.Generic.IReadOnlyList<NuGet.Packaging.Core.PackageType>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetPackageTypesAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<NuGet.Packaging.Core.PackageType>>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetPrimarySignatureAsync(System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Packaging.Signing.PrimarySignature>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetReferenceItems() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetReferenceItemsAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetStream(string path) -> System.IO.Stream
~override NuGet.Protocol.Plugins.PluginPackageReader.GetStreamAsync(string path, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.IO.Stream>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetSupportedFrameworks() -> System.Collections.Generic.IEnumerable<NuGet.Frameworks.NuGetFramework>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetSupportedFrameworksAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Frameworks.NuGetFramework>>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetToolItems() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
~override NuGet.Protocol.Plugins.PluginPackageReader.GetToolItemsAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>>
override NuGet.Protocol.Plugins.PluginPackageReader.IsServiceable() -> bool
~override NuGet.Protocol.Plugins.PluginPackageReader.IsServiceableAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>
~override NuGet.Protocol.Plugins.PluginPackageReader.IsSignedAsync(System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<bool>
~override NuGet.Protocol.Plugins.PluginPackageReader.NuspecReader.get -> NuGet.Packaging.NuspecReader
~override NuGet.Protocol.Plugins.PluginPackageReader.ValidateIntegrityAsync(NuGet.Packaging.Signing.SignatureContent signatureContent, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task
override NuGet.Protocol.Plugins.StandardInputReceiver.Connect() -> void
override NuGet.Protocol.Plugins.StandardOutputReceiver.Close() -> void
override NuGet.Protocol.Plugins.StandardOutputReceiver.Connect() -> void
~override NuGet.Protocol.Plugins.UnixAndMonoPlatformsEmbeddedSignatureVerifier.IsValid(string filePath) -> bool
~override NuGet.Protocol.Plugins.WindowsEmbeddedSignatureVerifier.IsValid(string filePath) -> bool
override NuGet.Protocol.Providers.VulnerabilityInfoResourceV3Provider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository! source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource?>!>!
~override NuGet.Protocol.ProxyAuthenticationHandler.SendAsync(System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Net.Http.HttpResponseMessage>
~override NuGet.Protocol.RawSearchResourceV3Provider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.RegistrationResourceV3Provider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.RemoteV2FindPackageByIdResource.CopyNupkgToStreamAsync(string id, NuGet.Versioning.NuGetVersion version, System.IO.Stream destination, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>
~override NuGet.Protocol.RemoteV2FindPackageByIdResource.DoesPackageExistAsync(string id, NuGet.Versioning.NuGetVersion version, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>
~override NuGet.Protocol.RemoteV2FindPackageByIdResource.GetAllVersionsAsync(string id, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Versioning.NuGetVersion>>
~override NuGet.Protocol.RemoteV2FindPackageByIdResource.GetDependencyInfoAsync(string id, NuGet.Versioning.NuGetVersion version, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo>
~override NuGet.Protocol.RemoteV2FindPackageByIdResource.GetPackageDownloaderAsync(NuGet.Packaging.Core.PackageIdentity packageIdentity, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Packaging.IPackageDownloader>
~override NuGet.Protocol.RemoteV2FindPackageByIdResourceProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository sourceRepository, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.RemoteV3FindPackageByIdResource.CopyNupkgToStreamAsync(string id, NuGet.Versioning.NuGetVersion version, System.IO.Stream destination, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>
~override NuGet.Protocol.RemoteV3FindPackageByIdResource.DoesPackageExistAsync(string id, NuGet.Versioning.NuGetVersion version, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>
~override NuGet.Protocol.RemoteV3FindPackageByIdResource.GetAllVersionsAsync(string id, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Versioning.NuGetVersion>>
~override NuGet.Protocol.RemoteV3FindPackageByIdResource.GetDependencyInfoAsync(string id, NuGet.Versioning.NuGetVersion version, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo>
~override NuGet.Protocol.RemoteV3FindPackageByIdResource.GetPackageDownloaderAsync(NuGet.Packaging.Core.PackageIdentity packageIdentity, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Packaging.IPackageDownloader>
~override NuGet.Protocol.RemoteV3FindPackageByIdResourceProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository sourceRepository, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.ReportAbuseResourceV3Provider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.RepositorySignatureResourceProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.SafeBoolConverter.CanConvert(System.Type objectType) -> bool
override NuGet.Protocol.SafeBoolConverter.CanRead.get -> bool
override NuGet.Protocol.SafeBoolConverter.CanWrite.get -> bool
~override NuGet.Protocol.SafeBoolConverter.ReadJson(Newtonsoft.Json.JsonReader reader, System.Type objectType, object existingValue, Newtonsoft.Json.JsonSerializer serializer) -> object
~override NuGet.Protocol.SafeBoolConverter.WriteJson(Newtonsoft.Json.JsonWriter writer, object value, Newtonsoft.Json.JsonSerializer serializer) -> void
~override NuGet.Protocol.SafeUriConverter.CanConvert(System.Type objectType) -> bool
override NuGet.Protocol.SafeUriConverter.CanRead.get -> bool
override NuGet.Protocol.SafeUriConverter.CanWrite.get -> bool
~override NuGet.Protocol.SafeUriConverter.ReadJson(Newtonsoft.Json.JsonReader reader, System.Type objectType, object existingValue, Newtonsoft.Json.JsonSerializer serializer) -> object
~override NuGet.Protocol.SafeUriConverter.WriteJson(Newtonsoft.Json.JsonWriter writer, object value, Newtonsoft.Json.JsonSerializer serializer) -> void
~override NuGet.Protocol.SemanticVersionConverter.CanConvert(System.Type objectType) -> bool
~override NuGet.Protocol.SemanticVersionConverter.ReadJson(Newtonsoft.Json.JsonReader reader, System.Type objectType, object existingValue, Newtonsoft.Json.JsonSerializer serializer) -> object
~override NuGet.Protocol.SemanticVersionConverter.WriteJson(Newtonsoft.Json.JsonWriter writer, object value, Newtonsoft.Json.JsonSerializer serializer) -> void
~override NuGet.Protocol.ServerWarningLogHandler.SendAsync(System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Net.Http.HttpResponseMessage>
~override NuGet.Protocol.ServiceIndexResourceV3Provider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.StsAuthenticationHandler.SendAsync(System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Net.Http.HttpResponseMessage>
~override NuGet.Protocol.SymbolPackageUpdateResourceV3Provider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.V2FeedListResource.ListAsync(string searchTerm, bool prerelease, bool allVersions, bool includeDelisted, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Common.IEnumerableAsync<NuGet.Protocol.Core.Types.IPackageSearchMetadata>>
~override NuGet.Protocol.V2FeedListResource.Source.get -> string
~override NuGet.Protocol.V2FeedListResourceProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.V3FeedListResourceProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository source, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Tuple<bool, NuGet.Protocol.Core.Types.INuGetResource>>
~override NuGet.Protocol.VersionInfoConverter.CanConvert(System.Type objectType) -> bool
override NuGet.Protocol.VersionInfoConverter.CanWrite.get -> bool
~override NuGet.Protocol.VersionInfoConverter.ReadJson(Newtonsoft.Json.JsonReader reader, System.Type objectType, object existingValue, Newtonsoft.Json.JsonSerializer serializer) -> object
~override NuGet.Protocol.VersionInfoConverter.WriteJson(Newtonsoft.Json.JsonWriter writer, object value, Newtonsoft.Json.JsonSerializer serializer) -> void
~override NuGet.Protocol.VersionRangeConverter.CanConvert(System.Type objectType) -> bool
~override NuGet.Protocol.VersionRangeConverter.ReadJson(Newtonsoft.Json.JsonReader reader, System.Type objectType, object existingValue, Newtonsoft.Json.JsonSerializer serializer) -> object
~override NuGet.Protocol.VersionRangeConverter.WriteJson(Newtonsoft.Json.JsonWriter writer, object value, Newtonsoft.Json.JsonSerializer serializer) -> void
~override NuGet.Repositories.LocalPackageInfo.ToString() -> string
~static NuGet.Protocol.CachingUtility.ComputeHash(string value, bool addIdentifiableCharacters = true) -> string
~static NuGet.Protocol.CachingUtility.IsFileAlreadyOpen(string filePath) -> bool
~static NuGet.Protocol.CachingUtility.ReadCacheFile(System.TimeSpan maxAge, string cacheFile) -> System.IO.Stream
~static NuGet.Protocol.CachingUtility.RemoveInvalidFileNameChars(string value) -> string
~static NuGet.Protocol.Core.Types.FindPackageByIdResource.GetDependencyInfo(NuGet.Packaging.NuspecReader reader) -> NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo
~static NuGet.Protocol.Core.Types.HttpSourceCacheContext.Create(NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, bool isFirstAttempt) -> NuGet.Protocol.Core.Types.HttpSourceCacheContext
~static NuGet.Protocol.Core.Types.HttpSourceCacheContext.Create(NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, int retryCount) -> NuGet.Protocol.Core.Types.HttpSourceCacheContext
static NuGet.Protocol.Core.Types.NuGetTestMode.Enabled.get -> bool
~static NuGet.Protocol.Core.Types.NuGetTestMode.InvokeTestFunctionAgainstTestMode<T>(System.Func<T> function, bool testModeEnabled) -> T
~static NuGet.Protocol.Core.Types.NullSourceCacheContext.Instance.get -> NuGet.Protocol.Core.Types.SourceCacheContext
~static NuGet.Protocol.Core.Types.OfflineFeedUtility.AddPackageToSource(NuGet.Protocol.Core.Types.OfflineFeedAddContext offlineFeedAddContext, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task
~static NuGet.Protocol.Core.Types.OfflineFeedUtility.GetPackageDirectory(NuGet.Packaging.Core.PackageIdentity packageIdentity, string offlineFeed) -> string
~static NuGet.Protocol.Core.Types.OfflineFeedUtility.PackageExists(NuGet.Packaging.Core.PackageIdentity packageIdentity, string offlineFeed, out bool isValidPackage) -> bool
~static NuGet.Protocol.Core.Types.OfflineFeedUtility.ThrowIfInvalid(string path) -> void
~static NuGet.Protocol.Core.Types.OfflineFeedUtility.ThrowIfInvalidOrNotFound(string path, bool isDirectory, string resourceString) -> void
~static NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.FromIdentity(NuGet.Packaging.Core.PackageIdentity identity) -> NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder
~static NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder.FromMetadata(NuGet.Protocol.Core.Types.IPackageSearchMetadata metadata) -> NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder
~static NuGet.Protocol.Core.Types.PackageSearchMetadataExtensions.WithVersions(this NuGet.Protocol.Core.Types.IPackageSearchMetadata metadata, System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.VersionInfo> versions) -> NuGet.Protocol.Core.Types.IPackageSearchMetadata
~static NuGet.Protocol.Core.Types.PackageSearchMetadataExtensions.WithVersions(this NuGet.Protocol.Core.Types.IPackageSearchMetadata metadata, System.Func<System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.VersionInfo>> valueFactory) -> NuGet.Protocol.Core.Types.IPackageSearchMetadata
~static NuGet.Protocol.Core.Types.PackageSearchMetadataExtensions.WithVersions(this NuGet.Protocol.Core.Types.IPackageSearchMetadata metadata, System.Func<System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.VersionInfo>>> asyncValueFactory) -> NuGet.Protocol.Core.Types.IPackageSearchMetadata
~static NuGet.Protocol.Core.Types.PackageUpdateResource.ForceDeleteDirectory(string path) -> void
~static NuGet.Protocol.Core.Types.Repository.CreateProvider(System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.INuGetResourceProvider> resourceProviders) -> NuGet.Protocol.Core.Types.ISourceRepositoryProvider
~static NuGet.Protocol.Core.Types.Repository.CreateProvider(System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.INuGetResourceProvider> resourceProviders, string rootPath) -> NuGet.Protocol.Core.Types.ISourceRepositoryProvider
~static NuGet.Protocol.Core.Types.Repository.CreateSource(System.Collections.Generic.IEnumerable<System.Lazy<NuGet.Protocol.Core.Types.INuGetResourceProvider>> resourceProviders, NuGet.Configuration.PackageSource source) -> NuGet.Protocol.Core.Types.SourceRepository
~static NuGet.Protocol.Core.Types.Repository.CreateSource(System.Collections.Generic.IEnumerable<System.Lazy<NuGet.Protocol.Core.Types.INuGetResourceProvider>> resourceProviders, NuGet.Configuration.PackageSource source, NuGet.Protocol.FeedType type) -> NuGet.Protocol.Core.Types.SourceRepository
~static NuGet.Protocol.Core.Types.Repository.CreateSource(System.Collections.Generic.IEnumerable<System.Lazy<NuGet.Protocol.Core.Types.INuGetResourceProvider>> resourceProviders, string sourceUrl) -> NuGet.Protocol.Core.Types.SourceRepository
~static NuGet.Protocol.Core.Types.Repository.CreateSource(System.Collections.Generic.IEnumerable<System.Lazy<NuGet.Protocol.Core.Types.INuGetResourceProvider>> resourceProviders, string sourceUrl, NuGet.Protocol.FeedType type) -> NuGet.Protocol.Core.Types.SourceRepository
~static NuGet.Protocol.Core.Types.Repository.Factory.get -> NuGet.Protocol.Core.Types.Repository.RepositoryFactory
~static NuGet.Protocol.Core.Types.Repository.Provider.get -> NuGet.Protocol.Core.Types.Repository.ProviderFactory
~static NuGet.Protocol.Core.Types.Repository.Provider.set -> void
~static NuGet.Protocol.Core.Types.UserAgent.SetUserAgent(System.Net.Http.HttpClient client) -> void
~static NuGet.Protocol.Core.Types.UserAgent.SetUserAgentString(NuGet.Protocol.Core.Types.UserAgentStringBuilder builder) -> void
~static NuGet.Protocol.Core.Types.UserAgent.UserAgentString.get -> string
static NuGet.Protocol.Events.ProtocolDiagnostics.HttpEvent -> NuGet.Protocol.Events.ProtocolDiagnostics.ProtocolDiagnosticHttpEventHandler
static NuGet.Protocol.Events.ProtocolDiagnostics.NupkgCopiedEvent -> NuGet.Protocol.Events.ProtocolDiagnostics.ProtocolDiagnosticsNupkgCopiedEventHandler
static NuGet.Protocol.Events.ProtocolDiagnostics.ResourceEvent -> NuGet.Protocol.Events.ProtocolDiagnostics.ProtocolDiagnosticResourceEventHandler
~static NuGet.Protocol.FactoryExtensionsV3.GetCoreV2(this NuGet.Protocol.Core.Types.Repository.RepositoryFactory factory, NuGet.Configuration.PackageSource source) -> NuGet.Protocol.Core.Types.SourceRepository
~static NuGet.Protocol.FactoryExtensionsV3.GetCoreV3(this NuGet.Protocol.Core.Types.Repository.ProviderFactory factory) -> System.Collections.Generic.IEnumerable<System.Lazy<NuGet.Protocol.Core.Types.INuGetResourceProvider>>
~static NuGet.Protocol.FactoryExtensionsV3.GetCoreV3(this NuGet.Protocol.Core.Types.Repository.RepositoryFactory factory, NuGet.Configuration.PackageSource source) -> NuGet.Protocol.Core.Types.SourceRepository
~static NuGet.Protocol.FactoryExtensionsV3.GetCoreV3(this NuGet.Protocol.Core.Types.Repository.RepositoryFactory factory, string source) -> NuGet.Protocol.Core.Types.SourceRepository
~static NuGet.Protocol.FactoryExtensionsV3.GetCoreV3(this NuGet.Protocol.Core.Types.Repository.RepositoryFactory factory, string source, NuGet.Protocol.FeedType type) -> NuGet.Protocol.Core.Types.SourceRepository
~static NuGet.Protocol.FeedTypeUtility.GetFeedType(NuGet.Configuration.PackageSource packageSource) -> NuGet.Protocol.FeedType
~static NuGet.Protocol.GetDownloadResultUtility.CleanUpDirectDownloads(NuGet.Protocol.Core.Types.PackageDownloadContext downloadContext) -> void
~static NuGet.Protocol.GetDownloadResultUtility.GetDownloadResultAsync(NuGet.Protocol.HttpSource client, NuGet.Packaging.Core.PackageIdentity identity, System.Uri uri, NuGet.Protocol.Core.Types.PackageDownloadContext downloadContext, string globalPackagesFolder, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.DownloadResourceResult>
~static NuGet.Protocol.GlobalPackagesFolderUtility.AddPackageAsync(string source, NuGet.Packaging.Core.PackageIdentity packageIdentity, System.IO.Stream packageStream, string globalPackagesFolder, System.Guid parentId, NuGet.Packaging.Signing.ClientPolicyContext clientPolicyContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Protocol.Core.Types.DownloadResourceResult>
~static NuGet.Protocol.GlobalPackagesFolderUtility.GetPackage(NuGet.Packaging.Core.PackageIdentity packageIdentity, string globalPackagesFolder) -> NuGet.Protocol.Core.Types.DownloadResourceResult
~static NuGet.Protocol.HttpCacheUtility.CreateCacheFileAsync(NuGet.Protocol.HttpCacheResult result, System.Net.Http.HttpResponseMessage response, System.Action<System.IO.Stream> ensureValidContents, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
~static NuGet.Protocol.HttpCacheUtility.InitializeHttpCacheResult(string httpCacheDirectory, System.Uri sourceUri, string cacheKey, NuGet.Protocol.Core.Types.HttpSourceCacheContext context) -> NuGet.Protocol.HttpCacheResult
~static NuGet.Protocol.HttpHandlerResourceV3.CredentialService.get -> System.Lazy<NuGet.Configuration.ICredentialService>
~static NuGet.Protocol.HttpHandlerResourceV3.CredentialService.set -> void
~static NuGet.Protocol.HttpHandlerResourceV3.CredentialsSuccessfullyUsed.get -> System.Action<System.Uri, System.Net.ICredentials>
~static NuGet.Protocol.HttpHandlerResourceV3.CredentialsSuccessfullyUsed.set -> void
~static NuGet.Protocol.HttpRequestMessageExtensions.GetOrCreateConfiguration(this System.Net.Http.HttpRequestMessage request) -> NuGet.Protocol.HttpRequestMessageConfiguration
~static NuGet.Protocol.HttpRequestMessageExtensions.SetConfiguration(this System.Net.Http.HttpRequestMessage request, NuGet.Protocol.HttpRequestMessageConfiguration configuration) -> void
~static NuGet.Protocol.HttpRequestMessageFactory.Create(System.Net.Http.HttpMethod method, System.Uri requestUri, NuGet.Common.ILogger log) -> System.Net.Http.HttpRequestMessage
~static NuGet.Protocol.HttpRequestMessageFactory.Create(System.Net.Http.HttpMethod method, System.Uri requestUri, NuGet.Protocol.HttpRequestMessageConfiguration configuration) -> System.Net.Http.HttpRequestMessage
~static NuGet.Protocol.HttpRequestMessageFactory.Create(System.Net.Http.HttpMethod method, string requestUri, NuGet.Common.ILogger log) -> System.Net.Http.HttpRequestMessage
~static NuGet.Protocol.HttpRequestMessageFactory.Create(System.Net.Http.HttpMethod method, string requestUri, NuGet.Protocol.HttpRequestMessageConfiguration configuration) -> System.Net.Http.HttpRequestMessage
~static NuGet.Protocol.HttpResponseMessageExtensions.LogServerWarning(this System.Net.Http.HttpResponseMessage response, NuGet.Common.ILogger log) -> void
~static NuGet.Protocol.HttpSource.Create(NuGet.Protocol.Core.Types.SourceRepository source) -> NuGet.Protocol.HttpSource
~static NuGet.Protocol.HttpSource.Create(NuGet.Protocol.Core.Types.SourceRepository source, NuGet.Protocol.IThrottle throttle) -> NuGet.Protocol.HttpSource
~static NuGet.Protocol.HttpSourceResourceProvider.Throttle.get -> NuGet.Protocol.IThrottle
~static NuGet.Protocol.HttpSourceResourceProvider.Throttle.set -> void
~static NuGet.Protocol.HttpStreamValidation.ValidateJObject(string uri, System.IO.Stream stream) -> void
~static NuGet.Protocol.HttpStreamValidation.ValidateNupkg(string uri, System.IO.Stream stream) -> void
~static NuGet.Protocol.HttpStreamValidation.ValidateXml(string uri, System.IO.Stream stream) -> void
~static NuGet.Protocol.JsonExtensions.FromJToken(this Newtonsoft.Json.Linq.JToken jtoken, System.Type type) -> object
~static NuGet.Protocol.JsonExtensions.FromJToken<T>(this Newtonsoft.Json.Linq.JToken jtoken) -> T
~static NuGet.Protocol.JsonExtensions.FromJson(this string json, System.Type type) -> object
~static NuGet.Protocol.JsonExtensions.FromJson<T>(this string json) -> T
~static NuGet.Protocol.JsonExtensions.FromJson<T>(this string json, Newtonsoft.Json.JsonSerializerSettings settings) -> T
~static NuGet.Protocol.JsonExtensions.GetBoolean(this Newtonsoft.Json.Linq.JObject json, string propertyName) -> bool?
~static NuGet.Protocol.JsonExtensions.GetJObjectProperty<T>(this Newtonsoft.Json.Linq.JObject jobject, string propertyName) -> T
~static NuGet.Protocol.JsonExtensions.ToJToken(this object obj) -> Newtonsoft.Json.Linq.JToken
~static NuGet.Protocol.JsonExtensions.ToJson(this object obj, Newtonsoft.Json.Formatting formatting = Newtonsoft.Json.Formatting.None) -> string
~static NuGet.Protocol.LocalFolderUtility.EnsurePackageFileExists(string packagePath, System.Collections.Generic.IEnumerable<string> matchingPackagePaths) -> void
~static NuGet.Protocol.LocalFolderUtility.GenerateNupkgMetadataFile(string nupkgPath, string installPath, string hashPath, string nupkgMetadataPath) -> void
~static NuGet.Protocol.LocalFolderUtility.GetAndVerifyRootDirectory(string root) -> System.IO.DirectoryInfo
~static NuGet.Protocol.LocalFolderUtility.GetDistinctPackages(System.Collections.Generic.IEnumerable<NuGet.Protocol.LocalPackageInfo> packages) -> System.Collections.Generic.IEnumerable<NuGet.Protocol.LocalPackageInfo>
~static NuGet.Protocol.LocalFolderUtility.GetIdentityFromNupkgPath(System.IO.FileInfo file, string id) -> NuGet.Packaging.Core.PackageIdentity
~static NuGet.Protocol.LocalFolderUtility.GetLocalFeedType(string root, NuGet.Common.ILogger log) -> NuGet.Protocol.FeedType
~static NuGet.Protocol.LocalFolderUtility.GetNupkgsFromFlatFolder(string root, NuGet.Common.ILogger log) -> System.Collections.Generic.IEnumerable<System.IO.FileInfo>
~static NuGet.Protocol.LocalFolderUtility.GetNupkgsFromFlatFolder(string root, NuGet.Common.ILogger log, System.Threading.CancellationToken cancellationToken) -> System.Collections.Generic.IEnumerable<System.IO.FileInfo>
~static NuGet.Protocol.LocalFolderUtility.GetNupkgsFromFlatFolder(string root, string id, NuGet.Common.ILogger log) -> System.Collections.Generic.IEnumerable<System.IO.FileInfo>
~static NuGet.Protocol.LocalFolderUtility.GetNupkgsFromFlatFolder(string root, string id, NuGet.Common.ILogger log, System.Threading.CancellationToken cancellationToken) -> System.Collections.Generic.IEnumerable<System.IO.FileInfo>
~static NuGet.Protocol.LocalFolderUtility.GetPackage(System.Uri path, NuGet.Common.ILogger log) -> NuGet.Protocol.LocalPackageInfo
~static NuGet.Protocol.LocalFolderUtility.GetPackageV2(string root, NuGet.Packaging.Core.PackageIdentity identity, NuGet.Common.ILogger log) -> NuGet.Protocol.LocalPackageInfo
~static NuGet.Protocol.LocalFolderUtility.GetPackageV2(string root, NuGet.Packaging.Core.PackageIdentity identity, NuGet.Common.ILogger log, System.Threading.CancellationToken cancellationToken) -> NuGet.Protocol.LocalPackageInfo
~static NuGet.Protocol.LocalFolderUtility.GetPackageV2(string root, string id, NuGet.Versioning.NuGetVersion version, NuGet.Common.ILogger log) -> NuGet.Protocol.LocalPackageInfo
~static NuGet.Protocol.LocalFolderUtility.GetPackageV2(string root, string id, NuGet.Versioning.NuGetVersion version, NuGet.Common.ILogger log, System.Threading.CancellationToken cancellationToken) -> NuGet.Protocol.LocalPackageInfo
~static NuGet.Protocol.LocalFolderUtility.GetPackageV3(string root, NuGet.Packaging.Core.PackageIdentity identity, NuGet.Common.ILogger log) -> NuGet.Protocol.LocalPackageInfo
~static NuGet.Protocol.LocalFolderUtility.GetPackageV3(string root, string id, NuGet.Versioning.NuGetVersion version, NuGet.Common.ILogger log) -> NuGet.Protocol.LocalPackageInfo
~static NuGet.Protocol.LocalFolderUtility.GetPackagesConfigFolderPackage(string root, NuGet.Packaging.Core.PackageIdentity identity, NuGet.Common.ILogger log) -> NuGet.Protocol.LocalPackageInfo
~static NuGet.Protocol.LocalFolderUtility.GetPackagesConfigFolderPackage(string root, string id, NuGet.Versioning.NuGetVersion version, NuGet.Common.ILogger log) -> NuGet.Protocol.LocalPackageInfo
~static NuGet.Protocol.LocalFolderUtility.GetPackagesConfigFolderPackages(string root, NuGet.Common.ILogger log) -> System.Collections.Generic.IEnumerable<NuGet.Protocol.LocalPackageInfo>
~static NuGet.Protocol.LocalFolderUtility.GetPackagesConfigFolderPackages(string root, NuGet.Common.ILogger log, System.Threading.CancellationToken cancellationToken) -> System.Collections.Generic.IEnumerable<NuGet.Protocol.LocalPackageInfo>
~static NuGet.Protocol.LocalFolderUtility.GetPackagesConfigFolderPackages(string root, string id, NuGet.Common.ILogger log) -> System.Collections.Generic.IEnumerable<NuGet.Protocol.LocalPackageInfo>
~static NuGet.Protocol.LocalFolderUtility.GetPackagesV2(string root, NuGet.Common.ILogger log) -> System.Collections.Generic.IEnumerable<NuGet.Protocol.LocalPackageInfo>
~static NuGet.Protocol.LocalFolderUtility.GetPackagesV2(string root, NuGet.Common.ILogger log, System.Threading.CancellationToken cancellationToken) -> System.Collections.Generic.IEnumerable<NuGet.Protocol.LocalPackageInfo>
~static NuGet.Protocol.LocalFolderUtility.GetPackagesV2(string root, string id, NuGet.Common.ILogger log) -> System.Collections.Generic.IEnumerable<NuGet.Protocol.LocalPackageInfo>
~static NuGet.Protocol.LocalFolderUtility.GetPackagesV2(string root, string id, NuGet.Common.ILogger log, System.Threading.CancellationToken cancellationToken) -> System.Collections.Generic.IEnumerable<NuGet.Protocol.LocalPackageInfo>
~static NuGet.Protocol.LocalFolderUtility.GetPackagesV3(string root, NuGet.Common.ILogger log) -> System.Collections.Generic.IEnumerable<NuGet.Protocol.LocalPackageInfo>
~static NuGet.Protocol.LocalFolderUtility.GetPackagesV3(string root, NuGet.Common.ILogger log, System.Threading.CancellationToken cancellationToken) -> System.Collections.Generic.IEnumerable<NuGet.Protocol.LocalPackageInfo>
~static NuGet.Protocol.LocalFolderUtility.GetPackagesV3(string root, string id, NuGet.Common.ILogger log) -> System.Collections.Generic.IEnumerable<NuGet.Protocol.LocalPackageInfo>
~static NuGet.Protocol.LocalFolderUtility.GetPackagesV3(string root, string id, NuGet.Common.ILogger log, System.Threading.CancellationToken cancellationToken) -> System.Collections.Generic.IEnumerable<NuGet.Protocol.LocalPackageInfo>
~static NuGet.Protocol.LocalFolderUtility.GetVersionFromFileName(string fileName, string id, string extension) -> NuGet.Versioning.NuGetVersion
~static NuGet.Protocol.LocalFolderUtility.IsPossiblePackageMatch(System.IO.FileInfo file, NuGet.Packaging.Core.PackageIdentity identity) -> bool
~static NuGet.Protocol.LocalFolderUtility.IsPossiblePackageMatch(System.IO.FileInfo file, string id) -> bool
~static NuGet.Protocol.LocalFolderUtility.ResolvePackageFromPath(string packagePath, bool isSnupkg = false) -> System.Collections.Generic.IEnumerable<string>
~static NuGet.Protocol.NullThrottle.Instance.get -> NuGet.Protocol.NullThrottle
~static NuGet.Protocol.PackageDetailsUriResourceV3.CreateOrNull(string uriTemplate) -> NuGet.Protocol.PackageDetailsUriResourceV3
~static NuGet.Protocol.Plugins.AutomaticProgressReporter.Create(NuGet.Protocol.Plugins.IConnection connection, NuGet.Protocol.Plugins.Message request, System.TimeSpan interval, System.Threading.CancellationToken cancellationToken) -> NuGet.Protocol.Plugins.AutomaticProgressReporter
~static NuGet.Protocol.Plugins.ConnectionOptions.CreateDefault(NuGet.Common.IEnvironmentVariableReader reader = null) -> NuGet.Protocol.Plugins.ConnectionOptions
~static NuGet.Protocol.Plugins.EmbeddedSignatureVerifier.Create() -> NuGet.Protocol.Plugins.EmbeddedSignatureVerifier
~static NuGet.Protocol.Plugins.JsonSerializationUtilities.Deserialize<T>(string json) -> T
~static NuGet.Protocol.Plugins.JsonSerializationUtilities.FromObject(object value) -> Newtonsoft.Json.Linq.JObject
~static NuGet.Protocol.Plugins.JsonSerializationUtilities.Serialize(Newtonsoft.Json.JsonWriter writer, object value) -> void
~static NuGet.Protocol.Plugins.JsonSerializationUtilities.Serializer.get -> Newtonsoft.Json.JsonSerializer
~static NuGet.Protocol.Plugins.JsonSerializationUtilities.ToObject<T>(Newtonsoft.Json.Linq.JObject jObject) -> T
~static NuGet.Protocol.Plugins.LogRequestHandler.GetLogLevel(NuGet.Common.ILogger logger) -> NuGet.Common.LogLevel
~static NuGet.Protocol.Plugins.MessageUtilities.Create(string requestId, NuGet.Protocol.Plugins.MessageType type, NuGet.Protocol.Plugins.MessageMethod method) -> NuGet.Protocol.Plugins.Message
~static NuGet.Protocol.Plugins.MessageUtilities.Create<TPayload>(string requestId, NuGet.Protocol.Plugins.MessageType type, NuGet.Protocol.Plugins.MessageMethod method, TPayload payload) -> NuGet.Protocol.Plugins.Message
~static NuGet.Protocol.Plugins.MessageUtilities.DeserializePayload<TPayload>(NuGet.Protocol.Plugins.Message message) -> TPayload
~static NuGet.Protocol.Plugins.PluginDiscoveryUtility.GetConventionBasedPlugins(System.Collections.Generic.IEnumerable<string> directories) -> System.Collections.Generic.IEnumerable<string>
~static NuGet.Protocol.Plugins.PluginDiscoveryUtility.GetInternalPluginRelativeToMSBuildDirectory(string msbuildDirectoryPath) -> string
~static NuGet.Protocol.Plugins.PluginDiscoveryUtility.GetInternalPlugins() -> string
~static NuGet.Protocol.Plugins.PluginDiscoveryUtility.GetNuGetHomePluginsPath() -> string
~static NuGet.Protocol.Plugins.PluginDiscoveryUtility.GetNuGetPluginsDirectoryRelativeToNuGetAssembly(string nugetAssemblyPath) -> string
~static NuGet.Protocol.Plugins.PluginDiscoveryUtility.InternalPluginDiscoveryRoot.get -> System.Lazy<string>
~static NuGet.Protocol.Plugins.PluginDiscoveryUtility.InternalPluginDiscoveryRoot.set -> void
~static NuGet.Protocol.Plugins.PluginFactory.CreateFromCurrentProcessAsync(NuGet.Protocol.Plugins.IRequestHandlers requestHandlers, NuGet.Protocol.Plugins.ConnectionOptions options, System.Threading.CancellationToken sessionCancellationToken) -> System.Threading.Tasks.Task<NuGet.Protocol.Plugins.IPlugin>
~static NuGet.Protocol.Plugins.PluginManager.Instance.get -> NuGet.Protocol.Plugins.IPluginManager
~static NuGet.Protocol.Plugins.TimeoutUtilities.GetTimeout(string timeoutInSeconds, System.TimeSpan fallbackTimeout) -> System.TimeSpan
static NuGet.Protocol.Plugins.TimeoutUtilities.IsValid(System.TimeSpan timeout) -> bool
~static NuGet.Protocol.RegistrationUtility.CreateVersionRange(string stringToParse) -> NuGet.Versioning.VersionRange
~static NuGet.Protocol.RegistrationUtility.LoadRanges(NuGet.Protocol.HttpSource httpSource, System.Uri registrationUri, string packageId, NuGet.Versioning.VersionRange range, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<Newtonsoft.Json.Linq.JObject>>
~static NuGet.Protocol.SemaphoreSlimThrottle.CreateBinarySemaphore() -> NuGet.Protocol.SemaphoreSlimThrottle
~static NuGet.Protocol.SemaphoreSlimThrottle.CreateSemaphoreThrottle(int initialCount) -> NuGet.Protocol.SemaphoreSlimThrottle
~static NuGet.Protocol.StreamExtensions.CopyToAsync(this System.IO.Stream stream, System.IO.Stream destination, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task
~static NuGet.Protocol.TimeoutUtility.StartWithTimeout(System.Func<System.Threading.CancellationToken, System.Threading.Tasks.Task> getTask, System.TimeSpan timeout, string timeoutMessage, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task
~static NuGet.Protocol.TimeoutUtility.StartWithTimeout<T>(System.Func<System.Threading.CancellationToken, System.Threading.Tasks.Task<T>> getTask, System.TimeSpan timeout, string timeoutMessage, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<T>
~static NuGet.Protocol.TokenStore.Instance.get -> NuGet.Protocol.TokenStore
~static NuGet.Protocol.V2FeedUtilities.CreatePackageSearchResult(NuGet.Protocol.V2FeedPackageInfo package, NuGet.Protocol.MetadataReferenceCache metadataCache, NuGet.Protocol.Core.Types.SearchFilter filter, NuGet.Protocol.V2FeedParser feedParser, NuGet.Common.ILogger log, System.Threading.CancellationToken cancellationToken) -> NuGet.Protocol.Core.Types.IPackageSearchMetadata
~static NuGet.Protocol.VisualStudio.FactoryExtensionsVS.GetVisualStudio(this NuGet.Protocol.Core.Types.Repository.ProviderFactory factory) -> System.Collections.Generic.IEnumerable<System.Lazy<NuGet.Protocol.Core.Types.INuGetResourceProvider>>
~static NuGet.Protocol.VisualStudio.FactoryExtensionsVS.GetVisualStudio(this NuGet.Protocol.Core.Types.Repository.RepositoryFactory factory, NuGet.Configuration.PackageSource source) -> NuGet.Protocol.Core.Types.SourceRepository
~static NuGet.Protocol.VisualStudio.FactoryExtensionsVS.GetVisualStudio(this NuGet.Protocol.Core.Types.Repository.RepositoryFactory factory, string source) -> NuGet.Protocol.Core.Types.SourceRepository
~static NuGet.Repositories.NuGetv3LocalRepositoryUtility.GetPackage(System.Collections.Generic.IReadOnlyList<NuGet.Repositories.NuGetv3LocalRepository> repositories, string id, NuGet.Versioning.NuGetVersion version) -> NuGet.Repositories.LocalPackageSourceInfo
~static readonly NuGet.Protocol.Core.Types.UserAgentStringBuilder.DefaultNuGetClientName -> string
~static readonly NuGet.Protocol.HttpRequestMessageConfiguration.Default -> NuGet.Protocol.HttpRequestMessageConfiguration
static readonly NuGet.Protocol.HttpRetryHandlerRequest.DefaultDownloadTimeout -> System.TimeSpan
static readonly NuGet.Protocol.HttpRetryHandlerRequest.DefaultMaxTries -> int
static readonly NuGet.Protocol.HttpSourceAuthenticationHandler.MaxAuthRetries -> int
static readonly NuGet.Protocol.HttpSourceRequest.DefaultRequestTimeout -> System.TimeSpan
~static readonly NuGet.Protocol.JsonExtensions.ObjectSerializationSettings -> Newtonsoft.Json.JsonSerializerSettings
static readonly NuGet.Protocol.Plugins.PluginConstants.CloseTimeout -> System.TimeSpan
static readonly NuGet.Protocol.Plugins.PluginConstants.IdleTimeout -> System.TimeSpan
~static readonly NuGet.Protocol.Plugins.PluginConstants.PluginArguments -> System.Collections.Generic.IEnumerable<string>
static readonly NuGet.Protocol.Plugins.PluginConstants.ProgressInterval -> System.TimeSpan
static readonly NuGet.Protocol.Plugins.PluginConstants.RequestTimeout -> System.TimeSpan
~static readonly NuGet.Protocol.Plugins.ProtocolConstants.CurrentVersion -> NuGet.Versioning.SemanticVersion
static readonly NuGet.Protocol.Plugins.ProtocolConstants.HandshakeTimeout -> System.TimeSpan
static readonly NuGet.Protocol.Plugins.ProtocolConstants.MaxTimeout -> System.TimeSpan
static readonly NuGet.Protocol.Plugins.ProtocolConstants.MinTimeout -> System.TimeSpan
static readonly NuGet.Protocol.Plugins.ProtocolConstants.RequestTimeout -> System.TimeSpan
~static readonly NuGet.Protocol.Plugins.ProtocolConstants.Version100 -> NuGet.Versioning.SemanticVersion
~static readonly NuGet.Protocol.ProtocolConstants.ApiKeyHeader -> string
~static readonly NuGet.Protocol.ProtocolConstants.ServerWarningHeader -> string
~static readonly NuGet.Protocol.ProtocolConstants.SessionId -> string
static readonly NuGet.Protocol.ProxyAuthenticationHandler.MaxAuthRetries -> int
~static readonly NuGet.Protocol.ServiceTypes.LegacyGallery -> string[]
~static readonly NuGet.Protocol.ServiceTypes.PackageBaseAddress -> string[]
~static readonly NuGet.Protocol.ServiceTypes.PackageDetailsUriTemplate -> string[]
~static readonly NuGet.Protocol.ServiceTypes.PackagePublish -> string[]
~static readonly NuGet.Protocol.ServiceTypes.RegistrationsBaseUrl -> string[]
~static readonly NuGet.Protocol.ServiceTypes.ReportAbuse -> string[]
~static readonly NuGet.Protocol.ServiceTypes.RepositorySignatures -> string[]
~static readonly NuGet.Protocol.ServiceTypes.SearchAutocompleteService -> string[]
~static readonly NuGet.Protocol.ServiceTypes.SearchQueryService -> string[]
~static readonly NuGet.Protocol.ServiceTypes.SymbolPackagePublish -> string[]
~static readonly NuGet.Protocol.ServiceTypes.Version200 -> string
~static readonly NuGet.Protocol.ServiceTypes.Version300 -> string
~static readonly NuGet.Protocol.ServiceTypes.Version300beta -> string
~static readonly NuGet.Protocol.ServiceTypes.Version300rc -> string
~static readonly NuGet.Protocol.ServiceTypes.Version340 -> string
~static readonly NuGet.Protocol.ServiceTypes.Version360 -> string
~static readonly NuGet.Protocol.ServiceTypes.Version470 -> string
~static readonly NuGet.Protocol.ServiceTypes.Version490 -> string
~static readonly NuGet.Protocol.ServiceTypes.Version500 -> string
~static readonly NuGet.Protocol.ServiceTypes.Version510 -> string
~static readonly NuGet.Protocol.ServiceTypes.Versioned -> string
static readonly NuGet.Protocol.StreamExtensions.BufferSize -> int
~virtual NuGet.Protocol.Core.Types.DependencyInfoResource.ResolvePackages(string packageId, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo>>
~virtual NuGet.Protocol.Core.Types.Repository.ProviderFactory.GetCoreV3() -> System.Collections.Generic.IEnumerable<System.Lazy<NuGet.Protocol.Core.Types.INuGetResourceProvider>>
virtual NuGet.Protocol.Core.Types.ResourceProvider.After.get -> System.Collections.Generic.IEnumerable<string!>!
virtual NuGet.Protocol.Core.Types.ResourceProvider.Before.get -> System.Collections.Generic.IEnumerable<string!>!
virtual NuGet.Protocol.Core.Types.ResourceProvider.Name.get -> string!
virtual NuGet.Protocol.Core.Types.ResourceProvider.ResourceType.get -> System.Type!
~virtual NuGet.Protocol.Core.Types.SourceCacheContext.Clone() -> NuGet.Protocol.Core.Types.SourceCacheContext
virtual NuGet.Protocol.Core.Types.SourceCacheContext.Dispose(bool disposing) -> void
~virtual NuGet.Protocol.Core.Types.SourceCacheContext.GeneratedTempFolder.get -> string
~virtual NuGet.Protocol.Core.Types.SourceCacheContext.GeneratedTempFolder.set -> void
~virtual NuGet.Protocol.Core.Types.SourceCacheContext.WithRefreshCacheTrue() -> NuGet.Protocol.Core.Types.SourceCacheContext
~virtual NuGet.Protocol.Core.Types.SourceRepository.GetFeedType(System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Protocol.FeedType>
~virtual NuGet.Protocol.Core.Types.SourceRepository.GetResource<T>() -> T
~virtual NuGet.Protocol.Core.Types.SourceRepository.GetResource<T>(System.Threading.CancellationToken token) -> T
~virtual NuGet.Protocol.Core.Types.SourceRepository.GetResourceAsync<T>() -> System.Threading.Tasks.Task<T>
~virtual NuGet.Protocol.Core.Types.SourceRepository.GetResourceAsync<T>(System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<T>
~virtual NuGet.Protocol.Core.Types.SourceRepository.PackageSource.get -> NuGet.Configuration.PackageSource
~virtual NuGet.Protocol.FindLocalPackagesResource.Exists(NuGet.Packaging.Core.PackageIdentity identity, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> bool
~virtual NuGet.Protocol.FindLocalPackagesResource.Exists(string packageId, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> bool
virtual NuGet.Protocol.HttpSource.Dispose(bool disposing) -> void
~virtual NuGet.Protocol.HttpSource.GetAsync<T>(NuGet.Protocol.HttpSourceCachedRequest request, System.Func<NuGet.Protocol.HttpSourceResult, System.Threading.Tasks.Task<T>> processAsync, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<T>
~virtual NuGet.Protocol.HttpSource.TryReadCacheFile(string uri, System.TimeSpan maxAge, string cacheFile) -> System.IO.Stream
virtual NuGet.Protocol.HttpSourceResult.Dispose(bool disposing) -> void
~virtual NuGet.Protocol.LocalPackageFileCache.GetOrAddFiles(string expandedPath) -> System.Lazy<System.Collections.Generic.IReadOnlyList<string>>
~virtual NuGet.Protocol.LocalPackageFileCache.GetOrAddNuspec(string manifestPath, string expandedPath) -> System.Lazy<NuGet.Packaging.NuspecReader>
~virtual NuGet.Protocol.LocalPackageFileCache.GetOrAddRuntimeGraph(string expandedPath) -> System.Lazy<NuGet.RuntimeModel.RuntimeGraph>
~virtual NuGet.Protocol.LocalPackageFileCache.GetOrAddSha512(string sha512Path) -> System.Lazy<string>
~virtual NuGet.Protocol.LocalPackageFileCache.Sha512Exists(string sha512Path) -> bool
~virtual NuGet.Protocol.LocalPackageInfo.GetReader() -> NuGet.Packaging.PackageReaderBase
~virtual NuGet.Protocol.LocalPackageInfo.Identity.get -> NuGet.Packaging.Core.PackageIdentity
virtual NuGet.Protocol.LocalPackageInfo.IsNupkg.get -> bool
virtual NuGet.Protocol.LocalPackageInfo.LastWriteTimeUtc.get -> System.DateTime
~virtual NuGet.Protocol.LocalPackageInfo.Nuspec.get -> NuGet.Packaging.NuspecReader
~virtual NuGet.Protocol.LocalPackageInfo.Path.get -> string
virtual NuGet.Protocol.ODataServiceDocumentResourceV2.RequestTime.get -> System.DateTime
virtual NuGet.Protocol.Plugins.Receiver.Close() -> void
~virtual NuGet.Protocol.RawSearchResourceV3.Search(string searchTerm, NuGet.Protocol.Core.Types.SearchFilter filters, int skip, int take, NuGet.Common.ILogger log, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<Newtonsoft.Json.Linq.JObject>>
~virtual NuGet.Protocol.RawSearchResourceV3.SearchPage(string searchTerm, NuGet.Protocol.Core.Types.SearchFilter filters, int skip, int take, NuGet.Common.ILogger log, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<Newtonsoft.Json.Linq.JObject>
~virtual NuGet.Protocol.RegistrationResourceV3.GetPackageEntries(string packageId, bool includeUnlisted, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<Newtonsoft.Json.Linq.JObject>>
~virtual NuGet.Protocol.RegistrationResourceV3.GetPackageMetadata(NuGet.Packaging.Core.PackageIdentity identity, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<Newtonsoft.Json.Linq.JObject>
~virtual NuGet.Protocol.RegistrationResourceV3.GetPackageMetadata(string packageId, NuGet.Versioning.VersionRange range, bool includePrerelease, bool includeUnlisted, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<Newtonsoft.Json.Linq.JObject>>
~virtual NuGet.Protocol.RegistrationResourceV3.GetPackageMetadata(string packageId, bool includePrerelease, bool includeUnlisted, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger log, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<Newtonsoft.Json.Linq.JObject>>
~virtual NuGet.Protocol.RegistrationResourceV3.GetUri(NuGet.Packaging.Core.PackageIdentity package) -> System.Uri
~virtual NuGet.Protocol.RegistrationResourceV3.GetUri(string id, NuGet.Versioning.NuGetVersion version) -> System.Uri
~virtual NuGet.Protocol.RegistrationResourceV3.GetUri(string packageId) -> System.Uri
~virtual NuGet.Protocol.ServiceIndexResourceV3.Entries.get -> System.Collections.Generic.IReadOnlyList<NuGet.Protocol.ServiceIndexEntry>
~virtual NuGet.Protocol.ServiceIndexResourceV3.GetServiceEntries(NuGet.Versioning.NuGetVersion clientVersion, params string[] orderedTypes) -> System.Collections.Generic.IReadOnlyList<NuGet.Protocol.ServiceIndexEntry>
~virtual NuGet.Protocol.ServiceIndexResourceV3.GetServiceEntries(params string[] orderedTypes) -> System.Collections.Generic.IReadOnlyList<NuGet.Protocol.ServiceIndexEntry>
~virtual NuGet.Protocol.ServiceIndexResourceV3.GetServiceEntryUri(params string[] orderedTypes) -> System.Uri
~virtual NuGet.Protocol.ServiceIndexResourceV3.GetServiceEntryUris(NuGet.Versioning.NuGetVersion clientVersion, params string[] orderedTypes) -> System.Collections.Generic.IReadOnlyList<System.Uri>
~virtual NuGet.Protocol.ServiceIndexResourceV3.GetServiceEntryUris(params string[] orderedTypes) -> System.Collections.Generic.IReadOnlyList<System.Uri>
~virtual NuGet.Protocol.ServiceIndexResourceV3.Json.get -> string
virtual NuGet.Protocol.ServiceIndexResourceV3.RequestTime.get -> System.DateTime
