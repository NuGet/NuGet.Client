// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

#nullable enable

using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Newtonsoft.Json;
using NuGet.Common;
using NuGet.Protocol.Core.Types;
using NuGet.Protocol.Model;

namespace NuGet.Protocol.Resources
{
    internal class VulnerabilityInfoResourceV3 : IVulnerabilityInfoResource
    {
        private readonly SourceRepository _sourceRepository;

        internal VulnerabilityInfoResourceV3(SourceRepository sourceRepository)
        {
            _sourceRepository = sourceRepository ?? throw new ArgumentNullException(nameof(sourceRepository));
        }

        internal async Task<IReadOnlyList<V3VulnerabilityIndexEntry>> GetVulnerabilityFilesAsync(SourceCacheContext cacheContext, ILogger log, CancellationToken cancellationToken)
        {
            Uri vulnerabilityIndexUrl = await GetIndexUrlAsync(cancellationToken);
            HttpSourceResource httpSourceResource = await _sourceRepository.GetResourceAsync<HttpSourceResource>(cancellationToken);

            HttpSourceCacheContext httpSourceCacheContext = HttpSourceCacheContext.Create(cacheContext, isFirstAttempt: true);
            var request = new HttpSourceCachedRequest(vulnerabilityIndexUrl.OriginalString, "vuln_index", httpSourceCacheContext);
            IReadOnlyList<V3VulnerabilityIndexEntry>? vulnFiles = await httpSourceResource.HttpSource.GetAsync(request,
                result =>
            {
                using (var textReader = new StreamReader(result.Stream))
                using (var jsonReader = new JsonTextReader(textReader))
                {
                    var parsed = JsonExtensions.JsonObjectSerializer.Deserialize<IReadOnlyList<V3VulnerabilityIndexEntry>>(jsonReader);
                    return Task.FromResult(parsed);
                }
            },
                log,
                cancellationToken);

            if (vulnFiles == null)
            {
                string message = string.Format("Package source '{0}' vulnerability data index '{1}' did not successfully deserialize. This indicates a problem with the JSON file contents returned from the server.",
                    _sourceRepository.PackageSource.Name,
                    vulnerabilityIndexUrl.OriginalString);
                throw new FatalProtocolException(message);
            }

            return vulnFiles;

            async Task<Uri> GetIndexUrlAsync(CancellationToken cancellationToken)
            {
                ServiceIndexResourceV3 serviceIndex = await _sourceRepository.GetResourceAsync<ServiceIndexResourceV3>(cancellationToken);
                return serviceIndex.GetServiceEntryUri(ServiceTypes.VulnerabilityInfo);
            }
        }

        internal async Task<IReadOnlyDictionary<string, IReadOnlyList<VulnerabilityInfo>>> GetVulnerabilityDataAsync(
            Uri uri,
            string name,
            SourceCacheContext cacheContext,
            ILogger logger,
            CancellationToken cancellationToken)
        {
            HttpSourceResource httpSourceResource = await _sourceRepository.GetResourceAsync<HttpSourceResource>(cancellationToken);

            HttpSourceCacheContext httpSourceCacheContext = HttpSourceCacheContext.Create(cacheContext, isFirstAttempt: true);
            var request = new HttpSourceCachedRequest(uri.OriginalString, "vuln_data_" + name, httpSourceCacheContext);
            IReadOnlyDictionary<string, IReadOnlyList<VulnerabilityInfo>>? data = await httpSourceResource.HttpSource.GetAsync(request,
                result =>
                {
                    using (var textReader = new StreamReader(result.Stream))
                    using (var jsonReader = new JsonTextReader(textReader))
                    {
                        var parsed = JsonExtensions.JsonObjectSerializer.Deserialize<IReadOnlyDictionary<string, IReadOnlyList<VulnerabilityInfo>>>(jsonReader);
                        return Task.FromResult(parsed);
                    }
                },
                logger,
                cancellationToken);

            if (data == null)
            {
                string message = "Package source '{0}' vulnerability data file '{1}' ({2}) did not successfully deserialize. This indicates a problem with the JSON file contents returned from the server.";
                throw new FatalProtocolException(message);
            }

            return data;
        }

        public async Task<GetVulnerabilityInfoResult> GetVulnerabilityInfoAsync(SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken)
        {
            List<Exception>? exceptions = null;
            List<IReadOnlyDictionary<string, IReadOnlyList<VulnerabilityInfo>>>? knownVulnerabilities = null;

            try
            {
                IReadOnlyList<V3VulnerabilityIndexEntry> indexEntries = await GetVulnerabilityFilesAsync(cacheContext, logger, cancellationToken);

                if (indexEntries.Count == 0)
                {
                    knownVulnerabilities = new();
                    return new GetVulnerabilityInfoResult(knownVulnerabilities, exceptions);
                }

                var tasks = new Task<IReadOnlyDictionary<string, IReadOnlyList<VulnerabilityInfo>>>[indexEntries.Count];
                for (int i = 0; i < tasks.Length; i++)
                {
                    V3VulnerabilityIndexEntry indexEntry = indexEntries[i];
                    tasks[i] = GetVulnerabilityDataAsync(indexEntry, cacheContext, logger, cancellationToken);
                }

                await Task.WhenAll(tasks);

                for (int i = 0; i < tasks.Length; i++)
                {
                    try
                    {
                        IReadOnlyDictionary<string, IReadOnlyList<VulnerabilityInfo>>? data = await tasks[i];
                        if (data != null)
                        {
                            if (knownVulnerabilities == null)
                            {
                                knownVulnerabilities = new(indexEntries.Count);
                            }
                            knownVulnerabilities.Add(data);
                        }
                    }
                    catch (Exception ex)
                    {
                        AddException(ref exceptions, ex);
                    }
                }
            }
            catch (Exception ex)
            {
                AddException(ref exceptions, ex);
            }

            GetVulnerabilityInfoResult result = new(knownVulnerabilities, exceptions);
            return result;

            static void AddException(ref List<Exception>? exceptions, Exception ex)
            {
                if (exceptions == null)
                {
                    exceptions = new();
                }
                exceptions.Add(ex);
            }
        }

        private Task<IReadOnlyDictionary<string, IReadOnlyList<VulnerabilityInfo>>> GetVulnerabilityDataAsync(
            V3VulnerabilityIndexEntry indexEntry,
            SourceCacheContext cacheContext,
            ILogger logger,
            CancellationToken cancellationToken)
        {
            return GetVulnerabilityDataAsync(new Uri(indexEntry.Url), indexEntry.Name, cacheContext, logger, cancellationToken);
        }
    }
}
