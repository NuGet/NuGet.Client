<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#+
    string InitCaps(string input)
    {
        return StringUtilities.InitCaps(input);
    }

    bool IsArgument(string type)
    {
        return type == "Argument";
    }

    bool IsOption(string type)
    {
        return type == "Option";
    }

    bool IsArgumentOrOption(string type)
    {
        return IsArgument(type) || IsOption(type);
    }

    string GetClrType(XElement option)
    {
        return StringUtilities.GetClrType(option);
    }

    string GetProperty(XElement element)
    {
        switch (element.Name.LocalName)
        {
            case "SingleValueOption":
                return "Option";
            case "SwitchOption":
                return "Option";
            case "Value":
                return "Option";
            case "Argument":
                return "Argument";
            case "Example":
                return "Example";
            case "SeeAlso":
                return "SeeAlso";
            default:
                throw new ArgumentException("Unknown Property Type " + element.Name.LocalName);
        }
    }

    string GetOptionType(XElement element)
    {
        return StringUtilities.GetOptionType(element);
    }

    bool isValidOption(XElement n)
    {
        return n.Name != XName.Get("Noun") && n.Name != XName.Get("Example") && n.Name != XName.Get("SeeAlso");
    }

    string getCommandHelpString(XElement cmd, string fallbackStringResource)
    {
        string help = cmd.Attribute(XName.Get("Help", ""))?.Value;

        if (help != null)
        {
            return help;
        }

        return fallbackStringResource;
    }

public static class StringUtilities
{
    public static string InitCaps(string input)
    {
        if (input == null)
        {
            return null;
        }

        var textInfo = CultureInfo.InvariantCulture.TextInfo;
        var output = textInfo.ToTitleCase(input);

        return output;
    }

    public static string GetClrType(XElement option)
    {
        string opt = GetOptionType(option);
        string optionType = option.Attribute(XName.Get("Type", ""))?.Value;

        if (optionType != null)
        {
            return optionType;
        }

        switch (GetOptionType(option))
        {
            case "MultipleValue":
                return "string";
            case "SingleValue":
                return "string";
            case "NoValue":
                return "bool";
            case "Value":
                if (string.IsNullOrEmpty(optionType))
                {
                    return "string";
                }
                return optionType;
            default:
                return "object";
        }
    }

    public static string GetOptionType(XElement element)
    {
        string arity = element.Attribute(XName.Get("Arity", ""))?.Value;
        if (arity != null)
        {
            return arity;
        }

        switch (element.Name.LocalName)
        {
            case "MultipleValueOption":
                return "MultipleValue";
            case "SingleValueOption":
                return "SingleValue";
            case "SwitchOption":
                return "NoValue";
            case "Value":
                return "Value";
            case "Argument":
                return "Value";
            default:
                throw new ArgumentException("Unknown Option Type " + element.Name.LocalName);
        }
    }

    public static string GetFormalName(string name)
    {
        return InitCaps(name)?.Replace("-", "");
    }

    public static string GetParamName(string name)
    {
        if (name == null)
        {
            return null;
        }
        if (name == "")
        {
            return "";
        }

        string formal = GetFormalName(name);
        var textInfo = CultureInfo.InvariantCulture.TextInfo;

        if (formal.Length == 1)
        {
            return textInfo.ToLower(formal.Substring(0, 1));
        }

        return textInfo.ToLower(formal.Substring(0, 1)) + formal.Substring(1);
    }
}

public class OptionData
{
    public OptionData(XElement element)
    {
        string elementName = element.Name.LocalName;
        Name = element.Attribute(XName.Get("Name", ""))?.Value;
        LongName = element.Attribute(XName.Get("LongName", ""))?.Value;
        Help = element.Attribute(XName.Get("Help", ""))?.Value;
        if (Help != null) { Help = "Strings." + Help; }
        Shortcut = element.Attribute(XName.Get("Shortcut",""))?.Value;
        IsRequired = element.Attribute(XName.Get("Required", ""))?.Value == "true";
        DataType = StringUtilities.GetClrType(element);
        string optionType = StringUtilities.GetOptionType(element);

        switch (elementName)
        {
            case "MultipleValueOption":
                BaseClass = "Option";
                OptionType = "ArgumentArity.OneOrMore";
                break;
            case "SingleValueOption":
                BaseClass = "Option";
                OptionType = "ArgumentArity.ZeroOrOne";
                break;
            case "SwitchOption":
                BaseClass = "Option";
                OptionType = "ArgumentArity.Zero";
                break;
            case "Value":
                BaseClass = "Option";
                OptionType = "ArgumentArity.ExactlyOne";
                break;
            case "Argument":
                BaseClass = "Argument";
                OptionType =  optionType != "Value" ? optionType : "ArgumentArity.ExactlyOne";
                break;
            case "Example":
                BaseClass = "Example";
                break;
            case "SeeAlso":
                BaseClass = "SeeAlso";
                break;
            default:
                throw new Exception("Unknown Element Type " + element.Name.LocalName);
        }

        var textInfo = CultureInfo.InvariantCulture.TextInfo;
        CamelCaseName = $"{textInfo.ToLower(InitCapsName[0])}{InitCapsName.Substring(1)}";
        PrivateMemberName = $"_{CamelCaseName}";
    }

    public string BaseClass { get; set; }
    public string OptionType { get; set; }
    public string Name { get; set; }
    public string InitCapsName { get { return StringUtilities.GetFormalName(Name); } }
    public string LongName { get; set; }
    public string LongNameOrName { get { return LongName != null ? LongName : Name; }}
    public string FormalName { get { return StringUtilities.GetFormalName(Name); } }
    public string Shortcut { get; set; }
    public string Help { get; set; }
    public bool IsRequired { get; set; }
    public string ShortcutString { get { return HasShortcut? ShortcutName + "|" + FullName : FullName; } }
    public bool HasShortcut { get { return Shortcut != null; } }
    public string ShortcutName { get { return "-" + Shortcut; } }
    public string FullName { get { return "--" + Name.ToLower(); } }
    public string DataType { get; set; }
    public string PrivateMemberName { get; }
    public string CamelCaseName { get; }
}

    string getSeparator(bool isFirst, bool isFirstWithSpace = true)
    {
        if (isFirst)
        {
            if (isFirstWithSpace)
            {
                return " ";
            }
            return string.Empty;
        }
        return ", ";
    }

    string Indent(int spaces)
    {
        return "".PadLeft(spaces);
    }

    string GenerateOptionNameVar(OptionData data)
    {
        return data.CamelCaseName + "_" + data.BaseClass;
    }

    void GenerateAddOptionOrArgument(IReadOnlyCollection<OptionData> options, string commandVarName, int indent = 4)
    {
        foreach (OptionData data in options)
        {
            string optionNameVar = GenerateOptionNameVar(data);
            if (data.BaseClass == "Argument")
            {
                // Generate Argument
                WriteLine($@"var {optionNameVar} = new Argument<{data.DataType}>(name: ""{data.LongNameOrName}"", description: {data.Help})");
                // End Generate argument
            }
            else if (data.BaseClass == "Option")
            {
                // Generate Option
                if (data.HasShortcut)
                {
                    WriteLine($@"var {optionNameVar} = new Option<{data.DataType}>(aliases: new[] {{ ""{data.ShortcutName}"", ""{data.FullName}"" }}, description: {data.Help})");
                }
                else
                {
                    WriteLine($@"var {optionNameVar} = new Option<{data.DataType}>(name: ""{data.FullName}"", description: {data.Help})");
                }
                // End Generate option
            }
            WriteLine("{");
            PushIndent(Indent(indent));
            WriteLine($@"Arity = {data.OptionType},");
            PopIndent();
            WriteLine("};");
            WriteLine($@"{commandVarName}.Add({optionNameVar});");
        }
    }

    void GenerateHandlerArguments(XElement optionsNode, int indent = 4)
    {
        // Create paramethers for command handler
        bool isFirst = true;
        var paramEnumerator = optionsNode.Elements().GetEnumerator();
        while (paramEnumerator.MoveNext())
        {
            XElement option = paramEnumerator.Current;
            if (!isValidOption(option))
            {
                continue;
            }
            var data = new OptionData(option);
#>
<#= Indent(indent) #><#= getSeparator(isFirst) #><#= StringUtilities.GetParamName(data.Name) #>
<#+
            isFirst = false;
        }
    }

    string GenerateCommandHandlerFunctionArgs(IReadOnlyCollection<OptionData> options, bool hasInitialComma = true, bool hasInitialSpace = true)
    {
        var sb = new StringBuilder();
        bool isFirst = !hasInitialComma;
        foreach (OptionData data in options)
        {
            sb.Append($"{getSeparator(isFirst, hasInitialSpace)}{GenerateOptionNameVar(data)}");
            isFirst = false;
        }

        return sb.ToString();
    }

    void GenerateCommandHandlerCustomBinder(string commandNameVar, string verbNounPrefix, string binderClassName, IReadOnlyCollection<OptionData> options)
    {
        string runnerClassName = $"{verbNounPrefix}Runner";

        WriteLine($"// Create handler delegate handler for {commandNameVar}");
        WriteLine($"{commandNameVar}.SetHandler((args) =>");
        WriteLine("{");
        PushIndent(Indent(4));
        WriteLine($"{runnerClassName}.Run(args, getLogger);"); // logger comes from param arg
        PopIndent();
        Write($"}}, new {binderClassName}(");
        Write(GenerateCommandHandlerFunctionArgs(options, hasInitialComma: false, hasInitialSpace: false));
        WriteLine("));");
    }

    void GenerateArgsClass(string className, XElement nodeMembers, string classVisibility = "public", int indent = 4)
    {
        PushIndent(Indent(indent));
        WriteLine($"{classVisibility} partial class {className}");
        WriteLine("{");
        PushIndent(Indent(indent * 2));
        foreach (XElement option in nodeMembers.Elements())
        {
            if (IsArgumentOrOption(GetProperty(option)))
            {
                string optionName = option.Attribute(XName.Get("Name", ""))?.Value;
                string optionFormalName = StringUtilities.GetFormalName(optionName);
                WriteLine($"public {GetClrType(option)} {optionFormalName} {{ get; set; }}");
            }
        }
        PopIndent();
        WriteLine("}");
        PopIndent();
        WriteLine("");
    } // end method GenerateArgsClass


    string GenerateTypeParams(XElement optionsNode, int indent = 4)
    {
        bool isFirst = true;
        var paramEnumerator = optionsNode.Elements().GetEnumerator();
        string arrayDelim;
        var sb = new StringBuilder();
        while (paramEnumerator.MoveNext())
        {
            XElement option = paramEnumerator.Current;
            if (!isValidOption(option))
            {
                continue;
            }
            var data = new OptionData(option);
            arrayDelim = data.OptionType == "ArgumentArity.OneOrMore" || data.OptionType == "ArgumentArity.ZeroOrMore" ? "[]" : "";
            sb.Append($"{getSeparator(isFirst)}{data.DataType}{arrayDelim}");
            isFirst = false;
        }

        return sb.ToString();
    }

    void GenerateSetCustomHandler(string commandVarName, string customHandler, IReadOnlyCollection<OptionData> options)
    {
        Write($"{commandVarName}.SetHandler({customHandler}");
        Write(GenerateCommandHandlerFunctionArgs(options));
        WriteLine(");");
    }

    string GetNodeFormalName(XElement nodeWithArgs)
    {
        string name = nodeWithArgs?.Attribute(XName.Get("Name", ""))?.Value;
        string formalName = StringUtilities.GetFormalName(name);

        return formalName;
    }

    string GetArgsClassName(XElement verb, XElement noun = null) => $"{GetNodeFormalName(verb)}{GetNodeFormalName(noun)}Args";

    string GetCustomBinderClassName(XElement verb, XElement noun = null) => $"{GetNodeFormalName(verb)}{GetNodeFormalName(noun)}CustomBinder";

    IReadOnlyCollection<OptionData> GetOptionsFromNode(XElement argsOptionsNode)
    {
        if (argsOptionsNode == null)
        {
            throw new ArgumentNullException(nameof(argsOptionsNode));
        }

        List<OptionData> options = new List<OptionData>();
        foreach (XElement option in argsOptionsNode.Elements())
        {
            if (isValidOption(option))
            {
                options.Add(new OptionData(option));
            }
        }

        return options;
    }

    void GenerateBinderClass(string className, string binderClassName, IReadOnlyCollection<OptionData> options)
    {
        if (string.IsNullOrWhiteSpace(className))
        {
            throw new ArgumentException("Value cannot be null or empty", nameof(className));
        }
        if (string.IsNullOrWhiteSpace(binderClassName))
        {
            throw new ArgumentException("Value cannot be null or empty", nameof(binderClassName));
        }
        if (options == null)
        {
            throw new ArgumentNullException(nameof(options));
        }

        WriteLine($"internal partial class {className} : BinderBase<{binderClassName}>");
        WriteLine("{");
        PushIndent(Indent(4));

        // Binder members
        foreach (OptionData data in options)
        {
            WriteLine($"private readonly {data.BaseClass}<{data.DataType}> {data.PrivateMemberName};");
        }
        WriteLine(string.Empty);

        // Constructor arguments
        bool isFirst = true;
        Write($"public {className}(");

        foreach (OptionData data in options)
        {
            Write($"{getSeparator(isFirst, isFirstWithSpace: false)}{data.BaseClass}<{data.DataType}> {data.CamelCaseName}");
            isFirst = false;
        }
        WriteLine(")");
        WriteLine("{");
        PushIndent(Indent(4));
        // Assignment
        foreach (OptionData data in options)
        {
            WriteLine($"{data.PrivateMemberName} = {data.CamelCaseName};");
        }
        PopIndent();
        WriteLine("}");
        WriteLine(string.Empty);

        WriteLine($"protected override {binderClassName} GetBoundValue(BindingContext bindingContext)");
        WriteLine("{");
        PushIndent(Indent(4));

        WriteLine($"var returnValue = new {binderClassName}()");
        WriteLine("{");
        PushIndent(Indent(4));
        // Argument assignment
        foreach (OptionData data in options)
        {
            if (data.BaseClass == "Option")
            {
                WriteLine($"{data.InitCapsName} = bindingContext.ParseResult.GetValueForOption({data.PrivateMemberName}),");
            }
            else if (data.BaseClass == "Argument")
            {
                WriteLine($"{data.InitCapsName} = bindingContext.ParseResult.GetValueForArgument({data.PrivateMemberName}),");
            }
        }
        PopIndent();
        WriteLine("};");

        WriteLine("return returnValue;");

        PopIndent();
        WriteLine("} // end GetBoundValue method");
        PopIndent();
        WriteLine("} // end class");
    }

    void GenerateBinderClass(XElement membersNode, XElement verbNameNode, XElement nounNameNode = null)
    {
        if (membersNode == null)
        {
            throw new ArgumentNullException(nameof(membersNode));
        }
        if (verbNameNode == null)
        {
            throw new ArgumentNullException(nameof(verbNameNode));
        }

        string binderTypeClassName = GetArgsClassName(verbNameNode, nounNameNode);
        string binderClassName = GetCustomBinderClassName(verbNameNode, nounNameNode);
        IReadOnlyCollection<OptionData> options = GetOptionsFromNode(membersNode);
        GenerateBinderClass(binderClassName, binderTypeClassName, options);
        WriteLine(string.Empty);
    }

    void GenerateRegisterMethodForCommand(string runnerPrefix, XElement commandNode, string binderClassName)
    {
        IReadOnlyCollection<OptionData> options = GetOptionsFromNode(commandNode);
        string customHandlerName = commandNode.Attribute(XName.Get("Handler", ""))?.Value;
        bool hasHustomHandler = !string.IsNullOrEmpty(customHandlerName);

        string cmdLocalName = "cmd";
        WriteLine($@"private static void RegisterOptionsForCommand{runnerPrefix}(Command {cmdLocalName}, Func<ILogger> getLogger)");
        WriteLine("{");
        PushIndent(Indent(4));
        GenerateAddOptionOrArgument(options, cmdLocalName);
        if (hasHustomHandler)
        {
            GenerateSetCustomHandler(cmdLocalName, customHandlerName, options);
        }
        else
        {
            GenerateCommandHandlerCustomBinder(cmdLocalName, runnerPrefix, binderClassName, options);
        }
        PopIndent();
        WriteLine("}");
    }

    void GenerateRegisterMehtodForCommandCall(string runnerPrefix, string commandNameVar, string loggerFuncNameVar)
    {
        WriteLine($@"RegisterOptionsForCommand{runnerPrefix}({commandNameVar}, {loggerFuncNameVar});");
    }
#>
