<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Xml.XDocument" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" #>
<#
 string commandFile = this.Host.ResolvePath("Commands.xml");
 XDocument commands = XDocument.Load(commandFile);
#>
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
<#@ include file="Utils.tt" #>
// Do not manually edit this autogenerated file:
// instead modify the neighboring .tt file (text template) and/or NuGet.CommandLine.Xplat\Commands\SystemCommandLine\Commands.xml (data file),
// then re-execute the text template via "run custom tool" on VS context menu for .tt file, or via dotnet-t4 global tool.

using System;
using System.CommandLine;
using NuGet.Commands;
using NuGet.Common;
using System.Threading.Tasks;

namespace NuGet.CommandLine.XPlat.Commands
{
<#
// ********************** Verb-Parser Template
var allElements = commands.Descendants(XName.Get("Verb","")).Concat(commands.Descendants(XName.Get("Command", "")));
foreach (XElement verb in allElements)
{
    string commandName = verb.Attribute(XName.Get("Name", "")).Value;
    string commandFormalName = InitCaps(commandName);
    string commandFormalNameVar = commandFormalName + "Cmd";
    IEnumerable<XElement> verbOpts = verb.Elements().Where(n => isValidOption(n));
#>
    internal partial class <#= commandFormalName #><#= verb.Name.LocalName #>Parser
    {
        internal static Func<ILogger> GetLoggerFunction;
        internal static Action<Exception> CommandExceptionHandler;

        internal static Command Register(Command app, Func<ILogger> getLogger, Action<Exception> commandExceptionHandler)
        {
            var <#= commandFormalNameVar #> = new Command(name: "<#= commandName #>", description: Strings.<#= getCommandHelpString(verb, $"{commandFormalName}_Description") #>);

            // Options directly under the verb '<#= commandName #>'
<#
    PushIndent(Indent(12));
    if (verbOpts.Any())
    {
        GenerateRegisterMehtodForCommandCall($@"{GetNodeFormalName(verb)}", commandFormalNameVar, "getLogger");
    }
    PopIndent();
    
    foreach (XElement noun in verb.Descendants(XName.Get("Noun")))
    {
        string nounName = noun.Attribute(XName.Get("Name", ""))?.Value;
        string nounFormalName = InitCaps(nounName)?.Replace("-", "");
        if (nounFormalName == null)
        {
            throw new ArgumentException("nounFormalName cannot be null");
        }
        string nounFormalNameVar = nounFormalName + "Cmd";
#>

            // noun sub-command: <#= commandName #> <#= nounName #>
            var <#= nounFormalNameVar #> = new Command(name: "<#= nounName #>", description: Strings.<#= getCommandHelpString(noun, $"{commandFormalName}{nounFormalName}CommandDescription") #>);

            // Options under sub-command: <#= commandName #> <#= nounName #>
<#
        // Look for options directly under each noun
        PushIndent(Indent(12));
        GenerateRegisterMehtodForCommandCall($@"{GetNodeFormalName(verb)}{GetNodeFormalName(noun)}", nounFormalNameVar, "getLogger");
        WriteLine(string.Empty);
        WriteLine($"{commandFormalNameVar}.AddCommand({nounFormalNameVar});");
        PopIndent();
    } // end noun foreach
#>

            GetLoggerFunction = getLogger;
            CommandExceptionHandler = commandExceptionHandler;
            app.AddCommand(<#= commandFormalNameVar #>);

            return <#= commandFormalNameVar #>;
        } // End noun method
<#
    PushIndent(Indent(8));

    // Generate handler for nouns
    foreach (XElement noun in verb.Descendants(XName.Get("Noun")))
    {
        WriteLine("");
        GenerateRegisterMethodForCommand($@"{GetNodeFormalName(verb)}{GetNodeFormalName(noun)}", noun, GetCustomBinderClassName(verb, noun));
    }

    // Generate handler for verbs or commands
    if (verbOpts.Any())
    {
        WriteLine("");
        GenerateRegisterMethodForCommand($@"{GetNodeFormalName(verb)}", verb, GetCustomBinderClassName(verb));
    }

    PopIndent();
#>
    } // end class

<#
} // end verb foreach
#>
} // end namespace
