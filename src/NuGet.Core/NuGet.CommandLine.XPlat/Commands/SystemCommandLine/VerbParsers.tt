<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Xml.XDocument" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" #>
<#
 string commandFile = this.Host.ResolvePath("Commands.xml");
 XDocument commands = XDocument.Load(commandFile);
#>
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
<#@ include file="Utils.tt" #>
// Do not manually edit this autogenerated file:
// instead modify the neighboring .tt file (text template) and/or NuGet.CommandLine.Xplat\Commands\SystemCommandLine\Commands.xml (data file),
// then re-execute the text template via "run custom tool" on VS context menu for .tt file, or via dotnet-t4 global tool.

using System;
using System.CommandLine;
using NuGet.Commands;
using NuGet.Common;

namespace NuGet.CommandLine.XPlat.Commands
{
<#
// ********************** Verb-Parser Template
var allElements = commands.Descendants(XName.Get("Verb","")).Concat(commands.Descendants(XName.Get("Command", "")));
foreach (XElement verb in allElements)
{
    string commandName = verb.Attribute(XName.Get("Name", "")).Value;
    string commandFormalName = InitCaps(commandName);
    string commandFormalNameVar = commandFormalName + "Cmd";
#>
    internal partial class <#= commandFormalName #><#= verb.Name.LocalName #>Parser
    {
        internal static Func<ILogger> GetLoggerFunction;

        internal static Command Register(Command app, Func<ILogger> getLogger)
        {
            var <#= commandFormalNameVar #> = new Command(name: "<#= commandName #>", description: Strings.<#= getCommandHelpString(verb, $"{commandFormalName}_Description") #>);

            // Options directly under the verb '<#= commandName #>'
<#
    GenerateAddOptionOrArgument(verb, commandFormalNameVar, 12);

    foreach (XElement noun in verb.Descendants(XName.Get("Noun")))
    {
        string nounName = noun.Attribute(XName.Get("Name", ""))?.Value;
        string nounFormalName = InitCaps(nounName)?.Replace("-", "");
        if (nounFormalName == null)
        {
            throw new ArgumentException("nounFormalName cannot be null");
        }
        string nounFormalNameVar = nounFormalName + "Cmd";
        IReadOnlyCollection<OptionData> options = GetOptionsFromNode(noun);
        string customHandlerName = noun.Attribute(XName.Get("Handler", ""))?.Value;
        bool hasHustomHandler = !string.IsNullOrEmpty(customHandlerName);
#>

            // noun sub-command: <#= commandName #> <#= nounName #>
            var <#= nounFormalNameVar #> = new Command(name: "<#= nounName #>", description: Strings.<#= getCommandHelpString(noun, $"{commandFormalName}{nounFormalName}CommandDescription") #>);

            // Options under sub-command: <#= commandName #> <#= nounName #>
<#
        // Look for options directly under each noun
        GenerateAddOptionOrArgument(noun, nounFormalNameVar, 12);

        // Generate handler for noun
        PushIndent(Indent(12));
        if (hasHustomHandler)
        {
            GenerateSetCustomHandler(nounFormalNameVar, customHandlerName, options);
        }
        else
        {
            string binderClassName = GetCustomBinderClassName(verb, noun);
            GenerateCommandHandlerCustomBinder(nounFormalNameVar, commandFormalName + nounFormalName, binderClassName, options);
        }

        WriteLine(string.Empty);
        WriteLine($"{commandFormalNameVar}.AddCommand({nounFormalNameVar});");
        PopIndent();
    } // end noun foreach

    // TODO: Generate handler for commands. See https://github.com/NuGet/Client.Engineering/issues/1817
#>

            GetLoggerFunction = getLogger;
            app.AddCommand(<#= commandFormalNameVar #>);

            return <#= commandFormalNameVar #>;
        } // End noun method
    } // end class

<#
} // end verb foreach
#>
} // end namespace
