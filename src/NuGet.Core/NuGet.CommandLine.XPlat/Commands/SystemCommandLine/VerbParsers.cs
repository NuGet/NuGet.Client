// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

// Do not manually edit this autogenerated file:
// instead modify the neighboring .tt file (text template) and/or NuGet.CommandLine.Xplat\Commands\SystemCommandLine\Commands.xml (data file),
// then re-execute the text template via "run custom tool" on VS context menu for .tt file, or via dotnet-t4 global tool.

using System;
using System.CommandLine;
using NuGet.Commands;
using NuGet.Common;
using System.Threading.Tasks;

namespace NuGet.CommandLine.XPlat.Commands
{
    internal partial class AddVerbParser
    {
        internal static Func<ILogger> GetLoggerFunction;
        internal static Action<Exception> CommandExceptionHandler;

        internal static Command Register(Command app, Func<ILogger> getLogger, Action<Exception> commandExceptionHandler)
        {
            var AddCmd = new Command(name: "add", description: Strings.Add_Description);

            // Options directly under the verb 'add'

            // noun sub-command: add source
            var SourceCmd = new Command(name: "source", description: Strings.AddSourceCommandDescription);

            // Options under sub-command: add source
            RegisterOptionsForCommandAddSource(SourceCmd, getLogger);

            AddCmd.AddCommand(SourceCmd);

            GetLoggerFunction = getLogger;
            CommandExceptionHandler = commandExceptionHandler;
            app.AddCommand(AddCmd);

            return AddCmd;
        } // End noun method

        private static void RegisterOptionsForCommandAddSource(Command cmd, Func<ILogger> getLogger)
        {
            var source_Argument = new Argument<string>(name: "PackageSourcePath", description: Strings.SourcesCommandSourceDescription)
            {
                Arity = ArgumentArity.ExactlyOne,
            };
            cmd.Add(source_Argument);
            var name_Option = new Option<string>(aliases: new[] { "-n", "--name" }, description: Strings.SourcesCommandNameDescription)
            {
                Arity = ArgumentArity.ZeroOrOne,
            };
            cmd.Add(name_Option);
            var username_Option = new Option<string>(aliases: new[] { "-u", "--username" }, description: Strings.SourcesCommandUsernameDescription)
            {
                Arity = ArgumentArity.ZeroOrOne,
            };
            cmd.Add(username_Option);
            var password_Option = new Option<string>(aliases: new[] { "-p", "--password" }, description: Strings.SourcesCommandPasswordDescription)
            {
                Arity = ArgumentArity.ZeroOrOne,
            };
            cmd.Add(password_Option);
            var storePasswordInClearText_Option = new Option<bool>(name: "--store-password-in-clear-text", description: Strings.SourcesCommandStorePasswordInClearTextDescription)
            {
                Arity = ArgumentArity.Zero,
            };
            cmd.Add(storePasswordInClearText_Option);
            var validAuthenticationTypes_Option = new Option<string>(name: "--valid-authentication-types", description: Strings.SourcesCommandValidAuthenticationTypesDescription)
            {
                Arity = ArgumentArity.ZeroOrOne,
            };
            cmd.Add(validAuthenticationTypes_Option);
            var configfile_Option = new Option<string>(name: "--configfile", description: Strings.Option_ConfigFile)
            {
                Arity = ArgumentArity.ZeroOrOne,
            };
            cmd.Add(configfile_Option);
            // Create handler delegate handler for cmd
            cmd.SetHandler((args) =>
            {
                int exitCode;
                try
                {
                    AddSourceRunner.Run(args, getLogger);
                    exitCode = 0;
                }
                catch (Exception e)
                {
                    CommandExceptionHandler(e);
                    exitCode = 1;
                }
                return Task.FromResult(exitCode);
            }, new AddSourceCustomBinder(source_Argument, name_Option, username_Option, password_Option, storePasswordInClearText_Option, validAuthenticationTypes_Option, configfile_Option));
        }
    } // end class

    internal partial class ListVerbParser
    {
        internal static Func<ILogger> GetLoggerFunction;
        internal static Action<Exception> CommandExceptionHandler;

        internal static Command Register(Command app, Func<ILogger> getLogger, Action<Exception> commandExceptionHandler)
        {
            var ListCmd = new Command(name: "list", description: Strings.List_Description);

            // Options directly under the verb 'list'

            // noun sub-command: list source
            var SourceCmd = new Command(name: "source", description: Strings.ListSourceCommandDescription);

            // Options under sub-command: list source
            RegisterOptionsForCommandListSource(SourceCmd, getLogger);

            ListCmd.AddCommand(SourceCmd);

            GetLoggerFunction = getLogger;
            CommandExceptionHandler = commandExceptionHandler;
            app.AddCommand(ListCmd);

            return ListCmd;
        } // End noun method

        private static void RegisterOptionsForCommandListSource(Command cmd, Func<ILogger> getLogger)
        {
            var format_Option = new Option<string>(name: "--format", description: Strings.SourcesCommandFormatDescription)
            {
                Arity = ArgumentArity.ZeroOrOne,
            };
            cmd.Add(format_Option);
            var configfile_Option = new Option<string>(name: "--configfile", description: Strings.Option_ConfigFile)
            {
                Arity = ArgumentArity.ZeroOrOne,
            };
            cmd.Add(configfile_Option);
            // Create handler delegate handler for cmd
            cmd.SetHandler((args) =>
            {
                int exitCode;
                try
                {
                    ListSourceRunner.Run(args, getLogger);
                    exitCode = 0;
                }
                catch (Exception e)
                {
                    CommandExceptionHandler(e);
                    exitCode = 1;
                }
                return Task.FromResult(exitCode);
            }, new ListSourceCustomBinder(format_Option, configfile_Option));
        }
    } // end class

} // end namespace
