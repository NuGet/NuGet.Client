NuGet.Client.ManagedCodeConventions
NuGet.Client.ManagedCodeConventions.Criteria.get -> NuGet.Client.ManagedCodeConventions.ManagedCodeCriteria
NuGet.Client.ManagedCodeConventions.ManagedCodeConventions(NuGet.RuntimeModel.RuntimeGraph runtimeGraph) -> void
NuGet.Client.ManagedCodeConventions.ManagedCodeCriteria
NuGet.Client.ManagedCodeConventions.ManagedCodeCriteria.ForFramework(NuGet.Frameworks.NuGetFramework framework) -> NuGet.ContentModel.SelectionCriteria
NuGet.Client.ManagedCodeConventions.ManagedCodeCriteria.ForFrameworkAndRuntime(NuGet.Frameworks.NuGetFramework framework, string runtimeIdentifier) -> NuGet.ContentModel.SelectionCriteria
NuGet.Client.ManagedCodeConventions.ManagedCodeCriteria.ForRuntime(string runtimeIdentifier) -> NuGet.ContentModel.SelectionCriteria
NuGet.Client.ManagedCodeConventions.ManagedCodePatterns
NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.AnyTargettedFile.get -> NuGet.ContentModel.PatternSet
NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.CompileLibAssemblies.get -> NuGet.ContentModel.PatternSet
NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.CompileRefAssemblies.get -> NuGet.ContentModel.PatternSet
NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.ContentFiles.get -> NuGet.ContentModel.PatternSet
NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.EmbedAssemblies.get -> NuGet.ContentModel.PatternSet
NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.MSBuildFiles.get -> NuGet.ContentModel.PatternSet
NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.MSBuildMultiTargetingFiles.get -> NuGet.ContentModel.PatternSet
NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.MSBuildTransitiveFiles.get -> NuGet.ContentModel.PatternSet
NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.NativeLibraries.get -> NuGet.ContentModel.PatternSet
NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.ResourceAssemblies.get -> NuGet.ContentModel.PatternSet
NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.RuntimeAssemblies.get -> NuGet.ContentModel.PatternSet
NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.ToolsAssemblies.get -> NuGet.ContentModel.PatternSet
NuGet.Client.ManagedCodeConventions.Patterns.get -> NuGet.Client.ManagedCodeConventions.ManagedCodePatterns
NuGet.Client.ManagedCodeConventions.Properties.get -> System.Collections.Generic.IReadOnlyDictionary<string, NuGet.ContentModel.ContentPropertyDefinition>
NuGet.Client.ManagedCodeConventions.PropertyNames
NuGet.ContentModel.Asset
NuGet.ContentModel.Asset.Asset() -> void
NuGet.ContentModel.Asset.Link.get -> string
NuGet.ContentModel.Asset.Link.set -> void
NuGet.ContentModel.Asset.Path.get -> string
NuGet.ContentModel.Asset.Path.set -> void
NuGet.ContentModel.ContentItem
NuGet.ContentModel.ContentItem.ContentItem() -> void
NuGet.ContentModel.ContentItem.Path.get -> string
NuGet.ContentModel.ContentItem.Path.set -> void
NuGet.ContentModel.ContentItem.Properties.get -> System.Collections.Generic.Dictionary<string, object>
NuGet.ContentModel.ContentItemCollection
NuGet.ContentModel.ContentItemCollection.ContentItemCollection() -> void
NuGet.ContentModel.ContentItemCollection.FindBestItemGroup(NuGet.ContentModel.SelectionCriteria criteria, params NuGet.ContentModel.PatternSet[] definitions) -> NuGet.ContentModel.ContentItemGroup
NuGet.ContentModel.ContentItemCollection.FindItemGroups(NuGet.ContentModel.PatternSet definition) -> System.Collections.Generic.IEnumerable<NuGet.ContentModel.ContentItemGroup>
NuGet.ContentModel.ContentItemCollection.FindItems(NuGet.ContentModel.PatternSet definition) -> System.Collections.Generic.IEnumerable<NuGet.ContentModel.ContentItem>
NuGet.ContentModel.ContentItemCollection.HasContract.get -> bool
NuGet.ContentModel.ContentItemCollection.HasItemGroup(NuGet.ContentModel.SelectionCriteria criteria, params NuGet.ContentModel.PatternSet[] definitions) -> bool
NuGet.ContentModel.ContentItemCollection.Load(System.Collections.Generic.IEnumerable<string> paths) -> void
NuGet.ContentModel.ContentItemGroup
NuGet.ContentModel.ContentItemGroup.ContentItemGroup() -> void
NuGet.ContentModel.ContentItemGroup.Items.get -> System.Collections.Generic.IList<NuGet.ContentModel.ContentItem>
NuGet.ContentModel.ContentItemGroup.Properties.get -> System.Collections.Generic.IDictionary<string, object>
NuGet.ContentModel.ContentPropertyDefinition
NuGet.ContentModel.ContentPropertyDefinition.CompareTest.get -> System.Func<object, object, object, int>
NuGet.ContentModel.ContentPropertyDefinition.CompatibilityTest.get -> System.Func<object, object, bool>
NuGet.ContentModel.ContentPropertyDefinition.ContentPropertyDefinition(string name) -> void
NuGet.ContentModel.ContentPropertyDefinition.ContentPropertyDefinition(string name, System.Collections.Generic.IEnumerable<string> fileExtensions) -> void
NuGet.ContentModel.ContentPropertyDefinition.ContentPropertyDefinition(string name, System.Collections.Generic.IEnumerable<string> fileExtensions, bool allowSubfolders) -> void
NuGet.ContentModel.ContentPropertyDefinition.ContentPropertyDefinition(string name, System.Func<object, object, bool> compatibilityTest) -> void
NuGet.ContentModel.ContentPropertyDefinition.ContentPropertyDefinition(string name, System.Func<string, NuGet.ContentModel.PatternTable, object> parser) -> void
NuGet.ContentModel.ContentPropertyDefinition.ContentPropertyDefinition(string name, System.Func<string, NuGet.ContentModel.PatternTable, object> parser, System.Collections.Generic.IEnumerable<string> fileExtensions) -> void
NuGet.ContentModel.ContentPropertyDefinition.ContentPropertyDefinition(string name, System.Func<string, NuGet.ContentModel.PatternTable, object> parser, System.Collections.Generic.IEnumerable<string> fileExtensions, bool allowSubfolders) -> void
NuGet.ContentModel.ContentPropertyDefinition.ContentPropertyDefinition(string name, System.Func<string, NuGet.ContentModel.PatternTable, object> parser, System.Func<object, object, bool> compatibilityTest) -> void
NuGet.ContentModel.ContentPropertyDefinition.ContentPropertyDefinition(string name, System.Func<string, NuGet.ContentModel.PatternTable, object> parser, System.Func<object, object, bool> compatibilityTest, System.Func<object, object, object, int> compareTest) -> void
NuGet.ContentModel.ContentPropertyDefinition.ContentPropertyDefinition(string name, System.Func<string, NuGet.ContentModel.PatternTable, object> parser, System.Func<object, object, bool> compatibilityTest, System.Func<object, object, object, int> compareTest, System.Collections.Generic.IEnumerable<string> fileExtensions, bool allowSubfolders) -> void
NuGet.ContentModel.ContentPropertyDefinition.FileExtensionAllowSubFolders.get -> bool
NuGet.ContentModel.ContentPropertyDefinition.FileExtensions.get -> System.Collections.Generic.List<string>
NuGet.ContentModel.ContentPropertyDefinition.Name.get -> string
NuGet.ContentModel.ContentPropertyDefinition.Parser.get -> System.Func<string, NuGet.ContentModel.PatternTable, object>
NuGet.ContentModel.Infrastructure.PatternExpression
NuGet.ContentModel.Infrastructure.PatternExpression.Match(string path, System.Collections.Generic.IReadOnlyDictionary<string, NuGet.ContentModel.ContentPropertyDefinition> propertyDefinitions) -> NuGet.ContentModel.ContentItem
NuGet.ContentModel.Infrastructure.PatternExpression.PatternExpression(NuGet.ContentModel.PatternDefinition pattern) -> void
NuGet.ContentModel.PatternDefinition
NuGet.ContentModel.PatternDefinition.Defaults.get -> System.Collections.Generic.IReadOnlyDictionary<string, object>
NuGet.ContentModel.PatternDefinition.Pattern.get -> string
NuGet.ContentModel.PatternDefinition.PatternDefinition(string pattern) -> void
NuGet.ContentModel.PatternDefinition.PatternDefinition(string pattern, NuGet.ContentModel.PatternTable table) -> void
NuGet.ContentModel.PatternDefinition.PatternDefinition(string pattern, NuGet.ContentModel.PatternTable table, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, object>> defaults) -> void
NuGet.ContentModel.PatternDefinition.Table.get -> NuGet.ContentModel.PatternTable
NuGet.ContentModel.PatternSet
NuGet.ContentModel.PatternSet.GroupPatterns.get -> System.Collections.Generic.IEnumerable<NuGet.ContentModel.PatternDefinition>
NuGet.ContentModel.PatternSet.PathPatterns.get -> System.Collections.Generic.IEnumerable<NuGet.ContentModel.PatternDefinition>
NuGet.ContentModel.PatternSet.PatternSet(System.Collections.Generic.IReadOnlyDictionary<string, NuGet.ContentModel.ContentPropertyDefinition> properties, System.Collections.Generic.IEnumerable<NuGet.ContentModel.PatternDefinition> groupPatterns, System.Collections.Generic.IEnumerable<NuGet.ContentModel.PatternDefinition> pathPatterns) -> void
NuGet.ContentModel.PatternSet.PropertyDefinitions.get -> System.Collections.Generic.IReadOnlyDictionary<string, NuGet.ContentModel.ContentPropertyDefinition>
NuGet.ContentModel.PatternSet.PropertyDefinitions.set -> void
NuGet.ContentModel.PatternTable
NuGet.ContentModel.PatternTable.PatternTable() -> void
NuGet.ContentModel.PatternTable.PatternTable(System.Collections.Generic.IEnumerable<NuGet.ContentModel.PatternTableEntry> entries) -> void
NuGet.ContentModel.PatternTable.TryLookup(string propertyName, string name, out object value) -> bool
NuGet.ContentModel.PatternTableEntry
NuGet.ContentModel.PatternTableEntry.Name.get -> string
NuGet.ContentModel.PatternTableEntry.PatternTableEntry(string propertyName, string name, object value) -> void
NuGet.ContentModel.PatternTableEntry.PropertyName.get -> string
NuGet.ContentModel.PatternTableEntry.Value.get -> object
NuGet.ContentModel.SelectionCriteria
NuGet.ContentModel.SelectionCriteria.Entries.get -> System.Collections.Generic.IList<NuGet.ContentModel.SelectionCriteriaEntry>
NuGet.ContentModel.SelectionCriteria.Entries.set -> void
NuGet.ContentModel.SelectionCriteria.SelectionCriteria() -> void
NuGet.ContentModel.SelectionCriteriaBuilder
NuGet.ContentModel.SelectionCriteriaBuilder.Properties.get -> System.Collections.Generic.IReadOnlyDictionary<string, NuGet.ContentModel.ContentPropertyDefinition>
NuGet.ContentModel.SelectionCriteriaBuilder.SelectionCriteriaBuilder(System.Collections.Generic.IReadOnlyDictionary<string, NuGet.ContentModel.ContentPropertyDefinition> properties) -> void
NuGet.ContentModel.SelectionCriteriaEntry
NuGet.ContentModel.SelectionCriteriaEntry.Properties.get -> System.Collections.Generic.IDictionary<string, object>
NuGet.ContentModel.SelectionCriteriaEntry.Properties.set -> void
NuGet.ContentModel.SelectionCriteriaEntry.SelectionCriteriaEntry() -> void
NuGet.ContentModel.SelectionCriteriaEntryBuilder
NuGet.ContentModel.SelectionCriteriaEntryBuilder.Builder.get -> NuGet.ContentModel.SelectionCriteriaBuilder
NuGet.ContentModel.SelectionCriteriaEntryBuilder.Entry.get -> NuGet.ContentModel.SelectionCriteriaEntry
NuGet.ContentModel.SelectionCriteriaEntryBuilder.this[string key, object value].get -> NuGet.ContentModel.SelectionCriteriaEntryBuilder
NuGet.ContentModel.SelectionCriteriaEntryBuilder.this[string key, string value].get -> NuGet.ContentModel.SelectionCriteriaEntryBuilder
NuGet.Packaging.CollectionExtensions
NuGet.Packaging.Core.ContentFilesEntry
NuGet.Packaging.Core.ContentFilesEntry.BuildAction.get -> string
NuGet.Packaging.Core.ContentFilesEntry.ContentFilesEntry(string include, string exclude, string buildAction, bool? copyToOutput, bool? flatten) -> void
NuGet.Packaging.Core.ContentFilesEntry.CopyToOutput.get -> bool?
NuGet.Packaging.Core.ContentFilesEntry.Exclude.get -> string
NuGet.Packaging.Core.ContentFilesEntry.Flatten.get -> bool?
NuGet.Packaging.Core.ContentFilesEntry.Include.get -> string
NuGet.Packaging.Core.ExtractPackageFileDelegate
NuGet.Packaging.Core.Fingerprints
NuGet.Packaging.Core.Fingerprints.Fingerprints(System.Collections.Generic.IDictionary<string, string> fingerPrints) -> void
NuGet.Packaging.Core.Fingerprints.GetEnumerator() -> System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<string, string>>
NuGet.Packaging.Core.Fingerprints.this[string key].get -> string
NuGet.Packaging.Core.IAsyncPackageCoreReader
NuGet.Packaging.Core.IAsyncPackageCoreReader.CopyFilesAsync(string destination, System.Collections.Generic.IEnumerable<string> packageFiles, NuGet.Packaging.Core.ExtractPackageFileDelegate extractFile, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<string>>
NuGet.Packaging.Core.IAsyncPackageCoreReader.GetFilesAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<string>>
NuGet.Packaging.Core.IAsyncPackageCoreReader.GetFilesAsync(string folder, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<string>>
NuGet.Packaging.Core.IAsyncPackageCoreReader.GetIdentityAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Packaging.Core.PackageIdentity>
NuGet.Packaging.Core.IAsyncPackageCoreReader.GetMinClientVersionAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Versioning.NuGetVersion>
NuGet.Packaging.Core.IAsyncPackageCoreReader.GetNuspecAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.IO.Stream>
NuGet.Packaging.Core.IAsyncPackageCoreReader.GetNuspecFileAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<string>
NuGet.Packaging.Core.IAsyncPackageCoreReader.GetPackageTypesAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<NuGet.Packaging.Core.PackageType>>
NuGet.Packaging.Core.IAsyncPackageCoreReader.GetStreamAsync(string path, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.IO.Stream>
NuGet.Packaging.Core.INuspecCoreReader
NuGet.Packaging.Core.INuspecCoreReader.GetId() -> string
NuGet.Packaging.Core.INuspecCoreReader.GetIdentity() -> NuGet.Packaging.Core.PackageIdentity
NuGet.Packaging.Core.INuspecCoreReader.GetMetadata() -> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>>
NuGet.Packaging.Core.INuspecCoreReader.GetMinClientVersion() -> NuGet.Versioning.NuGetVersion
NuGet.Packaging.Core.INuspecCoreReader.GetPackageTypes() -> System.Collections.Generic.IReadOnlyList<NuGet.Packaging.Core.PackageType>
NuGet.Packaging.Core.INuspecCoreReader.GetVersion() -> NuGet.Versioning.NuGetVersion
NuGet.Packaging.Core.IPackageCoreReader
NuGet.Packaging.Core.IPackageCoreReader.CopyFiles(string destination, System.Collections.Generic.IEnumerable<string> packageFiles, NuGet.Packaging.Core.ExtractPackageFileDelegate extractFile, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Collections.Generic.IEnumerable<string>
NuGet.Packaging.Core.IPackageCoreReader.GetFiles() -> System.Collections.Generic.IEnumerable<string>
NuGet.Packaging.Core.IPackageCoreReader.GetFiles(string folder) -> System.Collections.Generic.IEnumerable<string>
NuGet.Packaging.Core.IPackageCoreReader.GetIdentity() -> NuGet.Packaging.Core.PackageIdentity
NuGet.Packaging.Core.IPackageCoreReader.GetMinClientVersion() -> NuGet.Versioning.NuGetVersion
NuGet.Packaging.Core.IPackageCoreReader.GetNuspec() -> System.IO.Stream
NuGet.Packaging.Core.IPackageCoreReader.GetNuspecFile() -> string
NuGet.Packaging.Core.IPackageCoreReader.GetPackageTypes() -> System.Collections.Generic.IReadOnlyList<NuGet.Packaging.Core.PackageType>
NuGet.Packaging.Core.IPackageCoreReader.GetStream(string path) -> System.IO.Stream
NuGet.Packaging.Core.IPackageIdentityComparer
NuGet.Packaging.Core.IRepositoryCertificateInfo
NuGet.Packaging.Core.IRepositoryCertificateInfo.ContentUrl.get -> string
NuGet.Packaging.Core.IRepositoryCertificateInfo.Fingerprints.get -> NuGet.Packaging.Core.Fingerprints
NuGet.Packaging.Core.IRepositoryCertificateInfo.Issuer.get -> string
NuGet.Packaging.Core.IRepositoryCertificateInfo.NotAfter.get -> System.DateTimeOffset
NuGet.Packaging.Core.IRepositoryCertificateInfo.NotBefore.get -> System.DateTimeOffset
NuGet.Packaging.Core.IRepositoryCertificateInfo.Subject.get -> string
NuGet.Packaging.Core.NuspecCoreReader
NuGet.Packaging.Core.NuspecCoreReader.NuspecCoreReader(System.IO.Stream stream) -> void
NuGet.Packaging.Core.NuspecCoreReader.NuspecCoreReader(System.Xml.Linq.XDocument xml) -> void
NuGet.Packaging.Core.NuspecCoreReaderBase
NuGet.Packaging.Core.NuspecCoreReaderBase.MetadataNode.get -> System.Xml.Linq.XElement
NuGet.Packaging.Core.NuspecCoreReaderBase.MetadataValues.get -> System.Collections.Generic.Dictionary<string, string>
NuGet.Packaging.Core.NuspecCoreReaderBase.NuspecCoreReaderBase(System.IO.Stream stream) -> void
NuGet.Packaging.Core.NuspecCoreReaderBase.NuspecCoreReaderBase(System.IO.Stream stream, bool leaveStreamOpen) -> void
NuGet.Packaging.Core.NuspecCoreReaderBase.NuspecCoreReaderBase(System.Xml.Linq.XDocument xml) -> void
NuGet.Packaging.Core.NuspecCoreReaderBase.NuspecCoreReaderBase(string path) -> void
NuGet.Packaging.Core.NuspecCoreReaderBase.Xml.get -> System.Xml.Linq.XDocument
NuGet.Packaging.Core.NuspecUtility
NuGet.Packaging.Core.PackageDependency
NuGet.Packaging.Core.PackageDependency.Equals(NuGet.Packaging.Core.PackageDependency other) -> bool
NuGet.Packaging.Core.PackageDependency.Exclude.get -> System.Collections.Generic.IReadOnlyList<string>
NuGet.Packaging.Core.PackageDependency.Id.get -> string
NuGet.Packaging.Core.PackageDependency.Include.get -> System.Collections.Generic.IReadOnlyList<string>
NuGet.Packaging.Core.PackageDependency.PackageDependency(string id) -> void
NuGet.Packaging.Core.PackageDependency.PackageDependency(string id, NuGet.Versioning.VersionRange versionRange) -> void
NuGet.Packaging.Core.PackageDependency.PackageDependency(string id, NuGet.Versioning.VersionRange versionRange, System.Collections.Generic.IReadOnlyList<string> include, System.Collections.Generic.IReadOnlyList<string> exclude) -> void
NuGet.Packaging.Core.PackageDependency.VersionRange.get -> NuGet.Versioning.VersionRange
NuGet.Packaging.Core.PackageDependencyComparer
NuGet.Packaging.Core.PackageDependencyComparer.Equals(NuGet.Packaging.Core.PackageDependency x, NuGet.Packaging.Core.PackageDependency y) -> bool
NuGet.Packaging.Core.PackageDependencyComparer.GetHashCode(NuGet.Packaging.Core.PackageDependency obj) -> int
NuGet.Packaging.Core.PackageDependencyComparer.PackageDependencyComparer() -> void
NuGet.Packaging.Core.PackageDependencyComparer.PackageDependencyComparer(NuGet.Versioning.IVersionRangeComparer versionRangeComparer) -> void
NuGet.Packaging.Core.PackageDependencyInfo
NuGet.Packaging.Core.PackageDependencyInfo.Dependencies.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.PackageDependency>
NuGet.Packaging.Core.PackageDependencyInfo.Equals(NuGet.Packaging.Core.PackageDependencyInfo other) -> bool
NuGet.Packaging.Core.PackageDependencyInfo.PackageDependencyInfo(NuGet.Packaging.Core.PackageIdentity identity, System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.PackageDependency> dependencies) -> void
NuGet.Packaging.Core.PackageDependencyInfo.PackageDependencyInfo(string id, NuGet.Versioning.NuGetVersion version) -> void
NuGet.Packaging.Core.PackageDependencyInfo.PackageDependencyInfo(string id, NuGet.Versioning.NuGetVersion version, System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.PackageDependency> dependencies) -> void
NuGet.Packaging.Core.PackageDependencyInfoComparer
NuGet.Packaging.Core.PackageDependencyInfoComparer.Equals(NuGet.Packaging.Core.PackageDependencyInfo x, NuGet.Packaging.Core.PackageDependencyInfo y) -> bool
NuGet.Packaging.Core.PackageDependencyInfoComparer.GetHashCode(NuGet.Packaging.Core.PackageDependencyInfo obj) -> int
NuGet.Packaging.Core.PackageDependencyInfoComparer.PackageDependencyInfoComparer() -> void
NuGet.Packaging.Core.PackageDependencyInfoComparer.PackageDependencyInfoComparer(NuGet.Packaging.Core.IPackageIdentityComparer identityComparer, NuGet.Packaging.Core.PackageDependencyComparer dependencyComparer) -> void
NuGet.Packaging.Core.PackageIdentity
NuGet.Packaging.Core.PackageIdentity.CompareTo(NuGet.Packaging.Core.PackageIdentity other) -> int
NuGet.Packaging.Core.PackageIdentity.Equals(NuGet.Packaging.Core.PackageIdentity other) -> bool
NuGet.Packaging.Core.PackageIdentity.HasVersion.get -> bool
NuGet.Packaging.Core.PackageIdentity.Id.get -> string
NuGet.Packaging.Core.PackageIdentity.PackageIdentity(string id, NuGet.Versioning.NuGetVersion version) -> void
NuGet.Packaging.Core.PackageIdentity.Version.get -> NuGet.Versioning.NuGetVersion
NuGet.Packaging.Core.PackageIdentityComparer
NuGet.Packaging.Core.PackageIdentityComparer.Compare(NuGet.Packaging.Core.PackageIdentity x, NuGet.Packaging.Core.PackageIdentity y) -> int
NuGet.Packaging.Core.PackageIdentityComparer.Equals(NuGet.Packaging.Core.PackageIdentity x, NuGet.Packaging.Core.PackageIdentity y) -> bool
NuGet.Packaging.Core.PackageIdentityComparer.GetHashCode(NuGet.Packaging.Core.PackageIdentity obj) -> int
NuGet.Packaging.Core.PackageIdentityComparer.PackageIdentityComparer() -> void
NuGet.Packaging.Core.PackageIdentityComparer.PackageIdentityComparer(NuGet.Versioning.IVersionComparer versionComparer) -> void
NuGet.Packaging.Core.PackageIdentityComparer.PackageIdentityComparer(NuGet.Versioning.VersionComparison versionComparison) -> void
NuGet.Packaging.Core.PackageType
NuGet.Packaging.Core.PackageType.CompareTo(NuGet.Packaging.Core.PackageType other) -> int
NuGet.Packaging.Core.PackageType.Equals(NuGet.Packaging.Core.PackageType other) -> bool
NuGet.Packaging.Core.PackageType.Name.get -> string
NuGet.Packaging.Core.PackageType.PackageType(string name, System.Version version) -> void
NuGet.Packaging.Core.PackageType.Version.get -> System.Version
NuGet.Packaging.Core.PackagingCoreConstants
NuGet.Packaging.Core.PackagingException
NuGet.Packaging.Core.PackagingException.PackagingException(NuGet.Common.NuGetLogCode logCode, string message) -> void
NuGet.Packaging.Core.PackagingException.PackagingException(NuGet.Common.NuGetLogCode logCode, string message, System.Exception innerException) -> void
NuGet.Packaging.Core.PackagingException.PackagingException(string message) -> void
NuGet.Packaging.Core.PackagingException.PackagingException(string message, System.Exception innerException) -> void
NuGet.Packaging.Core.RepositoryMetadata
NuGet.Packaging.Core.RepositoryMetadata.Branch.get -> string
NuGet.Packaging.Core.RepositoryMetadata.Branch.set -> void
NuGet.Packaging.Core.RepositoryMetadata.Commit.get -> string
NuGet.Packaging.Core.RepositoryMetadata.Commit.set -> void
NuGet.Packaging.Core.RepositoryMetadata.Equals(NuGet.Packaging.Core.RepositoryMetadata other) -> bool
NuGet.Packaging.Core.RepositoryMetadata.RepositoryMetadata() -> void
NuGet.Packaging.Core.RepositoryMetadata.RepositoryMetadata(string type, string url, string branch, string commit) -> void
NuGet.Packaging.Core.RepositoryMetadata.Type.get -> string
NuGet.Packaging.Core.RepositoryMetadata.Type.set -> void
NuGet.Packaging.Core.RepositoryMetadata.Url.get -> string
NuGet.Packaging.Core.RepositoryMetadata.Url.set -> void
NuGet.Packaging.ExtractionSource
NuGet.Packaging.ExtractionSource.DownloadResource = 1 -> NuGet.Packaging.ExtractionSource
NuGet.Packaging.ExtractionSource.NuGetFolderProject = 2 -> NuGet.Packaging.ExtractionSource
NuGet.Packaging.ExtractionSource.RestoreCommand = 0 -> NuGet.Packaging.ExtractionSource
NuGet.Packaging.FallbackPackagePathInfo
NuGet.Packaging.FallbackPackagePathInfo.FallbackPackagePathInfo(string id, NuGet.Versioning.NuGetVersion version, NuGet.Packaging.VersionFolderPathResolver resolver) -> void
NuGet.Packaging.FallbackPackagePathInfo.Id.get -> string
NuGet.Packaging.FallbackPackagePathInfo.PathResolver.get -> NuGet.Packaging.VersionFolderPathResolver
NuGet.Packaging.FallbackPackagePathInfo.Version.get -> NuGet.Versioning.NuGetVersion
NuGet.Packaging.FallbackPackagePathResolver
NuGet.Packaging.FallbackPackagePathResolver.FallbackPackagePathResolver(NuGet.Common.INuGetPathContext pathContext) -> void
NuGet.Packaging.FallbackPackagePathResolver.FallbackPackagePathResolver(string userPackageFolder, System.Collections.Generic.IEnumerable<string> fallbackPackageFolders) -> void
NuGet.Packaging.FallbackPackagePathResolver.GetPackageDirectory(string packageId, NuGet.Versioning.NuGetVersion version) -> string
NuGet.Packaging.FallbackPackagePathResolver.GetPackageDirectory(string packageId, string version) -> string
NuGet.Packaging.FallbackPackagePathResolver.GetPackageInfo(string packageId, NuGet.Versioning.NuGetVersion version) -> NuGet.Packaging.FallbackPackagePathInfo
NuGet.Packaging.FrameworkAssemblyReference
NuGet.Packaging.FrameworkAssemblyReference.AssemblyName.get -> string
NuGet.Packaging.FrameworkAssemblyReference.FrameworkAssemblyReference(string assemblyName, System.Collections.Generic.IEnumerable<NuGet.Frameworks.NuGetFramework> supportedFrameworks) -> void
NuGet.Packaging.FrameworkAssemblyReference.SupportedFrameworks.get -> System.Collections.Generic.IEnumerable<NuGet.Frameworks.NuGetFramework>
NuGet.Packaging.FrameworkNameUtility
NuGet.Packaging.FrameworkReference
NuGet.Packaging.FrameworkReference.Compare(NuGet.Packaging.FrameworkReference x, NuGet.Packaging.FrameworkReference y) -> int
NuGet.Packaging.FrameworkReference.CompareTo(NuGet.Packaging.FrameworkReference other) -> int
NuGet.Packaging.FrameworkReference.Equals(NuGet.Packaging.FrameworkReference other) -> bool
NuGet.Packaging.FrameworkReference.FrameworkReference(string name) -> void
NuGet.Packaging.FrameworkReference.Name.get -> string
NuGet.Packaging.FrameworkReferenceGroup
NuGet.Packaging.FrameworkReferenceGroup.Equals(NuGet.Packaging.FrameworkReferenceGroup other) -> bool
NuGet.Packaging.FrameworkReferenceGroup.FrameworkReferenceGroup(NuGet.Frameworks.NuGetFramework targetFramework, System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkReference> frameworkReferences) -> void
NuGet.Packaging.FrameworkReferenceGroup.FrameworkReferences.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkReference>
NuGet.Packaging.FrameworkReferenceGroup.TargetFramework.get -> NuGet.Frameworks.NuGetFramework
NuGet.Packaging.FrameworkSpecificGroup
NuGet.Packaging.FrameworkSpecificGroup.Equals(NuGet.Packaging.FrameworkSpecificGroup other) -> bool
NuGet.Packaging.FrameworkSpecificGroup.FrameworkSpecificGroup(NuGet.Frameworks.NuGetFramework targetFramework, System.Collections.Generic.IEnumerable<string> items) -> void
NuGet.Packaging.FrameworkSpecificGroup.HasEmptyFolder.get -> bool
NuGet.Packaging.FrameworkSpecificGroup.Items.get -> System.Collections.Generic.IEnumerable<string>
NuGet.Packaging.FrameworkSpecificGroup.TargetFramework.get -> NuGet.Frameworks.NuGetFramework
NuGet.Packaging.FrameworksExtensions
NuGet.Packaging.IAsyncPackageContentReader
NuGet.Packaging.IAsyncPackageContentReader.GetBuildItemsAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>>
NuGet.Packaging.IAsyncPackageContentReader.GetContentItemsAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>>
NuGet.Packaging.IAsyncPackageContentReader.GetFrameworkItemsAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>>
NuGet.Packaging.IAsyncPackageContentReader.GetLibItemsAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>>
NuGet.Packaging.IAsyncPackageContentReader.GetPackageDependenciesAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageDependencyGroup>>
NuGet.Packaging.IAsyncPackageContentReader.GetReferenceItemsAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>>
NuGet.Packaging.IAsyncPackageContentReader.GetToolItemsAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>>
NuGet.Packaging.IHashFunction
NuGet.Packaging.IHashFunction.GetHash() -> string
NuGet.Packaging.IHashFunction.Update(byte[] data, int offset, int count) -> void
NuGet.Packaging.INuspecReader
NuGet.Packaging.INuspecReader.GetDependencyGroups() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageDependencyGroup>
NuGet.Packaging.INuspecReader.GetFrameworkReferenceGroups() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
NuGet.Packaging.INuspecReader.GetLanguage() -> string
NuGet.Packaging.INuspecReader.GetReferenceGroups() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
NuGet.Packaging.IPackageContentReader
NuGet.Packaging.IPackageContentReader.GetBuildItems() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
NuGet.Packaging.IPackageContentReader.GetContentItems() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
NuGet.Packaging.IPackageContentReader.GetFrameworkItems() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
NuGet.Packaging.IPackageContentReader.GetLibItems() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
NuGet.Packaging.IPackageContentReader.GetPackageDependencies() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageDependencyGroup>
NuGet.Packaging.IPackageContentReader.GetReferenceItems() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
NuGet.Packaging.IPackageContentReader.GetToolItems() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
NuGet.Packaging.IPackageDownloader
NuGet.Packaging.IPackageDownloader.ContentReader.get -> NuGet.Packaging.IAsyncPackageContentReader
NuGet.Packaging.IPackageDownloader.CopyNupkgFileToAsync(string destinationFilePath, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>
NuGet.Packaging.IPackageDownloader.CoreReader.get -> NuGet.Packaging.Core.IAsyncPackageCoreReader
NuGet.Packaging.IPackageDownloader.GetPackageHashAsync(string hashAlgorithm, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<string>
NuGet.Packaging.IPackageDownloader.SetExceptionHandler(System.Func<System.Exception, System.Threading.Tasks.Task<bool>> handleExceptionAsync) -> void
NuGet.Packaging.IPackageDownloader.SetThrottle(System.Threading.SemaphoreSlim throttle) -> void
NuGet.Packaging.IPackageDownloader.SignedPackageReader.get -> NuGet.Packaging.Signing.ISignedPackageReader
NuGet.Packaging.IPackageDownloader.Source.get -> string
NuGet.Packaging.IPackageFile
NuGet.Packaging.IPackageFile.EffectivePath.get -> string
NuGet.Packaging.IPackageFile.GetStream() -> System.IO.Stream
NuGet.Packaging.IPackageFile.LastWriteTime.get -> System.DateTimeOffset
NuGet.Packaging.IPackageFile.NuGetFramework.get -> NuGet.Frameworks.NuGetFramework
NuGet.Packaging.IPackageFile.Path.get -> string
NuGet.Packaging.IPackageFile.TargetFramework.get -> System.Runtime.Versioning.FrameworkName
NuGet.Packaging.IPackageMetadata
NuGet.Packaging.IPackageMetadata.Authors.get -> System.Collections.Generic.IEnumerable<string>
NuGet.Packaging.IPackageMetadata.ContentFiles.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.ManifestContentFiles>
NuGet.Packaging.IPackageMetadata.Copyright.get -> string
NuGet.Packaging.IPackageMetadata.DependencyGroups.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageDependencyGroup>
NuGet.Packaging.IPackageMetadata.Description.get -> string
NuGet.Packaging.IPackageMetadata.DevelopmentDependency.get -> bool
NuGet.Packaging.IPackageMetadata.FrameworkReferenceGroups.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkReferenceGroup>
NuGet.Packaging.IPackageMetadata.FrameworkReferences.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkAssemblyReference>
NuGet.Packaging.IPackageMetadata.Icon.get -> string
NuGet.Packaging.IPackageMetadata.IconUrl.get -> System.Uri
NuGet.Packaging.IPackageMetadata.Id.get -> string
NuGet.Packaging.IPackageMetadata.Language.get -> string
NuGet.Packaging.IPackageMetadata.LicenseMetadata.get -> NuGet.Packaging.LicenseMetadata
NuGet.Packaging.IPackageMetadata.LicenseUrl.get -> System.Uri
NuGet.Packaging.IPackageMetadata.MinClientVersion.get -> System.Version
NuGet.Packaging.IPackageMetadata.Owners.get -> System.Collections.Generic.IEnumerable<string>
NuGet.Packaging.IPackageMetadata.PackageAssemblyReferences.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageReferenceSet>
NuGet.Packaging.IPackageMetadata.PackageTypes.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.PackageType>
NuGet.Packaging.IPackageMetadata.ProjectUrl.get -> System.Uri
NuGet.Packaging.IPackageMetadata.ReleaseNotes.get -> string
NuGet.Packaging.IPackageMetadata.Repository.get -> NuGet.Packaging.Core.RepositoryMetadata
NuGet.Packaging.IPackageMetadata.RequireLicenseAcceptance.get -> bool
NuGet.Packaging.IPackageMetadata.Serviceable.get -> bool
NuGet.Packaging.IPackageMetadata.Summary.get -> string
NuGet.Packaging.IPackageMetadata.Tags.get -> string
NuGet.Packaging.IPackageMetadata.Title.get -> string
NuGet.Packaging.IPackageMetadata.Version.get -> NuGet.Versioning.NuGetVersion
NuGet.Packaging.IPackageResolver
NuGet.Packaging.IPackageResolver.Resolve(System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.PackageIdentity> targets, System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.PackageDependencyInfo> availablePackages, System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageReference> installedPackages, System.Threading.CancellationToken token) -> System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.PackageIdentity>
NuGet.Packaging.IPackageResolver.Resolve(System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.PackageIdentity> targets, System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.PackageDependencyInfo> availablePackages, System.Threading.CancellationToken token) -> System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.PackageIdentity>
NuGet.Packaging.IPackageResolver.Resolve(System.Collections.Generic.IEnumerable<string> targets, System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.PackageDependencyInfo> availablePackages, System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageReference> installedPackages, System.Threading.CancellationToken token) -> System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.PackageIdentity>
NuGet.Packaging.IPackageResolver.Resolve(System.Collections.Generic.IEnumerable<string> targets, System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.PackageDependencyInfo> availablePackages, System.Threading.CancellationToken token) -> System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.PackageIdentity>
NuGet.Packaging.LicenseMetadata
NuGet.Packaging.LicenseMetadata.Equals(NuGet.Packaging.LicenseMetadata other) -> bool
NuGet.Packaging.LicenseMetadata.License.get -> string
NuGet.Packaging.LicenseMetadata.LicenseExpression.get -> NuGet.Packaging.Licenses.NuGetLicenseExpression
NuGet.Packaging.LicenseMetadata.LicenseMetadata(NuGet.Packaging.LicenseType type, string license, NuGet.Packaging.Licenses.NuGetLicenseExpression expression, System.Collections.Generic.IReadOnlyList<string> warningsAndErrors, System.Version version) -> void
NuGet.Packaging.LicenseMetadata.LicenseUrl.get -> System.Uri
NuGet.Packaging.LicenseMetadata.Type.get -> NuGet.Packaging.LicenseType
NuGet.Packaging.LicenseMetadata.Version.get -> System.Version
NuGet.Packaging.LicenseMetadata.WarningsAndErrors.get -> System.Collections.Generic.IReadOnlyList<string>
NuGet.Packaging.LicenseType
NuGet.Packaging.LicenseType.Expression = 1 -> NuGet.Packaging.LicenseType
NuGet.Packaging.LicenseType.File = 0 -> NuGet.Packaging.LicenseType
NuGet.Packaging.Licenses.ExceptionData
NuGet.Packaging.Licenses.ExceptionData.ExceptionData(string licenseID, bool isDeprecatedLicenseId) -> void
NuGet.Packaging.Licenses.ExceptionData.IsDeprecatedLicenseId.get -> bool
NuGet.Packaging.Licenses.ExceptionData.LicenseExceptionID.get -> string
NuGet.Packaging.Licenses.LicenseData
NuGet.Packaging.Licenses.LicenseData.IsDeprecatedLicenseId.get -> bool
NuGet.Packaging.Licenses.LicenseData.IsFsfLibre.get -> bool
NuGet.Packaging.Licenses.LicenseData.IsOsiApproved.get -> bool
NuGet.Packaging.Licenses.LicenseData.LicenseData(string licenseID, bool isOsiApproved, bool isDeprecatedLicenseId, bool isFsfLibre) -> void
NuGet.Packaging.Licenses.LicenseData.LicenseID.get -> string
NuGet.Packaging.Licenses.LicenseExpressionType
NuGet.Packaging.Licenses.LicenseExpressionType.License = 0 -> NuGet.Packaging.Licenses.LicenseExpressionType
NuGet.Packaging.Licenses.LicenseExpressionType.Operator = 1 -> NuGet.Packaging.Licenses.LicenseExpressionType
NuGet.Packaging.Licenses.LicenseOperator
NuGet.Packaging.Licenses.LicenseOperator.LicenseOperator(NuGet.Packaging.Licenses.LicenseOperatorType operatorType) -> void
NuGet.Packaging.Licenses.LicenseOperator.OperatorType.get -> NuGet.Packaging.Licenses.LicenseOperatorType
NuGet.Packaging.Licenses.LicenseOperatorType
NuGet.Packaging.Licenses.LicenseOperatorType.LogicalOperator = 1 -> NuGet.Packaging.Licenses.LicenseOperatorType
NuGet.Packaging.Licenses.LicenseOperatorType.WithOperator = 0 -> NuGet.Packaging.Licenses.LicenseOperatorType
NuGet.Packaging.Licenses.LogicalOperator
NuGet.Packaging.Licenses.LogicalOperator.Left.get -> NuGet.Packaging.Licenses.NuGetLicenseExpression
NuGet.Packaging.Licenses.LogicalOperator.LogicalOperator(NuGet.Packaging.Licenses.LogicalOperatorType logicalOperatorType, NuGet.Packaging.Licenses.NuGetLicenseExpression left, NuGet.Packaging.Licenses.NuGetLicenseExpression right) -> void
NuGet.Packaging.Licenses.LogicalOperator.LogicalOperatorType.get -> NuGet.Packaging.Licenses.LogicalOperatorType
NuGet.Packaging.Licenses.LogicalOperator.Right.get -> NuGet.Packaging.Licenses.NuGetLicenseExpression
NuGet.Packaging.Licenses.LogicalOperatorType
NuGet.Packaging.Licenses.LogicalOperatorType.And = 0 -> NuGet.Packaging.Licenses.LogicalOperatorType
NuGet.Packaging.Licenses.LogicalOperatorType.Or = 1 -> NuGet.Packaging.Licenses.LogicalOperatorType
NuGet.Packaging.Licenses.NuGetLicense
NuGet.Packaging.Licenses.NuGetLicense.Identifier.get -> string
NuGet.Packaging.Licenses.NuGetLicense.IsStandardLicense.get -> bool
NuGet.Packaging.Licenses.NuGetLicense.Plus.get -> bool
NuGet.Packaging.Licenses.NuGetLicenseData
NuGet.Packaging.Licenses.NuGetLicenseData.NuGetLicenseData() -> void
NuGet.Packaging.Licenses.NuGetLicenseException
NuGet.Packaging.Licenses.NuGetLicenseException.Identifier.get -> string
NuGet.Packaging.Licenses.NuGetLicenseExpression
NuGet.Packaging.Licenses.NuGetLicenseExpression.NuGetLicenseExpression() -> void
NuGet.Packaging.Licenses.NuGetLicenseExpression.Type.get -> NuGet.Packaging.Licenses.LicenseExpressionType
NuGet.Packaging.Licenses.NuGetLicenseExpression.Type.set -> void
NuGet.Packaging.Licenses.NuGetLicenseExpressionExtensions
NuGet.Packaging.Licenses.NuGetLicenseExpressionParsingException
NuGet.Packaging.Licenses.NuGetLicenseExpressionParsingException.NuGetLicenseExpressionParsingException(string message) -> void
NuGet.Packaging.Licenses.NuGetLicenseExpressionParsingException.NuGetLicenseExpressionParsingException(string message, System.Exception innerException) -> void
NuGet.Packaging.Licenses.WithOperator
NuGet.Packaging.Licenses.WithOperator.Exception.get -> NuGet.Packaging.Licenses.NuGetLicenseException
NuGet.Packaging.Licenses.WithOperator.License.get -> NuGet.Packaging.Licenses.NuGetLicense
NuGet.Packaging.Licenses.WithOperator.WithOperator(NuGet.Packaging.Licenses.NuGetLicense license, NuGet.Packaging.Licenses.NuGetLicenseException exception) -> void
NuGet.Packaging.LocalPackageArchiveDownloader
NuGet.Packaging.LocalPackageArchiveDownloader.ContentReader.get -> NuGet.Packaging.IAsyncPackageContentReader
NuGet.Packaging.LocalPackageArchiveDownloader.CopyNupkgFileToAsync(string destinationFilePath, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>
NuGet.Packaging.LocalPackageArchiveDownloader.CoreReader.get -> NuGet.Packaging.Core.IAsyncPackageCoreReader
NuGet.Packaging.LocalPackageArchiveDownloader.Dispose() -> void
NuGet.Packaging.LocalPackageArchiveDownloader.GetPackageHashAsync(string hashAlgorithm, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<string>
NuGet.Packaging.LocalPackageArchiveDownloader.LocalPackageArchiveDownloader(string source, string packageFilePath, NuGet.Packaging.Core.PackageIdentity packageIdentity, NuGet.Common.ILogger logger) -> void
NuGet.Packaging.LocalPackageArchiveDownloader.SetExceptionHandler(System.Func<System.Exception, System.Threading.Tasks.Task<bool>> handleExceptionAsync) -> void
NuGet.Packaging.LocalPackageArchiveDownloader.SetThrottle(System.Threading.SemaphoreSlim throttle) -> void
NuGet.Packaging.LocalPackageArchiveDownloader.SignedPackageReader.get -> NuGet.Packaging.Signing.ISignedPackageReader
NuGet.Packaging.LocalPackageArchiveDownloader.Source.get -> string
NuGet.Packaging.Manifest
NuGet.Packaging.Manifest.Files.get -> System.Collections.Generic.ICollection<NuGet.Packaging.ManifestFile>
NuGet.Packaging.Manifest.HasFilesNode.get -> bool
NuGet.Packaging.Manifest.Manifest(NuGet.Packaging.ManifestMetadata metadata) -> void
NuGet.Packaging.Manifest.Manifest(NuGet.Packaging.ManifestMetadata metadata, System.Collections.Generic.ICollection<NuGet.Packaging.ManifestFile> files) -> void
NuGet.Packaging.Manifest.Metadata.get -> NuGet.Packaging.ManifestMetadata
NuGet.Packaging.Manifest.Save(System.IO.Stream stream) -> void
NuGet.Packaging.Manifest.Save(System.IO.Stream stream, bool generateBackwardsCompatible) -> void
NuGet.Packaging.Manifest.Save(System.IO.Stream stream, int minimumManifestVersion) -> void
NuGet.Packaging.Manifest.Save(System.IO.Stream stream, int minimumManifestVersion, bool generateBackwardsCompatible) -> void
NuGet.Packaging.ManifestContentFiles
NuGet.Packaging.ManifestContentFiles.BuildAction.get -> string
NuGet.Packaging.ManifestContentFiles.BuildAction.set -> void
NuGet.Packaging.ManifestContentFiles.CopyToOutput.get -> string
NuGet.Packaging.ManifestContentFiles.CopyToOutput.set -> void
NuGet.Packaging.ManifestContentFiles.Exclude.get -> string
NuGet.Packaging.ManifestContentFiles.Exclude.set -> void
NuGet.Packaging.ManifestContentFiles.Flatten.get -> string
NuGet.Packaging.ManifestContentFiles.Flatten.set -> void
NuGet.Packaging.ManifestContentFiles.Include.get -> string
NuGet.Packaging.ManifestContentFiles.Include.set -> void
NuGet.Packaging.ManifestContentFiles.ManifestContentFiles() -> void
NuGet.Packaging.ManifestFile
NuGet.Packaging.ManifestFile.Exclude.get -> string
NuGet.Packaging.ManifestFile.Exclude.set -> void
NuGet.Packaging.ManifestFile.ManifestFile() -> void
NuGet.Packaging.ManifestFile.Source.get -> string
NuGet.Packaging.ManifestFile.Source.set -> void
NuGet.Packaging.ManifestFile.Target.get -> string
NuGet.Packaging.ManifestFile.Target.set -> void
NuGet.Packaging.ManifestFile.Validate() -> System.Collections.Generic.IEnumerable<string>
NuGet.Packaging.ManifestMetadata
NuGet.Packaging.ManifestMetadata.Authors.get -> System.Collections.Generic.IEnumerable<string>
NuGet.Packaging.ManifestMetadata.Authors.set -> void
NuGet.Packaging.ManifestMetadata.ContentFiles.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.ManifestContentFiles>
NuGet.Packaging.ManifestMetadata.ContentFiles.set -> void
NuGet.Packaging.ManifestMetadata.Copyright.get -> string
NuGet.Packaging.ManifestMetadata.Copyright.set -> void
NuGet.Packaging.ManifestMetadata.DependencyGroups.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageDependencyGroup>
NuGet.Packaging.ManifestMetadata.DependencyGroups.set -> void
NuGet.Packaging.ManifestMetadata.Description.get -> string
NuGet.Packaging.ManifestMetadata.Description.set -> void
NuGet.Packaging.ManifestMetadata.DevelopmentDependency.get -> bool
NuGet.Packaging.ManifestMetadata.DevelopmentDependency.set -> void
NuGet.Packaging.ManifestMetadata.FrameworkReferenceGroups.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkReferenceGroup>
NuGet.Packaging.ManifestMetadata.FrameworkReferenceGroups.set -> void
NuGet.Packaging.ManifestMetadata.FrameworkReferences.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkAssemblyReference>
NuGet.Packaging.ManifestMetadata.FrameworkReferences.set -> void
NuGet.Packaging.ManifestMetadata.Icon.get -> string
NuGet.Packaging.ManifestMetadata.Icon.set -> void
NuGet.Packaging.ManifestMetadata.IconUrl.get -> System.Uri
NuGet.Packaging.ManifestMetadata.Id.get -> string
NuGet.Packaging.ManifestMetadata.Id.set -> void
NuGet.Packaging.ManifestMetadata.Language.get -> string
NuGet.Packaging.ManifestMetadata.Language.set -> void
NuGet.Packaging.ManifestMetadata.LicenseMetadata.get -> NuGet.Packaging.LicenseMetadata
NuGet.Packaging.ManifestMetadata.LicenseMetadata.set -> void
NuGet.Packaging.ManifestMetadata.LicenseUrl.get -> System.Uri
NuGet.Packaging.ManifestMetadata.ManifestMetadata() -> void
NuGet.Packaging.ManifestMetadata.ManifestMetadata(NuGet.Packaging.IPackageMetadata copy) -> void
NuGet.Packaging.ManifestMetadata.MinClientVersion.get -> System.Version
NuGet.Packaging.ManifestMetadata.MinClientVersionString.get -> string
NuGet.Packaging.ManifestMetadata.MinClientVersionString.set -> void
NuGet.Packaging.ManifestMetadata.Owners.get -> System.Collections.Generic.IEnumerable<string>
NuGet.Packaging.ManifestMetadata.Owners.set -> void
NuGet.Packaging.ManifestMetadata.PackageAssemblyReferences.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageReferenceSet>
NuGet.Packaging.ManifestMetadata.PackageAssemblyReferences.set -> void
NuGet.Packaging.ManifestMetadata.PackageTypes.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.PackageType>
NuGet.Packaging.ManifestMetadata.PackageTypes.set -> void
NuGet.Packaging.ManifestMetadata.ProjectUrl.get -> System.Uri
NuGet.Packaging.ManifestMetadata.ReleaseNotes.get -> string
NuGet.Packaging.ManifestMetadata.ReleaseNotes.set -> void
NuGet.Packaging.ManifestMetadata.Repository.get -> NuGet.Packaging.Core.RepositoryMetadata
NuGet.Packaging.ManifestMetadata.Repository.set -> void
NuGet.Packaging.ManifestMetadata.RequireLicenseAcceptance.get -> bool
NuGet.Packaging.ManifestMetadata.RequireLicenseAcceptance.set -> void
NuGet.Packaging.ManifestMetadata.Serviceable.get -> bool
NuGet.Packaging.ManifestMetadata.Serviceable.set -> void
NuGet.Packaging.ManifestMetadata.SetIconUrl(string iconUrl) -> void
NuGet.Packaging.ManifestMetadata.SetLicenseUrl(string licenseUrl) -> void
NuGet.Packaging.ManifestMetadata.SetProjectUrl(string projectUrl) -> void
NuGet.Packaging.ManifestMetadata.Summary.get -> string
NuGet.Packaging.ManifestMetadata.Summary.set -> void
NuGet.Packaging.ManifestMetadata.Tags.get -> string
NuGet.Packaging.ManifestMetadata.Tags.set -> void
NuGet.Packaging.ManifestMetadata.Title.get -> string
NuGet.Packaging.ManifestMetadata.Title.set -> void
NuGet.Packaging.ManifestMetadata.Validate() -> System.Collections.Generic.IEnumerable<string>
NuGet.Packaging.ManifestMetadata.Version.get -> NuGet.Versioning.NuGetVersion
NuGet.Packaging.ManifestMetadata.Version.set -> void
NuGet.Packaging.ManifestSchemaUtility
NuGet.Packaging.ManifestVersionUtility
NuGet.Packaging.MinClientVersionException
NuGet.Packaging.MinClientVersionException.MinClientVersionException(string message) -> void
NuGet.Packaging.MinClientVersionUtility
NuGet.Packaging.NupkgMetadataFile
NuGet.Packaging.NupkgMetadataFile.ContentHash.get -> string
NuGet.Packaging.NupkgMetadataFile.ContentHash.set -> void
NuGet.Packaging.NupkgMetadataFile.Equals(NuGet.Packaging.NupkgMetadataFile other) -> bool
NuGet.Packaging.NupkgMetadataFile.NupkgMetadataFile() -> void
NuGet.Packaging.NupkgMetadataFile.Version.get -> int
NuGet.Packaging.NupkgMetadataFile.Version.set -> void
NuGet.Packaging.NupkgMetadataFileFormat
NuGet.Packaging.NupkgMetadataFileFormat.NupkgMetadataFileFormat() -> void
NuGet.Packaging.NuspecReader
NuGet.Packaging.NuspecReader.GetAuthors() -> string
NuGet.Packaging.NuspecReader.GetContentFiles() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.ContentFilesEntry>
NuGet.Packaging.NuspecReader.GetCopyright() -> string
NuGet.Packaging.NuspecReader.GetDependencyGroups() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageDependencyGroup>
NuGet.Packaging.NuspecReader.GetDependencyGroups(bool useStrictVersionCheck) -> System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageDependencyGroup>
NuGet.Packaging.NuspecReader.GetDescription() -> string
NuGet.Packaging.NuspecReader.GetFrameworkAssemblyGroups() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
NuGet.Packaging.NuspecReader.GetFrameworkRefGroups() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkReferenceGroup>
NuGet.Packaging.NuspecReader.GetFrameworkReferenceGroups() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
NuGet.Packaging.NuspecReader.GetIcon() -> string
NuGet.Packaging.NuspecReader.GetIconUrl() -> string
NuGet.Packaging.NuspecReader.GetLanguage() -> string
NuGet.Packaging.NuspecReader.GetLicenseMetadata() -> NuGet.Packaging.LicenseMetadata
NuGet.Packaging.NuspecReader.GetLicenseUrl() -> string
NuGet.Packaging.NuspecReader.GetOwners() -> string
NuGet.Packaging.NuspecReader.GetProjectUrl() -> string
NuGet.Packaging.NuspecReader.GetReferenceGroups() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
NuGet.Packaging.NuspecReader.GetReleaseNotes() -> string
NuGet.Packaging.NuspecReader.GetRepositoryMetadata() -> NuGet.Packaging.Core.RepositoryMetadata
NuGet.Packaging.NuspecReader.GetRequireLicenseAcceptance() -> bool
NuGet.Packaging.NuspecReader.GetSummary() -> string
NuGet.Packaging.NuspecReader.GetTags() -> string
NuGet.Packaging.NuspecReader.GetTitle() -> string
NuGet.Packaging.NuspecReader.NuspecReader(System.IO.Stream stream) -> void
NuGet.Packaging.NuspecReader.NuspecReader(System.IO.Stream stream, NuGet.Frameworks.IFrameworkNameProvider frameworkProvider, bool leaveStreamOpen) -> void
NuGet.Packaging.NuspecReader.NuspecReader(System.Xml.Linq.XDocument xml) -> void
NuGet.Packaging.NuspecReader.NuspecReader(System.Xml.Linq.XDocument xml, NuGet.Frameworks.IFrameworkNameProvider frameworkProvider) -> void
NuGet.Packaging.NuspecReader.NuspecReader(string path) -> void
NuGet.Packaging.NuspecReader.NuspecReader(string path, NuGet.Frameworks.IFrameworkNameProvider frameworkProvider) -> void
NuGet.Packaging.PackageArchiveReader
NuGet.Packaging.PackageArchiveReader.EnumeratePackageEntries(System.Collections.Generic.IEnumerable<string> packageFiles, string packageDirectory) -> System.Collections.Generic.IEnumerable<NuGet.Packaging.ZipFilePair>
NuGet.Packaging.PackageArchiveReader.ExtractFile(string packageFile, string targetFilePath, NuGet.Common.ILogger logger) -> string
NuGet.Packaging.PackageArchiveReader.GetEntry(string packageFile) -> System.IO.Compression.ZipArchiveEntry
NuGet.Packaging.PackageArchiveReader.PackageArchiveReader(System.IO.Compression.ZipArchive zipArchive) -> void
NuGet.Packaging.PackageArchiveReader.PackageArchiveReader(System.IO.Compression.ZipArchive zipArchive, NuGet.Frameworks.IFrameworkNameProvider frameworkProvider, NuGet.Frameworks.IFrameworkCompatibilityProvider compatibilityProvider) -> void
NuGet.Packaging.PackageArchiveReader.PackageArchiveReader(System.IO.Stream stream) -> void
NuGet.Packaging.PackageArchiveReader.PackageArchiveReader(System.IO.Stream stream, NuGet.Frameworks.IFrameworkNameProvider frameworkProvider, NuGet.Frameworks.IFrameworkCompatibilityProvider compatibilityProvider) -> void
NuGet.Packaging.PackageArchiveReader.PackageArchiveReader(System.IO.Stream stream, bool leaveStreamOpen) -> void
NuGet.Packaging.PackageArchiveReader.PackageArchiveReader(System.IO.Stream stream, bool leaveStreamOpen, NuGet.Frameworks.IFrameworkNameProvider frameworkProvider, NuGet.Frameworks.IFrameworkCompatibilityProvider compatibilityProvider) -> void
NuGet.Packaging.PackageArchiveReader.PackageArchiveReader(string filePath, NuGet.Frameworks.IFrameworkNameProvider frameworkProvider = null, NuGet.Frameworks.IFrameworkCompatibilityProvider compatibilityProvider = null) -> void
NuGet.Packaging.PackageArchiveReader.SigningSpecifications.get -> NuGet.Packaging.Signing.SigningSpecifications
NuGet.Packaging.PackageArchiveReader.ThrowIfZipReadStreamIsNull() -> void
NuGet.Packaging.PackageArchiveReader.ValidatePackageEntriesAsync(System.Threading.CancellationToken token) -> System.Threading.Tasks.Task
NuGet.Packaging.PackageArchiveReader.ZipReadStream.get -> System.IO.Stream
NuGet.Packaging.PackageArchiveReader.ZipReadStream.set -> void
NuGet.Packaging.PackageBuilder
NuGet.Packaging.PackageBuilder.AddFiles(string basePath, string source, string destination, string exclude = null) -> void
NuGet.Packaging.PackageBuilder.Authors.get -> System.Collections.Generic.ISet<string>
NuGet.Packaging.PackageBuilder.ContentFiles.get -> System.Collections.Generic.ICollection<NuGet.Packaging.ManifestContentFiles>
NuGet.Packaging.PackageBuilder.Copyright.get -> string
NuGet.Packaging.PackageBuilder.Copyright.set -> void
NuGet.Packaging.PackageBuilder.DependencyGroups.get -> System.Collections.ObjectModel.Collection<NuGet.Packaging.PackageDependencyGroup>
NuGet.Packaging.PackageBuilder.Description.get -> string
NuGet.Packaging.PackageBuilder.Description.set -> void
NuGet.Packaging.PackageBuilder.DevelopmentDependency.get -> bool
NuGet.Packaging.PackageBuilder.DevelopmentDependency.set -> void
NuGet.Packaging.PackageBuilder.Files.get -> System.Collections.Generic.ICollection<NuGet.Packaging.IPackageFile>
NuGet.Packaging.PackageBuilder.FrameworkReferenceGroups.get -> System.Collections.ObjectModel.Collection<NuGet.Packaging.FrameworkReferenceGroup>
NuGet.Packaging.PackageBuilder.FrameworkReferences.get -> System.Collections.ObjectModel.Collection<NuGet.Packaging.FrameworkAssemblyReference>
NuGet.Packaging.PackageBuilder.HasSnapshotVersion.get -> bool
NuGet.Packaging.PackageBuilder.HasSnapshotVersion.set -> void
NuGet.Packaging.PackageBuilder.Icon.get -> string
NuGet.Packaging.PackageBuilder.Icon.set -> void
NuGet.Packaging.PackageBuilder.IconUrl.get -> System.Uri
NuGet.Packaging.PackageBuilder.IconUrl.set -> void
NuGet.Packaging.PackageBuilder.Id.get -> string
NuGet.Packaging.PackageBuilder.Id.set -> void
NuGet.Packaging.PackageBuilder.Language.get -> string
NuGet.Packaging.PackageBuilder.Language.set -> void
NuGet.Packaging.PackageBuilder.LicenseMetadata.get -> NuGet.Packaging.LicenseMetadata
NuGet.Packaging.PackageBuilder.LicenseMetadata.set -> void
NuGet.Packaging.PackageBuilder.LicenseUrl.get -> System.Uri
NuGet.Packaging.PackageBuilder.LicenseUrl.set -> void
NuGet.Packaging.PackageBuilder.MinClientVersion.get -> System.Version
NuGet.Packaging.PackageBuilder.MinClientVersion.set -> void
NuGet.Packaging.PackageBuilder.OutputName.get -> string
NuGet.Packaging.PackageBuilder.OutputName.set -> void
NuGet.Packaging.PackageBuilder.Owners.get -> System.Collections.Generic.ISet<string>
NuGet.Packaging.PackageBuilder.PackageAssemblyReferences.get -> System.Collections.Generic.ICollection<NuGet.Packaging.PackageReferenceSet>
NuGet.Packaging.PackageBuilder.PackageAssemblyReferences.set -> void
NuGet.Packaging.PackageBuilder.PackageBuilder() -> void
NuGet.Packaging.PackageBuilder.PackageBuilder(System.IO.Stream stream, string basePath) -> void
NuGet.Packaging.PackageBuilder.PackageBuilder(System.IO.Stream stream, string basePath, System.Func<string, string> propertyProvider) -> void
NuGet.Packaging.PackageBuilder.PackageBuilder(bool deterministic) -> void
NuGet.Packaging.PackageBuilder.PackageBuilder(string path, System.Func<string, string> propertyProvider, bool includeEmptyDirectories) -> void
NuGet.Packaging.PackageBuilder.PackageBuilder(string path, System.Func<string, string> propertyProvider, bool includeEmptyDirectories, bool deterministic) -> void
NuGet.Packaging.PackageBuilder.PackageBuilder(string path, string basePath, System.Func<string, string> propertyProvider, bool includeEmptyDirectories) -> void
NuGet.Packaging.PackageBuilder.PackageBuilder(string path, string basePath, System.Func<string, string> propertyProvider, bool includeEmptyDirectories, bool deterministic) -> void
NuGet.Packaging.PackageBuilder.PackageTypes.get -> System.Collections.Generic.ICollection<NuGet.Packaging.Core.PackageType>
NuGet.Packaging.PackageBuilder.PackageTypes.set -> void
NuGet.Packaging.PackageBuilder.Populate(NuGet.Packaging.ManifestMetadata manifestMetadata) -> void
NuGet.Packaging.PackageBuilder.PopulateFiles(string basePath, System.Collections.Generic.IEnumerable<NuGet.Packaging.ManifestFile> files) -> void
NuGet.Packaging.PackageBuilder.ProjectUrl.get -> System.Uri
NuGet.Packaging.PackageBuilder.ProjectUrl.set -> void
NuGet.Packaging.PackageBuilder.Properties.get -> System.Collections.Generic.Dictionary<string, string>
NuGet.Packaging.PackageBuilder.ReleaseNotes.get -> string
NuGet.Packaging.PackageBuilder.ReleaseNotes.set -> void
NuGet.Packaging.PackageBuilder.Repository.get -> NuGet.Packaging.Core.RepositoryMetadata
NuGet.Packaging.PackageBuilder.Repository.set -> void
NuGet.Packaging.PackageBuilder.RequireLicenseAcceptance.get -> bool
NuGet.Packaging.PackageBuilder.RequireLicenseAcceptance.set -> void
NuGet.Packaging.PackageBuilder.Save(System.IO.Stream stream) -> void
NuGet.Packaging.PackageBuilder.Serviceable.get -> bool
NuGet.Packaging.PackageBuilder.Serviceable.set -> void
NuGet.Packaging.PackageBuilder.Summary.get -> string
NuGet.Packaging.PackageBuilder.Summary.set -> void
NuGet.Packaging.PackageBuilder.Tags.get -> System.Collections.Generic.ISet<string>
NuGet.Packaging.PackageBuilder.TargetFrameworks.get -> System.Collections.Generic.IList<NuGet.Frameworks.NuGetFramework>
NuGet.Packaging.PackageBuilder.TargetFrameworks.set -> void
NuGet.Packaging.PackageBuilder.Title.get -> string
NuGet.Packaging.PackageBuilder.Title.set -> void
NuGet.Packaging.PackageBuilder.Version.get -> NuGet.Versioning.NuGetVersion
NuGet.Packaging.PackageBuilder.Version.set -> void
NuGet.Packaging.PackageDependencyGroup
NuGet.Packaging.PackageDependencyGroup.Equals(NuGet.Packaging.PackageDependencyGroup other) -> bool
NuGet.Packaging.PackageDependencyGroup.PackageDependencyGroup(NuGet.Frameworks.NuGetFramework targetFramework, System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.PackageDependency> packages) -> void
NuGet.Packaging.PackageDependencyGroup.Packages.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.PackageDependency>
NuGet.Packaging.PackageDependencyGroup.TargetFramework.get -> NuGet.Frameworks.NuGetFramework
NuGet.Packaging.PackageExtraction.PackageExtractionBehavior
NuGet.Packaging.PackageExtractionContext
NuGet.Packaging.PackageExtractionContext.ClientPolicyContext.get -> NuGet.Packaging.Signing.ClientPolicyContext
NuGet.Packaging.PackageExtractionContext.CopySatelliteFiles.get -> bool
NuGet.Packaging.PackageExtractionContext.CopySatelliteFiles.set -> void
NuGet.Packaging.PackageExtractionContext.Logger.get -> NuGet.Common.ILogger
NuGet.Packaging.PackageExtractionContext.PackageExtractionContext(NuGet.Packaging.PackageSaveMode packageSaveMode, NuGet.Packaging.XmlDocFileSaveMode xmlDocFileSaveMode, NuGet.Packaging.Signing.ClientPolicyContext clientPolicyContext, NuGet.Common.ILogger logger) -> void
NuGet.Packaging.PackageExtractionContext.PackageSaveMode.get -> NuGet.Packaging.PackageSaveMode
NuGet.Packaging.PackageExtractionContext.PackageSaveMode.set -> void
NuGet.Packaging.PackageExtractionContext.SignedPackageVerifier.get -> NuGet.Packaging.Signing.IPackageSignatureVerifier
NuGet.Packaging.PackageExtractionContext.SignedPackageVerifier.set -> void
NuGet.Packaging.PackageExtractionContext.XmlDocFileSaveMode.get -> NuGet.Packaging.XmlDocFileSaveMode
NuGet.Packaging.PackageExtractionContext.XmlDocFileSaveMode.set -> void
NuGet.Packaging.PackageExtractionResult
NuGet.Packaging.PackageExtractionResult.Cached.get -> bool
NuGet.Packaging.PackageExtractionResult.Duration.get -> System.TimeSpan
NuGet.Packaging.PackageExtractionResult.Duration.set -> void
NuGet.Packaging.PackageExtractionResult.PackageExtractionResult(bool cached, System.TimeSpan signVerifyDelay, NuGet.Packaging.PackageSignType packageType, bool success, System.DateTimeOffset signVerifyStartTime, System.DateTimeOffset signVerifyEndTime) -> void
NuGet.Packaging.PackageExtractionResult.PackageExtractionResult(bool cached, System.TimeSpan signVerifyDelay, NuGet.Packaging.PackageSignType packageType, bool success, System.TimeSpan duration) -> void
NuGet.Packaging.PackageExtractionResult.PackageType.get -> NuGet.Packaging.PackageSignType
NuGet.Packaging.PackageExtractionResult.SignVerifyDelay.get -> System.TimeSpan
NuGet.Packaging.PackageExtractionResult.SignVerifyEndTime.get -> System.DateTimeOffset
NuGet.Packaging.PackageExtractionResult.SignVerifyStartTime.get -> System.DateTimeOffset
NuGet.Packaging.PackageExtractionResult.Success.get -> bool
NuGet.Packaging.PackageExtractionTelemetryEvent
NuGet.Packaging.PackageExtractionTelemetryEvent.ExtractionSource.get -> NuGet.Packaging.ExtractionSource
NuGet.Packaging.PackageExtractionTelemetryEvent.LogPackageIdentity(NuGet.Packaging.Core.PackageIdentity packageId) -> void
NuGet.Packaging.PackageExtractionTelemetryEvent.PackageExtractionTelemetryEvent(NuGet.Packaging.PackageSaveMode packageSaveMode, NuGet.Common.NuGetOperationStatus status, NuGet.Packaging.ExtractionSource extractionSource, NuGet.Packaging.Core.PackageIdentity packageId = null) -> void
NuGet.Packaging.PackageExtractionTelemetryEvent.PackageId.get -> string
NuGet.Packaging.PackageExtractionTelemetryEvent.PackageSaveMode.get -> NuGet.Packaging.PackageSaveMode
NuGet.Packaging.PackageExtractionTelemetryEvent.PackageVersion.get -> string
NuGet.Packaging.PackageExtractionTelemetryEvent.SetResult(NuGet.Common.NuGetOperationStatus status) -> void
NuGet.Packaging.PackageExtractionTelemetryEvent.Status.get -> NuGet.Common.NuGetOperationStatus
NuGet.Packaging.PackageExtractor
NuGet.Packaging.PackageFileExtractor
NuGet.Packaging.PackageFileExtractor.ExtractPackageFile(string source, string target, System.IO.Stream stream) -> string
NuGet.Packaging.PackageFileExtractor.PackageFileExtractor(System.Collections.Generic.IEnumerable<string> packageFiles, NuGet.Packaging.XmlDocFileSaveMode xmlDocFileSaveMode) -> void
NuGet.Packaging.PackageFolderReader
NuGet.Packaging.PackageFolderReader.PackageFolderReader(System.IO.DirectoryInfo folder) -> void
NuGet.Packaging.PackageFolderReader.PackageFolderReader(System.IO.DirectoryInfo folder, NuGet.Frameworks.IFrameworkNameProvider frameworkProvider, NuGet.Frameworks.IFrameworkCompatibilityProvider compatibilityProvider) -> void
NuGet.Packaging.PackageFolderReader.PackageFolderReader(string folderPath) -> void
NuGet.Packaging.PackageFolderReader.PackageFolderReader(string folderPath, NuGet.Frameworks.IFrameworkNameProvider frameworkProvider, NuGet.Frameworks.IFrameworkCompatibilityProvider compatibilityProvider) -> void
NuGet.Packaging.PackageHelper
NuGet.Packaging.PackageIdValidator
NuGet.Packaging.PackagePathHelper
NuGet.Packaging.PackagePathResolver
NuGet.Packaging.PackagePathResolver.GetManifestFileName(NuGet.Packaging.Core.PackageIdentity packageIdentity) -> string
NuGet.Packaging.PackagePathResolver.GetPackageDownloadMarkerFileName(NuGet.Packaging.Core.PackageIdentity packageIdentity) -> string
NuGet.Packaging.PackagePathResolver.PackagePathResolver(string rootDirectory, bool useSideBySidePaths = true) -> void
NuGet.Packaging.PackagePathResolver.Root.get -> string
NuGet.Packaging.PackagePathResolver.UseSideBySidePaths.get -> bool
NuGet.Packaging.PackageReaderBase
NuGet.Packaging.PackageReaderBase.CompatibilityProvider.get -> NuGet.Frameworks.IFrameworkCompatibilityProvider
NuGet.Packaging.PackageReaderBase.CompatibilityProvider.set -> void
NuGet.Packaging.PackageReaderBase.Dispose() -> void
NuGet.Packaging.PackageReaderBase.FrameworkProvider.get -> NuGet.Frameworks.IFrameworkNameProvider
NuGet.Packaging.PackageReaderBase.FrameworkProvider.set -> void
NuGet.Packaging.PackageReaderBase.GetFileGroups(string folder) -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
NuGet.Packaging.PackageReaderBase.GetFrameworkFromPath(string path, bool allowSubFolders = false) -> NuGet.Frameworks.NuGetFramework
NuGet.Packaging.PackageReaderBase.NormalizeDirectoryPath(string path) -> string
NuGet.Packaging.PackageReaderBase.PackageReaderBase(NuGet.Frameworks.IFrameworkNameProvider frameworkProvider) -> void
NuGet.Packaging.PackageReaderBase.PackageReaderBase(NuGet.Frameworks.IFrameworkNameProvider frameworkProvider, NuGet.Frameworks.IFrameworkCompatibilityProvider compatibilityProvider) -> void
NuGet.Packaging.PackageReaderExtensions
NuGet.Packaging.PackageReference
NuGet.Packaging.PackageReference.AllowedVersions.get -> NuGet.Versioning.VersionRange
NuGet.Packaging.PackageReference.HasAllowedVersions.get -> bool
NuGet.Packaging.PackageReference.IsDevelopmentDependency.get -> bool
NuGet.Packaging.PackageReference.IsUserInstalled.get -> bool
NuGet.Packaging.PackageReference.PackageIdentity.get -> NuGet.Packaging.Core.PackageIdentity
NuGet.Packaging.PackageReference.PackageReference(NuGet.Packaging.Core.PackageIdentity identity, NuGet.Frameworks.NuGetFramework targetFramework) -> void
NuGet.Packaging.PackageReference.PackageReference(NuGet.Packaging.Core.PackageIdentity identity, NuGet.Frameworks.NuGetFramework targetFramework, bool userInstalled) -> void
NuGet.Packaging.PackageReference.PackageReference(NuGet.Packaging.Core.PackageIdentity identity, NuGet.Frameworks.NuGetFramework targetFramework, bool userInstalled, bool developmentDependency, bool requireReinstallation) -> void
NuGet.Packaging.PackageReference.PackageReference(NuGet.Packaging.Core.PackageIdentity identity, NuGet.Frameworks.NuGetFramework targetFramework, bool userInstalled, bool developmentDependency, bool requireReinstallation, NuGet.Versioning.VersionRange allowedVersions) -> void
NuGet.Packaging.PackageReference.RequireReinstallation.get -> bool
NuGet.Packaging.PackageReference.TargetFramework.get -> NuGet.Frameworks.NuGetFramework
NuGet.Packaging.PackageReferenceSet
NuGet.Packaging.PackageReferenceSet.PackageReferenceSet(NuGet.Frameworks.NuGetFramework targetFramework, System.Collections.Generic.IEnumerable<string> references) -> void
NuGet.Packaging.PackageReferenceSet.PackageReferenceSet(System.Collections.Generic.IEnumerable<string> references) -> void
NuGet.Packaging.PackageReferenceSet.PackageReferenceSet(string targetFramework, System.Collections.Generic.IEnumerable<string> references) -> void
NuGet.Packaging.PackageReferenceSet.References.get -> System.Collections.Generic.IReadOnlyCollection<string>
NuGet.Packaging.PackageReferenceSet.TargetFramework.get -> NuGet.Frameworks.NuGetFramework
NuGet.Packaging.PackageReferenceSet.Validate() -> System.Collections.Generic.IEnumerable<string>
NuGet.Packaging.PackageSaveMode
NuGet.Packaging.PackageSaveMode.Defaultv2 = NuGet.Packaging.PackageSaveMode.Nupkg | NuGet.Packaging.PackageSaveMode.Files -> NuGet.Packaging.PackageSaveMode
NuGet.Packaging.PackageSaveMode.Defaultv3 = NuGet.Packaging.PackageSaveMode.Nuspec | NuGet.Packaging.PackageSaveMode.Defaultv2 -> NuGet.Packaging.PackageSaveMode
NuGet.Packaging.PackageSaveMode.Files = 4 -> NuGet.Packaging.PackageSaveMode
NuGet.Packaging.PackageSaveMode.None = 0 -> NuGet.Packaging.PackageSaveMode
NuGet.Packaging.PackageSaveMode.Nupkg = 2 -> NuGet.Packaging.PackageSaveMode
NuGet.Packaging.PackageSaveMode.Nuspec = 1 -> NuGet.Packaging.PackageSaveMode
NuGet.Packaging.PackageSignType
NuGet.Packaging.PackageSignType.Signed = 0 -> NuGet.Packaging.PackageSignType
NuGet.Packaging.PackageSignType.Unsigned = 1 -> NuGet.Packaging.PackageSignType
NuGet.Packaging.PackageSigningTelemetryEvent
NuGet.Packaging.PackageSigningTelemetryEvent.ExtractionId.get -> string
NuGet.Packaging.PackageSigningTelemetryEvent.PackageSignType.get -> NuGet.Packaging.PackageSignType
NuGet.Packaging.PackageSigningTelemetryEvent.PackageSigningTelemetryEvent() -> void
NuGet.Packaging.PackageSigningTelemetryEvent.PackageSigningTelemetryEvent(NuGet.Packaging.PackageSignType packageSignType, NuGet.Common.NuGetOperationStatus status) -> void
NuGet.Packaging.PackageSigningTelemetryEvent.SetResult(NuGet.Packaging.PackageSignType packageSignType, NuGet.Common.NuGetOperationStatus status) -> void
NuGet.Packaging.PackageSigningTelemetryEvent.Status.get -> NuGet.Common.NuGetOperationStatus
NuGet.Packaging.PackagesConfig
NuGet.Packaging.PackagesConfigReader
NuGet.Packaging.PackagesConfigReader.GetMinClientVersion() -> NuGet.Versioning.NuGetVersion
NuGet.Packaging.PackagesConfigReader.GetPackages() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageReference>
NuGet.Packaging.PackagesConfigReader.GetPackages(bool allowDuplicatePackageIds) -> System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageReference>
NuGet.Packaging.PackagesConfigReader.PackagesConfigReader(NuGet.Frameworks.IFrameworkNameProvider frameworkMappings, System.IO.Stream stream, bool leaveStreamOpen) -> void
NuGet.Packaging.PackagesConfigReader.PackagesConfigReader(NuGet.Frameworks.IFrameworkNameProvider frameworkMappings, System.Xml.Linq.XDocument xml) -> void
NuGet.Packaging.PackagesConfigReader.PackagesConfigReader(System.IO.Stream stream) -> void
NuGet.Packaging.PackagesConfigReader.PackagesConfigReader(System.IO.Stream stream, bool leaveStreamOpen) -> void
NuGet.Packaging.PackagesConfigReader.PackagesConfigReader(System.Xml.Linq.XDocument xml) -> void
NuGet.Packaging.PackagesConfigReaderException
NuGet.Packaging.PackagesConfigReaderException.PackagesConfigReaderException(string message) -> void
NuGet.Packaging.PackagesConfigReaderException.PackagesConfigReaderException(string message, System.Exception innerException) -> void
NuGet.Packaging.PackagesConfigWriter
NuGet.Packaging.PackagesConfigWriter.AddPackageEntry(NuGet.Packaging.Core.PackageIdentity identity, NuGet.Frameworks.NuGetFramework targetFramework) -> void
NuGet.Packaging.PackagesConfigWriter.AddPackageEntry(NuGet.Packaging.PackageReference entry) -> void
NuGet.Packaging.PackagesConfigWriter.AddPackageEntry(string packageId, NuGet.Versioning.NuGetVersion version, NuGet.Frameworks.NuGetFramework targetFramework) -> void
NuGet.Packaging.PackagesConfigWriter.Dispose() -> void
NuGet.Packaging.PackagesConfigWriter.PackagesConfigWriter(System.IO.Stream stream, bool createNew) -> void
NuGet.Packaging.PackagesConfigWriter.PackagesConfigWriter(System.IO.Stream stream, bool createNew, NuGet.Frameworks.IFrameworkNameProvider frameworkMappings) -> void
NuGet.Packaging.PackagesConfigWriter.PackagesConfigWriter(string fullPath, bool createNew) -> void
NuGet.Packaging.PackagesConfigWriter.PackagesConfigWriter(string fullPath, bool createNew, NuGet.Frameworks.IFrameworkNameProvider frameworkMappings) -> void
NuGet.Packaging.PackagesConfigWriter.RemovePackageEntry(NuGet.Packaging.Core.PackageIdentity identity, NuGet.Frameworks.NuGetFramework targetFramework) -> void
NuGet.Packaging.PackagesConfigWriter.RemovePackageEntry(NuGet.Packaging.PackageReference entry) -> void
NuGet.Packaging.PackagesConfigWriter.RemovePackageEntry(string packageId, NuGet.Versioning.NuGetVersion version, NuGet.Frameworks.NuGetFramework targetFramework) -> void
NuGet.Packaging.PackagesConfigWriter.UpdateOrAddPackageEntry(System.Xml.Linq.XDocument originalConfig, NuGet.Packaging.PackageReference newEntry) -> void
NuGet.Packaging.PackagesConfigWriter.UpdatePackageEntry(NuGet.Packaging.PackageReference oldEntry, NuGet.Packaging.PackageReference newEntry) -> void
NuGet.Packaging.PackagesConfigWriter.WriteFile(string fullPath) -> void
NuGet.Packaging.PackagesConfigWriter.WriteMinClientVersion(NuGet.Versioning.NuGetVersion version) -> void
NuGet.Packaging.PackagesConfigWriterException
NuGet.Packaging.PackagesConfigWriterException.PackagesConfigWriterException(string message) -> void
NuGet.Packaging.PackagesConfigWriterException.PackagesConfigWriterException(string message, System.Exception innerException) -> void
NuGet.Packaging.PackagingConstants
NuGet.Packaging.PackagingConstants.Folders
NuGet.Packaging.PhysicalPackageFile
NuGet.Packaging.PhysicalPackageFile.EffectivePath.get -> string
NuGet.Packaging.PhysicalPackageFile.GetStream() -> System.IO.Stream
NuGet.Packaging.PhysicalPackageFile.LastWriteTime.get -> System.DateTimeOffset
NuGet.Packaging.PhysicalPackageFile.NuGetFramework.get -> NuGet.Frameworks.NuGetFramework
NuGet.Packaging.PhysicalPackageFile.Path.get -> string
NuGet.Packaging.PhysicalPackageFile.PhysicalPackageFile() -> void
NuGet.Packaging.PhysicalPackageFile.PhysicalPackageFile(System.IO.MemoryStream stream) -> void
NuGet.Packaging.PhysicalPackageFile.SourcePath.get -> string
NuGet.Packaging.PhysicalPackageFile.SourcePath.set -> void
NuGet.Packaging.PhysicalPackageFile.TargetFramework.get -> System.Runtime.Versioning.FrameworkName
NuGet.Packaging.PhysicalPackageFile.TargetPath.get -> string
NuGet.Packaging.PhysicalPackageFile.TargetPath.set -> void
NuGet.Packaging.RepositorySignatureInfo
NuGet.Packaging.RepositorySignatureInfo.AllRepositorySigned.get -> bool
NuGet.Packaging.RepositorySignatureInfo.RepositoryCertificateInfos.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.IRepositoryCertificateInfo>
NuGet.Packaging.RepositorySignatureInfo.RepositorySignatureInfo(bool allRepositorySigned, System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.IRepositoryCertificateInfo> repositoryCertificateInfos) -> void
NuGet.Packaging.RepositorySignatureInfoProvider
NuGet.Packaging.RepositorySignatureInfoProvider.AddOrUpdateRepositorySignatureInfo(string source, NuGet.Packaging.RepositorySignatureInfo repositorySignatureInfo) -> void
NuGet.Packaging.RepositorySignatureInfoProvider.RepositorySignatureInfoProvider() -> void
NuGet.Packaging.RepositorySignatureInfoProvider.TryGetRepositorySignatureInfo(string source, out NuGet.Packaging.RepositorySignatureInfo repositorySignatureInfo) -> bool
NuGet.Packaging.Rules.AnalysisResources
NuGet.Packaging.Rules.DefaultManifestValuesRule
NuGet.Packaging.Rules.DefaultManifestValuesRule.DefaultManifestValuesRule(string messageFormat) -> void
NuGet.Packaging.Rules.DefaultManifestValuesRule.MessageFormat.get -> string
NuGet.Packaging.Rules.DefaultManifestValuesRule.Validate(NuGet.Packaging.PackageArchiveReader builder) -> System.Collections.Generic.IEnumerable<NuGet.Common.PackagingLogMessage>
NuGet.Packaging.Rules.IPackageRule
NuGet.Packaging.Rules.IPackageRule.MessageFormat.get -> string
NuGet.Packaging.Rules.IPackageRule.Validate(NuGet.Packaging.PackageArchiveReader builder) -> System.Collections.Generic.IEnumerable<NuGet.Common.PackagingLogMessage>
NuGet.Packaging.Rules.IconUrlDeprecationWarning
NuGet.Packaging.Rules.IconUrlDeprecationWarning.IconUrlDeprecationWarning(string messageFormat) -> void
NuGet.Packaging.Rules.IconUrlDeprecationWarning.MessageFormat.get -> string
NuGet.Packaging.Rules.IconUrlDeprecationWarning.Validate(NuGet.Packaging.PackageArchiveReader builder) -> System.Collections.Generic.IEnumerable<NuGet.Common.PackagingLogMessage>
NuGet.Packaging.Rules.LicenseUrlDeprecationWarning
NuGet.Packaging.Rules.LicenseUrlDeprecationWarning.LicenseUrlDeprecationWarning(string messageFormat) -> void
NuGet.Packaging.Rules.LicenseUrlDeprecationWarning.MessageFormat.get -> string
NuGet.Packaging.Rules.LicenseUrlDeprecationWarning.Validate(NuGet.Packaging.PackageArchiveReader builder) -> System.Collections.Generic.IEnumerable<NuGet.Common.PackagingLogMessage>
NuGet.Packaging.Rules.PathTooLongRule
NuGet.Packaging.Rules.PathTooLongRule.MessageFormat.get -> string
NuGet.Packaging.Rules.PathTooLongRule.PathTooLongRule(string messageFormat) -> void
NuGet.Packaging.Rules.PathTooLongRule.Validate(NuGet.Packaging.PackageArchiveReader builder) -> System.Collections.Generic.IEnumerable<NuGet.Common.PackagingLogMessage>
NuGet.Packaging.Rules.RuleSet
NuGet.Packaging.Rules.UnspecifiedDependencyVersionRule
NuGet.Packaging.Rules.UnspecifiedDependencyVersionRule.MessageFormat.get -> string
NuGet.Packaging.Rules.UnspecifiedDependencyVersionRule.UnspecifiedDependencyVersionRule(string messageFormat) -> void
NuGet.Packaging.Rules.UnspecifiedDependencyVersionRule.Validate(NuGet.Packaging.PackageArchiveReader builder) -> System.Collections.Generic.IEnumerable<NuGet.Common.PackagingLogMessage>
NuGet.Packaging.Sha512HashFunction
NuGet.Packaging.Sha512HashFunction.Dispose() -> void
NuGet.Packaging.Sha512HashFunction.GetHash() -> string
NuGet.Packaging.Sha512HashFunction.GetHashBytes() -> byte[]
NuGet.Packaging.Sha512HashFunction.Sha512HashFunction() -> void
NuGet.Packaging.Sha512HashFunction.Update(byte[] data, int offset, int count) -> void
NuGet.Packaging.Signing.Accuracy
NuGet.Packaging.Signing.Accuracy.GetTotalMicroseconds() -> long?
NuGet.Packaging.Signing.Accuracy.Microseconds.get -> int?
NuGet.Packaging.Signing.Accuracy.Milliseconds.get -> int?
NuGet.Packaging.Signing.Accuracy.Seconds.get -> int?
NuGet.Packaging.Signing.AlgorithmIdentifier
NuGet.Packaging.Signing.AlgorithmIdentifier.Algorithm.get -> System.Security.Cryptography.Oid
NuGet.Packaging.Signing.AllowListVerificationProvider
NuGet.Packaging.Signing.AllowListVerificationProvider.AllowListVerificationProvider(System.Collections.Generic.IReadOnlyCollection<NuGet.Packaging.Signing.VerificationAllowListEntry> allowList, bool requireNonEmptyAllowList = false, string emptyListErrorMessage = "", string noMatchErrorMessage = "") -> void
NuGet.Packaging.Signing.AllowListVerificationProvider.GetTrustResultAsync(NuGet.Packaging.Signing.ISignedPackageReader package, NuGet.Packaging.Signing.PrimarySignature signature, NuGet.Packaging.Signing.SignedPackageVerifierSettings settings, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Packaging.Signing.PackageVerificationResult>
NuGet.Packaging.Signing.AttributeUtility
NuGet.Packaging.Signing.AuthorPrimarySignature
NuGet.Packaging.Signing.AuthorPrimarySignature.AuthorPrimarySignature(System.Security.Cryptography.Pkcs.SignedCms signedCms) -> void
NuGet.Packaging.Signing.AuthorSignPackageRequest
NuGet.Packaging.Signing.AuthorSignPackageRequest.AuthorSignPackageRequest(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate, NuGet.Common.HashAlgorithmName hashAlgorithm) -> void
NuGet.Packaging.Signing.AuthorSignPackageRequest.AuthorSignPackageRequest(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate, NuGet.Common.HashAlgorithmName signatureHashAlgorithm, NuGet.Common.HashAlgorithmName timestampHashAlgorithm) -> void
NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata
NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata.CentralDirectoryHeaderMetadata() -> void
NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata.ChangeInOffset.get -> long
NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata.ChangeInOffset.set -> void
NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata.FileEntryTotalSize.get -> long
NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata.FileEntryTotalSize.set -> void
NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata.HeaderSize.get -> long
NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata.HeaderSize.set -> void
NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata.IndexInHeaders.get -> int
NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata.IndexInHeaders.set -> void
NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata.IsPackageSignatureFile.get -> bool
NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata.IsPackageSignatureFile.set -> void
NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata.OffsetToLocalFileHeader.get -> long
NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata.OffsetToLocalFileHeader.set -> void
NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata.Position.get -> long
NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata.Position.set -> void
NuGet.Packaging.Signing.CertificateChainUtility
NuGet.Packaging.Signing.CertificateHashAllowListEntry
NuGet.Packaging.Signing.CertificateHashAllowListEntry.CertificateHashAllowListEntry(NuGet.Packaging.Signing.VerificationTarget target, NuGet.Packaging.Signing.SignaturePlacement placement, string fingerprint, NuGet.Common.HashAlgorithmName algorithm) -> void
NuGet.Packaging.Signing.CertificateHashAllowListEntry.Fingerprint.get -> string
NuGet.Packaging.Signing.CertificateHashAllowListEntry.FingerprintAlgorithm.get -> NuGet.Common.HashAlgorithmName
NuGet.Packaging.Signing.CertificateType
NuGet.Packaging.Signing.CertificateType.Signature = 0 -> NuGet.Packaging.Signing.CertificateType
NuGet.Packaging.Signing.CertificateType.Timestamp = 1 -> NuGet.Packaging.Signing.CertificateType
NuGet.Packaging.Signing.CertificateUtility
NuGet.Packaging.Signing.ClientPolicyContext
NuGet.Packaging.Signing.ClientPolicyContext.AllowList.get -> System.Collections.Generic.IReadOnlyCollection<NuGet.Packaging.Signing.TrustedSignerAllowListEntry>
NuGet.Packaging.Signing.ClientPolicyContext.Policy.get -> NuGet.Common.SignatureValidationMode
NuGet.Packaging.Signing.ClientPolicyContext.VerifierSettings.get -> NuGet.Packaging.Signing.SignedPackageVerifierSettings
NuGet.Packaging.Signing.CommitmentTypeIndication
NuGet.Packaging.Signing.CommitmentTypeIndication.CommitmentTypeId.get -> System.Security.Cryptography.Oid
NuGet.Packaging.Signing.CommitmentTypeIndication.Qualifiers.get -> System.Collections.Generic.IReadOnlyList<NuGet.Packaging.Signing.CommitmentTypeQualifier>
NuGet.Packaging.Signing.CommitmentTypeQualifier
NuGet.Packaging.Signing.CommitmentTypeQualifier.CommitmentTypeIdentifier.get -> System.Security.Cryptography.Oid
NuGet.Packaging.Signing.CommitmentTypeQualifier.Qualifier.get -> byte[]
NuGet.Packaging.Signing.Crc32
NuGet.Packaging.Signing.DerEncoding.DerGeneralizedTime
NuGet.Packaging.Signing.DerEncoding.DerGeneralizedTime.DateTime.get -> System.DateTime
NuGet.Packaging.Signing.EssCertId
NuGet.Packaging.Signing.EssCertId.CertificateHash.get -> byte[]
NuGet.Packaging.Signing.EssCertId.IssuerSerial.get -> NuGet.Packaging.Signing.IssuerSerial
NuGet.Packaging.Signing.EssCertIdV2
NuGet.Packaging.Signing.EssCertIdV2.CertificateHash.get -> byte[]
NuGet.Packaging.Signing.EssCertIdV2.HashAlgorithm.get -> NuGet.Packaging.Signing.AlgorithmIdentifier
NuGet.Packaging.Signing.EssCertIdV2.IssuerSerial.get -> NuGet.Packaging.Signing.IssuerSerial
NuGet.Packaging.Signing.Extension
NuGet.Packaging.Signing.Extension.Critical.get -> bool
NuGet.Packaging.Signing.Extension.Id.get -> System.Security.Cryptography.Oid
NuGet.Packaging.Signing.Extension.Value.get -> byte[]
NuGet.Packaging.Signing.Extensions
NuGet.Packaging.Signing.Extensions.ExtensionsList.get -> System.Collections.Generic.IReadOnlyList<NuGet.Packaging.Signing.Extension>
NuGet.Packaging.Signing.GeneralName
NuGet.Packaging.Signing.GeneralName.DirectoryName.get -> System.Security.Cryptography.X509Certificates.X500DistinguishedName
NuGet.Packaging.Signing.IPackageSignatureVerifier
NuGet.Packaging.Signing.IPackageSignatureVerifier.VerifySignaturesAsync(NuGet.Packaging.Signing.ISignedPackageReader package, NuGet.Packaging.Signing.SignedPackageVerifierSettings settings, System.Threading.CancellationToken token, System.Guid telemetryOperationId) -> System.Threading.Tasks.Task<NuGet.Packaging.Signing.VerifySignaturesResult>
NuGet.Packaging.Signing.IRepositorySignature
NuGet.Packaging.Signing.IRepositorySignature.PackageOwners.get -> System.Collections.Generic.IReadOnlyList<string>
NuGet.Packaging.Signing.IRepositorySignature.V3ServiceIndexUrl.get -> System.Uri
NuGet.Packaging.Signing.ISignature
NuGet.Packaging.Signing.ISignature.SignerInfo.get -> System.Security.Cryptography.Pkcs.SignerInfo
NuGet.Packaging.Signing.ISignature.Type.get -> NuGet.Packaging.Signing.SignatureType
NuGet.Packaging.Signing.ISignatureProvider
NuGet.Packaging.Signing.ISignatureProvider.CreatePrimarySignatureAsync(NuGet.Packaging.Signing.SignPackageRequest request, NuGet.Packaging.Signing.SignatureContent signatureContent, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Packaging.Signing.PrimarySignature>
NuGet.Packaging.Signing.ISignatureProvider.CreateRepositoryCountersignatureAsync(NuGet.Packaging.Signing.RepositorySignPackageRequest request, NuGet.Packaging.Signing.PrimarySignature primarySignature, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Packaging.Signing.PrimarySignature>
NuGet.Packaging.Signing.ISignatureVerificationProvider
NuGet.Packaging.Signing.ISignatureVerificationProvider.GetTrustResultAsync(NuGet.Packaging.Signing.ISignedPackageReader package, NuGet.Packaging.Signing.PrimarySignature signature, NuGet.Packaging.Signing.SignedPackageVerifierSettings settings, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Packaging.Signing.PackageVerificationResult>
NuGet.Packaging.Signing.ISignedPackage
NuGet.Packaging.Signing.ISignedPackageReader
NuGet.Packaging.Signing.ISignedPackageReader.CanVerifySignedPackages(NuGet.Packaging.Signing.SignedPackageVerifierSettings verifierSettings) -> bool
NuGet.Packaging.Signing.ISignedPackageReader.GetArchiveHashAsync(NuGet.Common.HashAlgorithmName hashAlgorithm, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<byte[]>
NuGet.Packaging.Signing.ISignedPackageReader.GetContentHash(System.Threading.CancellationToken token, System.Func<string> GetUnsignedPackageHash = null) -> string
NuGet.Packaging.Signing.ISignedPackageReader.GetPrimarySignatureAsync(System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Packaging.Signing.PrimarySignature>
NuGet.Packaging.Signing.ISignedPackageReader.IsSignedAsync(System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<bool>
NuGet.Packaging.Signing.ISignedPackageReader.ValidateIntegrityAsync(NuGet.Packaging.Signing.SignatureContent signatureContent, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task
NuGet.Packaging.Signing.ISignedPackageWriter
NuGet.Packaging.Signing.ISignedPackageWriter.AddSignatureAsync(System.IO.Stream signatureStream, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task
NuGet.Packaging.Signing.ISignedPackageWriter.IsZip64Async(System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<bool>
NuGet.Packaging.Signing.ISignedPackageWriter.RemoveSignatureAsync(System.Threading.CancellationToken token) -> System.Threading.Tasks.Task
NuGet.Packaging.Signing.ITimestampProvider
NuGet.Packaging.Signing.ITimestampProvider.TimestampSignatureAsync(NuGet.Packaging.Signing.PrimarySignature primarySignature, NuGet.Packaging.Signing.TimestampRequest request, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Packaging.Signing.PrimarySignature>
NuGet.Packaging.Signing.ITrustedSignersProvider
NuGet.Packaging.Signing.ITrustedSignersProvider.AddOrUpdateTrustedSigner(NuGet.Configuration.TrustedSignerItem trustedSigner) -> void
NuGet.Packaging.Signing.ITrustedSignersProvider.GetTrustedSigners() -> System.Collections.Generic.IReadOnlyList<NuGet.Configuration.TrustedSignerItem>
NuGet.Packaging.Signing.ITrustedSignersProvider.Remove(System.Collections.Generic.IReadOnlyList<NuGet.Configuration.TrustedSignerItem> trustedSigners) -> void
NuGet.Packaging.Signing.IX509CertificateChain
NuGet.Packaging.Signing.IntegrityVerificationProvider
NuGet.Packaging.Signing.IntegrityVerificationProvider.GetTrustResultAsync(NuGet.Packaging.Signing.ISignedPackageReader package, NuGet.Packaging.Signing.PrimarySignature signature, NuGet.Packaging.Signing.SignedPackageVerifierSettings settings, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Packaging.Signing.PackageVerificationResult>
NuGet.Packaging.Signing.IntegrityVerificationProvider.IntegrityVerificationProvider() -> void
NuGet.Packaging.Signing.InvalidSignaturePackageVerificationResult
NuGet.Packaging.Signing.InvalidSignaturePackageVerificationResult.InvalidSignaturePackageVerificationResult(NuGet.Packaging.Signing.SignatureVerificationStatus trust, System.Collections.Generic.IEnumerable<NuGet.Packaging.Signing.SignatureLog> issues) -> void
NuGet.Packaging.Signing.IssuerSerial
NuGet.Packaging.Signing.IssuerSerial.GeneralNames.get -> System.Collections.Generic.IReadOnlyList<NuGet.Packaging.Signing.GeneralName>
NuGet.Packaging.Signing.IssuerSerial.SerialNumber.get -> byte[]
NuGet.Packaging.Signing.KeyPairFileReader
NuGet.Packaging.Signing.KeyPairFileReader.Dispose() -> void
NuGet.Packaging.Signing.KeyPairFileReader.KeyPairFileReader(System.IO.Stream stream, System.Text.Encoding encoding) -> void
NuGet.Packaging.Signing.KeyPairFileReader.ReadSection() -> System.Collections.Generic.Dictionary<string, string>
NuGet.Packaging.Signing.KeyPairFileUtility
NuGet.Packaging.Signing.KeyPairFileWriter
NuGet.Packaging.Signing.KeyPairFileWriter.Dispose() -> void
NuGet.Packaging.Signing.KeyPairFileWriter.KeyPairFileWriter(System.IO.Stream stream, System.Text.Encoding encoding, bool leaveOpen) -> void
NuGet.Packaging.Signing.KeyPairFileWriter.WritePair(string key, string value) -> void
NuGet.Packaging.Signing.KeyPairFileWriter.WriteSectionBreak() -> void
NuGet.Packaging.Signing.MessageImprint
NuGet.Packaging.Signing.MessageImprint.HashAlgorithm.get -> NuGet.Packaging.Signing.AlgorithmIdentifier
NuGet.Packaging.Signing.MessageImprint.HashedMessage.get -> byte[]
NuGet.Packaging.Signing.NuGetPackageOwners
NuGet.Packaging.Signing.NuGetPackageOwners.Encode() -> byte[]
NuGet.Packaging.Signing.NuGetPackageOwners.NuGetPackageOwners(System.Collections.Generic.IReadOnlyList<string> packageOwners) -> void
NuGet.Packaging.Signing.NuGetPackageOwners.PackageOwners.get -> System.Collections.Generic.IReadOnlyList<string>
NuGet.Packaging.Signing.NuGetV3ServiceIndexUrl
NuGet.Packaging.Signing.NuGetV3ServiceIndexUrl.Encode() -> byte[]
NuGet.Packaging.Signing.NuGetV3ServiceIndexUrl.NuGetV3ServiceIndexUrl(System.Uri v3ServiceIndexUrl) -> void
NuGet.Packaging.Signing.NuGetV3ServiceIndexUrl.V3ServiceIndexUrl.get -> System.Uri
NuGet.Packaging.Signing.Oids
NuGet.Packaging.Signing.PackageSignatureVerifier
NuGet.Packaging.Signing.PackageSignatureVerifier.PackageSignatureVerifier(System.Collections.Generic.IEnumerable<NuGet.Packaging.Signing.ISignatureVerificationProvider> verificationProviders) -> void
NuGet.Packaging.Signing.PackageSignatureVerifier.VerifySignaturesAsync(NuGet.Packaging.Signing.ISignedPackageReader package, NuGet.Packaging.Signing.SignedPackageVerifierSettings settings, System.Threading.CancellationToken token, System.Guid parentId = default(System.Guid)) -> System.Threading.Tasks.Task<NuGet.Packaging.Signing.VerifySignaturesResult>
NuGet.Packaging.Signing.PackageVerificationResult
NuGet.Packaging.Signing.PackageVerificationResult.GetErrorIssues() -> System.Collections.Generic.IEnumerable<NuGet.Common.ILogMessage>
NuGet.Packaging.Signing.PackageVerificationResult.GetWarningIssues() -> System.Collections.Generic.IEnumerable<NuGet.Common.ILogMessage>
NuGet.Packaging.Signing.PackageVerificationResult.PackageVerificationResult(NuGet.Packaging.Signing.SignatureVerificationStatus trust, System.Collections.Generic.IEnumerable<NuGet.Packaging.Signing.SignatureLog> issues) -> void
NuGet.Packaging.Signing.PolicyInformation
NuGet.Packaging.Signing.PolicyInformation.PolicyIdentifier.get -> System.Security.Cryptography.Oid
NuGet.Packaging.Signing.PolicyInformation.PolicyQualifiers.get -> System.Collections.Generic.IReadOnlyList<NuGet.Packaging.Signing.PolicyQualifierInfo>
NuGet.Packaging.Signing.PolicyQualifierInfo
NuGet.Packaging.Signing.PolicyQualifierInfo.PolicyQualifierId.get -> System.Security.Cryptography.Oid
NuGet.Packaging.Signing.PolicyQualifierInfo.Qualifier.get -> byte[]
NuGet.Packaging.Signing.PrimarySignature
NuGet.Packaging.Signing.PrimarySignature.GetBytes() -> byte[]
NuGet.Packaging.Signing.PrimarySignature.PrimarySignature(System.Security.Cryptography.Pkcs.SignedCms signedCms, NuGet.Packaging.Signing.SignatureType signatureType) -> void
NuGet.Packaging.Signing.PrimarySignature.Save(System.IO.Stream stream) -> void
NuGet.Packaging.Signing.PrimarySignature.SignatureContent.get -> NuGet.Packaging.Signing.SignatureContent
NuGet.Packaging.Signing.PrimarySignature.SignedCms.get -> System.Security.Cryptography.Pkcs.SignedCms
NuGet.Packaging.Signing.PrimarySignatureFactory
NuGet.Packaging.Signing.ReadOnlyBufferedStream
NuGet.Packaging.Signing.ReadOnlyBufferedStream.ReadOnlyBufferedStream(System.IO.Stream stream, bool leaveOpen) -> void
NuGet.Packaging.Signing.ReadOnlyBufferedStream.ReadOnlyBufferedStream(System.IO.Stream stream, bool leaveOpen, int bufferSize) -> void
NuGet.Packaging.Signing.RepositoryCountersignature
NuGet.Packaging.Signing.RepositoryCountersignature.PackageOwners.get -> System.Collections.Generic.IReadOnlyList<string>
NuGet.Packaging.Signing.RepositoryCountersignature.V3ServiceIndexUrl.get -> System.Uri
NuGet.Packaging.Signing.RepositoryPrimarySignature
NuGet.Packaging.Signing.RepositoryPrimarySignature.PackageOwners.get -> System.Collections.Generic.IReadOnlyList<string>
NuGet.Packaging.Signing.RepositoryPrimarySignature.RepositoryPrimarySignature(System.Security.Cryptography.Pkcs.SignedCms signedCms) -> void
NuGet.Packaging.Signing.RepositoryPrimarySignature.V3ServiceIndexUrl.get -> System.Uri
NuGet.Packaging.Signing.RepositorySignPackageRequest
NuGet.Packaging.Signing.RepositorySignPackageRequest.PackageOwners.get -> System.Collections.Generic.IReadOnlyList<string>
NuGet.Packaging.Signing.RepositorySignPackageRequest.RepositorySignPackageRequest(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate, NuGet.Common.HashAlgorithmName signatureHashAlgorithm, NuGet.Common.HashAlgorithmName timestampHashAlgorithm, System.Uri v3ServiceIndexUrl, System.Collections.Generic.IReadOnlyList<string> packageOwners) -> void
NuGet.Packaging.Signing.RepositorySignPackageRequest.V3ServiceIndexUrl.get -> System.Uri
NuGet.Packaging.Signing.RepositorySignatureInfoUtility
NuGet.Packaging.Signing.Rfc3161TimestampProvider
NuGet.Packaging.Signing.Rfc3161TimestampProvider.Rfc3161TimestampProvider(System.Uri timeStampServerUrl) -> void
NuGet.Packaging.Signing.Rfc3161TimestampProvider.TimestampSignatureAsync(NuGet.Packaging.Signing.PrimarySignature primarySignature, NuGet.Packaging.Signing.TimestampRequest request, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Packaging.Signing.PrimarySignature>
NuGet.Packaging.Signing.Rfc3161TimestampTokenInfo
NuGet.Packaging.Signing.Rfc3161TimestampTokenInfo.AccuracyInMicroseconds.get -> long?
NuGet.Packaging.Signing.Rfc3161TimestampTokenInfo.GetExtensions() -> System.Security.Cryptography.X509Certificates.X509ExtensionCollection
NuGet.Packaging.Signing.Rfc3161TimestampTokenInfo.GetMessageHash() -> byte[]
NuGet.Packaging.Signing.Rfc3161TimestampTokenInfo.GetNonce() -> byte[]
NuGet.Packaging.Signing.Rfc3161TimestampTokenInfo.GetSerialNumber() -> byte[]
NuGet.Packaging.Signing.Rfc3161TimestampTokenInfo.GetTimestampAuthorityName() -> byte[]
NuGet.Packaging.Signing.Rfc3161TimestampTokenInfo.HasExtensions.get -> bool
NuGet.Packaging.Signing.Rfc3161TimestampTokenInfo.HasMessageHash(byte[] hash) -> bool
NuGet.Packaging.Signing.Rfc3161TimestampTokenInfo.HashAlgorithmId.get -> System.Security.Cryptography.Oid
NuGet.Packaging.Signing.Rfc3161TimestampTokenInfo.IsOrdering.get -> bool
NuGet.Packaging.Signing.Rfc3161TimestampTokenInfo.PolicyId.get -> string
NuGet.Packaging.Signing.Rfc3161TimestampTokenInfo.Rfc3161TimestampTokenInfo(byte[] timestampTokenInfo) -> void
NuGet.Packaging.Signing.Rfc3161TimestampTokenInfo.Timestamp.get -> System.DateTimeOffset
NuGet.Packaging.Signing.Rfc3161TimestampTokenInfo.Version.get -> int
NuGet.Packaging.Signing.SignPackageRequest
NuGet.Packaging.Signing.SignPackageRequest.AdditionalCertificates.get -> System.Security.Cryptography.X509Certificates.X509Certificate2Collection
NuGet.Packaging.Signing.SignPackageRequest.Certificate.get -> System.Security.Cryptography.X509Certificates.X509Certificate2
NuGet.Packaging.Signing.SignPackageRequest.Dispose() -> void
NuGet.Packaging.Signing.SignPackageRequest.PrivateKey.get -> System.Security.Cryptography.CngKey
NuGet.Packaging.Signing.SignPackageRequest.PrivateKey.set -> void
NuGet.Packaging.Signing.SignPackageRequest.SignPackageRequest(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate, NuGet.Common.HashAlgorithmName signatureHashAlgorithm, NuGet.Common.HashAlgorithmName timestampHashAlgorithm) -> void
NuGet.Packaging.Signing.SignPackageRequest.SignatureHashAlgorithm.get -> NuGet.Common.HashAlgorithmName
NuGet.Packaging.Signing.SignPackageRequest.TimestampHashAlgorithm.get -> NuGet.Common.HashAlgorithmName
NuGet.Packaging.Signing.Signature
NuGet.Packaging.Signing.Signature.GetSigningCertificateFingerprint(NuGet.Common.HashAlgorithmName algorithm) -> string
NuGet.Packaging.Signing.Signature.Signature(System.Security.Cryptography.Pkcs.SignerInfo signerInfo, NuGet.Packaging.Signing.SignatureType type) -> void
NuGet.Packaging.Signing.Signature.SignerInfo.get -> System.Security.Cryptography.Pkcs.SignerInfo
NuGet.Packaging.Signing.Signature.Timestamps.get -> System.Collections.Generic.IReadOnlyList<NuGet.Packaging.Signing.Timestamp>
NuGet.Packaging.Signing.Signature.Type.get -> NuGet.Packaging.Signing.SignatureType
NuGet.Packaging.Signing.SignatureContent
NuGet.Packaging.Signing.SignatureContent.GetBytes() -> byte[]
NuGet.Packaging.Signing.SignatureContent.HashAlgorithm.get -> NuGet.Common.HashAlgorithmName
NuGet.Packaging.Signing.SignatureContent.HashValue.get -> string
NuGet.Packaging.Signing.SignatureContent.SignatureContent(NuGet.Packaging.Signing.SigningSpecifications signingSpecifications, NuGet.Common.HashAlgorithmName hashAlgorithm, string hashValue) -> void
NuGet.Packaging.Signing.SignatureException
NuGet.Packaging.Signing.SignatureException.Code.get -> NuGet.Common.NuGetLogCode
NuGet.Packaging.Signing.SignatureException.PackageIdentity.get -> NuGet.Packaging.Core.PackageIdentity
NuGet.Packaging.Signing.SignatureException.Results.get -> System.Collections.Generic.IReadOnlyList<NuGet.Packaging.Signing.PackageVerificationResult>
NuGet.Packaging.Signing.SignatureException.SignatureException(NuGet.Common.NuGetLogCode code, string message) -> void
NuGet.Packaging.Signing.SignatureException.SignatureException(NuGet.Common.NuGetLogCode code, string message, NuGet.Packaging.Core.PackageIdentity package) -> void
NuGet.Packaging.Signing.SignatureException.SignatureException(NuGet.Common.NuGetLogCode code, string message, System.Exception innerException) -> void
NuGet.Packaging.Signing.SignatureException.SignatureException(System.Collections.Generic.IReadOnlyList<NuGet.Packaging.Signing.PackageVerificationResult> results, NuGet.Packaging.Core.PackageIdentity package) -> void
NuGet.Packaging.Signing.SignatureException.SignatureException(string message) -> void
NuGet.Packaging.Signing.SignatureException.VerifyDuration.get -> System.TimeSpan
NuGet.Packaging.Signing.SignatureException.VerifyDuration.set -> void
NuGet.Packaging.Signing.SignatureLog
NuGet.Packaging.Signing.SignatureLog.AsRestoreLogMessage() -> NuGet.Common.RestoreLogMessage
NuGet.Packaging.Signing.SignatureLog.Code.get -> NuGet.Common.NuGetLogCode
NuGet.Packaging.Signing.SignatureLog.Code.set -> void
NuGet.Packaging.Signing.SignatureLog.Equals(NuGet.Packaging.Signing.SignatureLog other) -> bool
NuGet.Packaging.Signing.SignatureLog.Level.get -> NuGet.Common.LogLevel
NuGet.Packaging.Signing.SignatureLog.Level.set -> void
NuGet.Packaging.Signing.SignatureLog.LibraryId.get -> string
NuGet.Packaging.Signing.SignatureLog.LibraryId.set -> void
NuGet.Packaging.Signing.SignatureLog.Message.get -> string
NuGet.Packaging.Signing.SignatureLog.Message.set -> void
NuGet.Packaging.Signing.SignatureLog.ProjectPath.get -> string
NuGet.Packaging.Signing.SignatureLog.ProjectPath.set -> void
NuGet.Packaging.Signing.SignatureLog.Time.get -> System.DateTimeOffset
NuGet.Packaging.Signing.SignatureLog.Time.set -> void
NuGet.Packaging.Signing.SignatureLog.WarningLevel.get -> NuGet.Common.WarningLevel
NuGet.Packaging.Signing.SignatureLog.WarningLevel.set -> void
NuGet.Packaging.Signing.SignaturePlacement
NuGet.Packaging.Signing.SignaturePlacement.Any = NuGet.Packaging.Signing.SignaturePlacement.PrimarySignature | NuGet.Packaging.Signing.SignaturePlacement.Countersignature -> NuGet.Packaging.Signing.SignaturePlacement
NuGet.Packaging.Signing.SignaturePlacement.Countersignature = 2 -> NuGet.Packaging.Signing.SignaturePlacement
NuGet.Packaging.Signing.SignaturePlacement.PrimarySignature = 1 -> NuGet.Packaging.Signing.SignaturePlacement
NuGet.Packaging.Signing.SignatureTrustAndValidityVerificationProvider
NuGet.Packaging.Signing.SignatureTrustAndValidityVerificationProvider.GetTrustResultAsync(NuGet.Packaging.Signing.ISignedPackageReader package, NuGet.Packaging.Signing.PrimarySignature signature, NuGet.Packaging.Signing.SignedPackageVerifierSettings settings, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Packaging.Signing.PackageVerificationResult>
NuGet.Packaging.Signing.SignatureTrustAndValidityVerificationProvider.SignatureTrustAndValidityVerificationProvider(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, NuGet.Common.HashAlgorithmName>> allowUntrustedRootList = null) -> void
NuGet.Packaging.Signing.SignatureType
NuGet.Packaging.Signing.SignatureType.Author = 1 -> NuGet.Packaging.Signing.SignatureType
NuGet.Packaging.Signing.SignatureType.Repository = 2 -> NuGet.Packaging.Signing.SignatureType
NuGet.Packaging.Signing.SignatureType.Unknown = 0 -> NuGet.Packaging.Signing.SignatureType
NuGet.Packaging.Signing.SignatureUtility
NuGet.Packaging.Signing.SignatureVerificationBehavior
NuGet.Packaging.Signing.SignatureVerificationBehavior.Always = 3 -> NuGet.Packaging.Signing.SignatureVerificationBehavior
NuGet.Packaging.Signing.SignatureVerificationBehavior.IfExists = 1 -> NuGet.Packaging.Signing.SignatureVerificationBehavior
NuGet.Packaging.Signing.SignatureVerificationBehavior.IfExistsAndIsNecessary = 2 -> NuGet.Packaging.Signing.SignatureVerificationBehavior
NuGet.Packaging.Signing.SignatureVerificationBehavior.Never = 0 -> NuGet.Packaging.Signing.SignatureVerificationBehavior
NuGet.Packaging.Signing.SignatureVerificationStatus
NuGet.Packaging.Signing.SignatureVerificationStatus.Disallowed = 2 -> NuGet.Packaging.Signing.SignatureVerificationStatus
NuGet.Packaging.Signing.SignatureVerificationStatus.Suspect = 1 -> NuGet.Packaging.Signing.SignatureVerificationStatus
NuGet.Packaging.Signing.SignatureVerificationStatus.Unknown = 0 -> NuGet.Packaging.Signing.SignatureVerificationStatus
NuGet.Packaging.Signing.SignatureVerificationStatus.Valid = 3 -> NuGet.Packaging.Signing.SignatureVerificationStatus
NuGet.Packaging.Signing.SignatureVerificationStatusFlags
NuGet.Packaging.Signing.SignatureVerificationStatusFlags.CertificateExpired = 256 -> NuGet.Packaging.Signing.SignatureVerificationStatusFlags
NuGet.Packaging.Signing.SignatureVerificationStatusFlags.CertificatePublicKeyInvalid = 32 -> NuGet.Packaging.Signing.SignatureVerificationStatusFlags
NuGet.Packaging.Signing.SignatureVerificationStatusFlags.CertificateRevoked = 16384 -> NuGet.Packaging.Signing.SignatureVerificationStatusFlags
NuGet.Packaging.Signing.SignatureVerificationStatusFlags.CertificateValidityInTheFuture = 128 -> NuGet.Packaging.Signing.SignatureVerificationStatusFlags
NuGet.Packaging.Signing.SignatureVerificationStatusFlags.ChainBuildingFailure = 4096 -> NuGet.Packaging.Signing.SignatureVerificationStatusFlags
NuGet.Packaging.Signing.SignatureVerificationStatusFlags.GeneralizedTimeOutsideValidity = 65536 -> NuGet.Packaging.Signing.SignatureVerificationStatusFlags
NuGet.Packaging.Signing.SignatureVerificationStatusFlags.HasLifetimeSigningEku = 64 -> NuGet.Packaging.Signing.SignatureVerificationStatusFlags
NuGet.Packaging.Signing.SignatureVerificationStatusFlags.HashAlgorithmUnsupported = 512 -> NuGet.Packaging.Signing.SignatureVerificationStatusFlags
NuGet.Packaging.Signing.SignatureVerificationStatusFlags.Illegal = NuGet.Packaging.Signing.SignatureVerificationStatusFlags.NoCertificate | NuGet.Packaging.Signing.SignatureVerificationStatusFlags.MultipleSignatures | NuGet.Packaging.Signing.SignatureVerificationStatusFlags.SignatureCheckFailed | NuGet.Packaging.Signing.SignatureVerificationStatusFlags.SignatureAlgorithmUnsupported | NuGet.Packaging.Signing.SignatureVerificationStatusFlags.CertificatePublicKeyInvalid | NuGet.Packaging.Signing.SignatureVerificationStatusFlags.HasLifetimeSigningEku | NuGet.Packaging.Signing.SignatureVerificationStatusFlags.CertificateValidityInTheFuture | NuGet.Packaging.Signing.SignatureVerificationStatusFlags.HashAlgorithmUnsupported | NuGet.Packaging.Signing.SignatureVerificationStatusFlags.MessageImprintUnsupportedAlgorithm -> NuGet.Packaging.Signing.SignatureVerificationStatusFlags
NuGet.Packaging.Signing.SignatureVerificationStatusFlags.IntegrityCheckFailed = 2048 -> NuGet.Packaging.Signing.SignatureVerificationStatusFlags
NuGet.Packaging.Signing.SignatureVerificationStatusFlags.MessageImprintUnsupportedAlgorithm = 1024 -> NuGet.Packaging.Signing.SignatureVerificationStatusFlags
NuGet.Packaging.Signing.SignatureVerificationStatusFlags.MultipleSignatures = 4 -> NuGet.Packaging.Signing.SignatureVerificationStatusFlags
NuGet.Packaging.Signing.SignatureVerificationStatusFlags.MultipleTimestamps = 262144 -> NuGet.Packaging.Signing.SignatureVerificationStatusFlags
NuGet.Packaging.Signing.SignatureVerificationStatusFlags.NoCertificate = 2 -> NuGet.Packaging.Signing.SignatureVerificationStatusFlags
NuGet.Packaging.Signing.SignatureVerificationStatusFlags.NoErrors = 0 -> NuGet.Packaging.Signing.SignatureVerificationStatusFlags
NuGet.Packaging.Signing.SignatureVerificationStatusFlags.NoSignature = 1 -> NuGet.Packaging.Signing.SignatureVerificationStatusFlags
NuGet.Packaging.Signing.SignatureVerificationStatusFlags.NoValidTimestamp = 131072 -> NuGet.Packaging.Signing.SignatureVerificationStatusFlags
NuGet.Packaging.Signing.SignatureVerificationStatusFlags.SignatureAlgorithmUnsupported = 16 -> NuGet.Packaging.Signing.SignatureVerificationStatusFlags
NuGet.Packaging.Signing.SignatureVerificationStatusFlags.SignatureCheckFailed = 8 -> NuGet.Packaging.Signing.SignatureVerificationStatusFlags
NuGet.Packaging.Signing.SignatureVerificationStatusFlags.Suspect = NuGet.Packaging.Signing.SignatureVerificationStatusFlags.IntegrityCheckFailed | NuGet.Packaging.Signing.SignatureVerificationStatusFlags.CertificateRevoked -> NuGet.Packaging.Signing.SignatureVerificationStatusFlags
NuGet.Packaging.Signing.SignatureVerificationStatusFlags.UnknownRevocation = 8192 -> NuGet.Packaging.Signing.SignatureVerificationStatusFlags
NuGet.Packaging.Signing.SignatureVerificationStatusFlags.Untrusted = NuGet.Packaging.Signing.SignatureVerificationStatusFlags.NoSignature | NuGet.Packaging.Signing.SignatureVerificationStatusFlags.CertificateExpired | NuGet.Packaging.Signing.SignatureVerificationStatusFlags.ChainBuildingFailure | NuGet.Packaging.Signing.SignatureVerificationStatusFlags.UnknownRevocation | NuGet.Packaging.Signing.SignatureVerificationStatusFlags.UntrustedRoot | NuGet.Packaging.Signing.SignatureVerificationStatusFlags.GeneralizedTimeOutsideValidity -> NuGet.Packaging.Signing.SignatureVerificationStatusFlags
NuGet.Packaging.Signing.SignatureVerificationStatusFlags.UntrustedRoot = 32768 -> NuGet.Packaging.Signing.SignatureVerificationStatusFlags
NuGet.Packaging.Signing.SignatureVerificationSummary
NuGet.Packaging.Signing.SignatureVerificationSummary.ExpirationTime.get -> System.DateTimeOffset?
NuGet.Packaging.Signing.SignatureVerificationSummary.Flags.get -> NuGet.Packaging.Signing.SignatureVerificationStatusFlags
NuGet.Packaging.Signing.SignatureVerificationSummary.Issues.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.Signing.SignatureLog>
NuGet.Packaging.Signing.SignatureVerificationSummary.Issues.set -> void
NuGet.Packaging.Signing.SignatureVerificationSummary.SignatureType.get -> NuGet.Packaging.Signing.SignatureType
NuGet.Packaging.Signing.SignatureVerificationSummary.SignatureVerificationSummary(NuGet.Packaging.Signing.SignatureType signatureType, NuGet.Packaging.Signing.SignatureVerificationStatus status, NuGet.Packaging.Signing.SignatureVerificationStatusFlags flags, NuGet.Packaging.Signing.Timestamp timestamp, System.Collections.Generic.IEnumerable<NuGet.Packaging.Signing.SignatureLog> issues) -> void
NuGet.Packaging.Signing.SignatureVerificationSummary.SignatureVerificationSummary(NuGet.Packaging.Signing.SignatureType signatureType, NuGet.Packaging.Signing.SignatureVerificationStatus status, NuGet.Packaging.Signing.SignatureVerificationStatusFlags flags, NuGet.Packaging.Signing.Timestamp timestamp, System.DateTimeOffset? expirationTime, System.Collections.Generic.IEnumerable<NuGet.Packaging.Signing.SignatureLog> issues) -> void
NuGet.Packaging.Signing.SignatureVerificationSummary.SignatureVerificationSummary(NuGet.Packaging.Signing.SignatureType signatureType, NuGet.Packaging.Signing.SignatureVerificationStatus status, NuGet.Packaging.Signing.SignatureVerificationStatusFlags flags, System.Collections.Generic.IEnumerable<NuGet.Packaging.Signing.SignatureLog> issues) -> void
NuGet.Packaging.Signing.SignatureVerificationSummary.Status.get -> NuGet.Packaging.Signing.SignatureVerificationStatus
NuGet.Packaging.Signing.SignatureVerificationSummary.Timestamp.get -> NuGet.Packaging.Signing.Timestamp
NuGet.Packaging.Signing.SignatureVerifySettings
NuGet.Packaging.Signing.SignatureVerifySettings.AllowIllegal.get -> bool
NuGet.Packaging.Signing.SignatureVerifySettings.AllowUnknownRevocation.get -> bool
NuGet.Packaging.Signing.SignatureVerifySettings.AllowUntrusted.get -> bool
NuGet.Packaging.Signing.SignatureVerifySettings.ReportUnknownRevocation.get -> bool
NuGet.Packaging.Signing.SignatureVerifySettings.ReportUntrustedRoot.get -> bool
NuGet.Packaging.Signing.SignatureVerifySettings.RevocationMode.get -> NuGet.Common.RevocationMode
NuGet.Packaging.Signing.SignatureVerifySettings.SignatureVerifySettings(bool allowIllegal, bool allowUntrusted, bool allowUnknownRevocation, bool reportUnknownRevocation, bool reportUntrustedRoot, NuGet.Common.RevocationMode revocationMode) -> void
NuGet.Packaging.Signing.SignedPackageArchive
NuGet.Packaging.Signing.SignedPackageArchive.AddSignatureAsync(System.IO.Stream signatureStream, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task
NuGet.Packaging.Signing.SignedPackageArchive.IsZip64Async(System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<bool>
NuGet.Packaging.Signing.SignedPackageArchive.RemoveSignatureAsync(System.Threading.CancellationToken token) -> System.Threading.Tasks.Task
NuGet.Packaging.Signing.SignedPackageArchive.SignedPackageArchive(System.IO.Stream packageReadStream, System.IO.Stream packageWriteStream) -> void
NuGet.Packaging.Signing.SignedPackageArchiveIOUtility
NuGet.Packaging.Signing.SignedPackageArchiveMetadata
NuGet.Packaging.Signing.SignedPackageArchiveMetadata.CentralDirectoryHeaders.get -> System.Collections.Generic.List<NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata>
NuGet.Packaging.Signing.SignedPackageArchiveMetadata.CentralDirectoryHeaders.set -> void
NuGet.Packaging.Signing.SignedPackageArchiveMetadata.EndOfCentralDirectory.get -> long
NuGet.Packaging.Signing.SignedPackageArchiveMetadata.EndOfCentralDirectory.set -> void
NuGet.Packaging.Signing.SignedPackageArchiveMetadata.GetPackageSignatureFileCentralDirectoryHeaderMetadata() -> NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata
NuGet.Packaging.Signing.SignedPackageArchiveMetadata.SignatureCentralDirectoryHeaderIndex.get -> int
NuGet.Packaging.Signing.SignedPackageArchiveMetadata.SignatureCentralDirectoryHeaderIndex.set -> void
NuGet.Packaging.Signing.SignedPackageArchiveMetadata.SignedPackageArchiveMetadata() -> void
NuGet.Packaging.Signing.SignedPackageArchiveMetadata.StartOfLocalFileHeaders.get -> long
NuGet.Packaging.Signing.SignedPackageArchiveMetadata.StartOfLocalFileHeaders.set -> void
NuGet.Packaging.Signing.SignedPackageArchiveUtility
NuGet.Packaging.Signing.SignedPackageVerificationResult
NuGet.Packaging.Signing.SignedPackageVerificationResult.Signature.get -> NuGet.Packaging.Signing.PrimarySignature
NuGet.Packaging.Signing.SignedPackageVerificationResult.SignedPackageVerificationResult(NuGet.Packaging.Signing.SignatureVerificationStatus trust, NuGet.Packaging.Signing.PrimarySignature signature, System.Collections.Generic.IEnumerable<NuGet.Packaging.Signing.SignatureLog> issues) -> void
NuGet.Packaging.Signing.SignedPackageVerifierSettings
NuGet.Packaging.Signing.SignedPackageVerifierSettings.AllowIgnoreTimestamp.get -> bool
NuGet.Packaging.Signing.SignedPackageVerifierSettings.AllowIllegal.get -> bool
NuGet.Packaging.Signing.SignedPackageVerifierSettings.AllowMultipleTimestamps.get -> bool
NuGet.Packaging.Signing.SignedPackageVerifierSettings.AllowNoTimestamp.get -> bool
NuGet.Packaging.Signing.SignedPackageVerifierSettings.AllowUnknownRevocation.get -> bool
NuGet.Packaging.Signing.SignedPackageVerifierSettings.AllowUnsigned.get -> bool
NuGet.Packaging.Signing.SignedPackageVerifierSettings.AllowUntrusted.get -> bool
NuGet.Packaging.Signing.SignedPackageVerifierSettings.ReportUnknownRevocation.get -> bool
NuGet.Packaging.Signing.SignedPackageVerifierSettings.RepositoryCountersignatureVerificationBehavior.get -> NuGet.Packaging.Signing.SignatureVerificationBehavior
NuGet.Packaging.Signing.SignedPackageVerifierSettings.RevocationMode.get -> NuGet.Common.RevocationMode
NuGet.Packaging.Signing.SignedPackageVerifierSettings.SignaturePlacement.get -> NuGet.Packaging.Signing.SignaturePlacement
NuGet.Packaging.Signing.SignedPackageVerifierSettings.SignedPackageVerifierSettings(bool allowUnsigned, bool allowIllegal, bool allowUntrusted, bool allowIgnoreTimestamp, bool allowMultipleTimestamps, bool allowNoTimestamp, bool allowUnknownRevocation, bool reportUnknownRevocation, NuGet.Packaging.Signing.VerificationTarget verificationTarget, NuGet.Packaging.Signing.SignaturePlacement signaturePlacement, NuGet.Packaging.Signing.SignatureVerificationBehavior repositoryCountersignatureVerificationBehavior, NuGet.Common.RevocationMode revocationMode) -> void
NuGet.Packaging.Signing.SignedPackageVerifierSettings.VerificationTarget.get -> NuGet.Packaging.Signing.VerificationTarget
NuGet.Packaging.Signing.SigningCertificate
NuGet.Packaging.Signing.SigningCertificate.Certificates.get -> System.Collections.Generic.IReadOnlyList<NuGet.Packaging.Signing.EssCertId>
NuGet.Packaging.Signing.SigningCertificate.Policies.get -> System.Collections.Generic.IReadOnlyList<NuGet.Packaging.Signing.PolicyInformation>
NuGet.Packaging.Signing.SigningCertificateV2
NuGet.Packaging.Signing.SigningCertificateV2.Certificates.get -> System.Collections.Generic.IReadOnlyList<NuGet.Packaging.Signing.EssCertIdV2>
NuGet.Packaging.Signing.SigningCertificateV2.Encode() -> byte[]
NuGet.Packaging.Signing.SigningCertificateV2.Policies.get -> System.Collections.Generic.IReadOnlyList<NuGet.Packaging.Signing.PolicyInformation>
NuGet.Packaging.Signing.SigningOptions
NuGet.Packaging.Signing.SigningOptions.Dispose() -> void
NuGet.Packaging.Signing.SigningOptions.InputPackageStream.get -> System.IO.Stream
NuGet.Packaging.Signing.SigningOptions.Logger.get -> NuGet.Common.ILogger
NuGet.Packaging.Signing.SigningOptions.OutputPackageStream.get -> System.IO.Stream
NuGet.Packaging.Signing.SigningOptions.Overwrite.get -> bool
NuGet.Packaging.Signing.SigningOptions.SignatureProvider.get -> NuGet.Packaging.Signing.ISignatureProvider
NuGet.Packaging.Signing.SigningOptions.SigningOptions(System.Lazy<System.IO.Stream> inputPackageStream, System.Lazy<System.IO.Stream> outputPackageStream, bool overwrite, NuGet.Packaging.Signing.ISignatureProvider signatureProvider, NuGet.Common.ILogger logger) -> void
NuGet.Packaging.Signing.SigningSpecifications
NuGet.Packaging.Signing.SigningSpecifications.SigningSpecifications() -> void
NuGet.Packaging.Signing.SigningSpecificationsV1
NuGet.Packaging.Signing.SigningSpecificationsV1.SigningSpecificationsV1() -> void
NuGet.Packaging.Signing.SigningUtility
NuGet.Packaging.Signing.Timestamp
NuGet.Packaging.Signing.Timestamp.GeneralizedTime.get -> System.DateTimeOffset
NuGet.Packaging.Signing.Timestamp.LowerLimit.get -> System.DateTimeOffset
NuGet.Packaging.Signing.Timestamp.SignedCms.get -> System.Security.Cryptography.Pkcs.SignedCms
NuGet.Packaging.Signing.Timestamp.SignerInfo.get -> System.Security.Cryptography.Pkcs.SignerInfo
NuGet.Packaging.Signing.Timestamp.Timestamp() -> void
NuGet.Packaging.Signing.Timestamp.Timestamp(System.Security.Cryptography.Pkcs.SignedCms timestampCms) -> void
NuGet.Packaging.Signing.Timestamp.UpperLimit.get -> System.DateTimeOffset
NuGet.Packaging.Signing.TimestampException
NuGet.Packaging.Signing.TimestampException.TimestampException() -> void
NuGet.Packaging.Signing.TimestampException.TimestampException(NuGet.Common.NuGetLogCode code, string message) -> void
NuGet.Packaging.Signing.TimestampException.TimestampException(NuGet.Common.NuGetLogCode code, string message, System.Exception innerException) -> void
NuGet.Packaging.Signing.TimestampException.TimestampException(string message) -> void
NuGet.Packaging.Signing.TimestampRequest
NuGet.Packaging.Signing.TimestampRequest.HashAlgorithm.get -> NuGet.Common.HashAlgorithmName
NuGet.Packaging.Signing.TimestampRequest.HashedMessage.get -> byte[]
NuGet.Packaging.Signing.TimestampRequest.SigningSpecifications.get -> NuGet.Packaging.Signing.SigningSpecifications
NuGet.Packaging.Signing.TimestampRequest.Target.get -> NuGet.Packaging.Signing.SignaturePlacement
NuGet.Packaging.Signing.TimestampRequest.TimestampRequest(NuGet.Packaging.Signing.SigningSpecifications signingSpecifications, byte[] hashedMessage, NuGet.Common.HashAlgorithmName hashAlgorithm, NuGet.Packaging.Signing.SignaturePlacement target) -> void
NuGet.Packaging.Signing.TrustedSignerAllowListEntry
NuGet.Packaging.Signing.TrustedSignerAllowListEntry.AllowUntrustedRoot.get -> bool
NuGet.Packaging.Signing.TrustedSignerAllowListEntry.Owners.get -> System.Collections.Generic.IReadOnlyList<string>
NuGet.Packaging.Signing.TrustedSignerAllowListEntry.TrustedSignerAllowListEntry(NuGet.Packaging.Signing.VerificationTarget target, NuGet.Packaging.Signing.SignaturePlacement placement, string fingerprint, NuGet.Common.HashAlgorithmName algorithm, bool allowUntrustedRoot = false, System.Collections.Generic.IReadOnlyList<string> owners = null) -> void
NuGet.Packaging.Signing.TrustedSignersProvider
NuGet.Packaging.Signing.TrustedSignersProvider.AddOrUpdateTrustedSigner(NuGet.Configuration.TrustedSignerItem trustedSigner) -> void
NuGet.Packaging.Signing.TrustedSignersProvider.GetTrustedSigners() -> System.Collections.Generic.IReadOnlyList<NuGet.Configuration.TrustedSignerItem>
NuGet.Packaging.Signing.TrustedSignersProvider.Remove(System.Collections.Generic.IReadOnlyList<NuGet.Configuration.TrustedSignerItem> trustedSigners) -> void
NuGet.Packaging.Signing.TrustedSignersProvider.TrustedSignersProvider(NuGet.Configuration.ISettings settings) -> void
NuGet.Packaging.Signing.TstInfo
NuGet.Packaging.Signing.TstInfo.Accuracy.get -> NuGet.Packaging.Signing.Accuracy
NuGet.Packaging.Signing.TstInfo.Extensions.get -> System.Security.Cryptography.X509Certificates.X509ExtensionCollection
NuGet.Packaging.Signing.TstInfo.GenTime.get -> System.DateTimeOffset
NuGet.Packaging.Signing.TstInfo.MessageImprint.get -> NuGet.Packaging.Signing.MessageImprint
NuGet.Packaging.Signing.TstInfo.Nonce.get -> byte[]
NuGet.Packaging.Signing.TstInfo.Ordering.get -> bool
NuGet.Packaging.Signing.TstInfo.Policy.get -> System.Security.Cryptography.Oid
NuGet.Packaging.Signing.TstInfo.SerialNumber.get -> byte[]
NuGet.Packaging.Signing.TstInfo.Tsa.get -> byte[]
NuGet.Packaging.Signing.TstInfo.Version.get -> int
NuGet.Packaging.Signing.UnknownPrimarySignature
NuGet.Packaging.Signing.UnknownPrimarySignature.UnknownPrimarySignature(System.Security.Cryptography.Pkcs.SignedCms signedCms) -> void
NuGet.Packaging.Signing.UnsignedPackageVerificationResult
NuGet.Packaging.Signing.UnsignedPackageVerificationResult.UnsignedPackageVerificationResult(NuGet.Packaging.Signing.SignatureVerificationStatus trust, System.Collections.Generic.IEnumerable<NuGet.Packaging.Signing.SignatureLog> issues) -> void
NuGet.Packaging.Signing.VerificationAllowListEntry
NuGet.Packaging.Signing.VerificationAllowListEntry.Placement.get -> NuGet.Packaging.Signing.SignaturePlacement
NuGet.Packaging.Signing.VerificationAllowListEntry.Target.get -> NuGet.Packaging.Signing.VerificationTarget
NuGet.Packaging.Signing.VerificationAllowListEntry.VerificationAllowListEntry(NuGet.Packaging.Signing.VerificationTarget target, NuGet.Packaging.Signing.SignaturePlacement placement) -> void
NuGet.Packaging.Signing.VerificationTarget
NuGet.Packaging.Signing.VerificationTarget.All = NuGet.Packaging.Signing.VerificationTarget.Unknown | NuGet.Packaging.Signing.VerificationTarget.Author | NuGet.Packaging.Signing.VerificationTarget.Repository -> NuGet.Packaging.Signing.VerificationTarget
NuGet.Packaging.Signing.VerificationTarget.Author = 4 -> NuGet.Packaging.Signing.VerificationTarget
NuGet.Packaging.Signing.VerificationTarget.None = 0 -> NuGet.Packaging.Signing.VerificationTarget
NuGet.Packaging.Signing.VerificationTarget.Repository = 8 -> NuGet.Packaging.Signing.VerificationTarget
NuGet.Packaging.Signing.VerificationTarget.Unknown = 2 -> NuGet.Packaging.Signing.VerificationTarget
NuGet.Packaging.Signing.VerificationUtility
NuGet.Packaging.Signing.VerifySignaturesResult
NuGet.Packaging.Signing.VerifySignaturesResult.IsSigned.get -> bool
NuGet.Packaging.Signing.VerifySignaturesResult.IsValid.get -> bool
NuGet.Packaging.Signing.VerifySignaturesResult.Results.get -> System.Collections.Generic.IReadOnlyList<NuGet.Packaging.Signing.PackageVerificationResult>
NuGet.Packaging.Signing.VerifySignaturesResult.VerifySignaturesResult(bool isValid, bool isSigned) -> void
NuGet.Packaging.Signing.VerifySignaturesResult.VerifySignaturesResult(bool isValid, bool isSigned, System.Collections.Generic.IEnumerable<NuGet.Packaging.Signing.PackageVerificationResult> results) -> void
NuGet.Packaging.Signing.X509CertificateChain
NuGet.Packaging.Signing.X509CertificateChain.Dispose() -> void
NuGet.Packaging.Signing.X509CertificateChain.X509CertificateChain() -> void
NuGet.Packaging.Signing.X509ChainHolder
NuGet.Packaging.Signing.X509ChainHolder.Chain.get -> System.Security.Cryptography.X509Certificates.X509Chain
NuGet.Packaging.Signing.X509ChainHolder.Dispose() -> void
NuGet.Packaging.Signing.X509ChainHolder.X509ChainHolder() -> void
NuGet.Packaging.Signing.X509SignatureProvider
NuGet.Packaging.Signing.X509SignatureProvider.CreatePrimarySignatureAsync(NuGet.Packaging.Signing.SignPackageRequest request, NuGet.Packaging.Signing.SignatureContent signatureContent, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Packaging.Signing.PrimarySignature>
NuGet.Packaging.Signing.X509SignatureProvider.CreateRepositoryCountersignatureAsync(NuGet.Packaging.Signing.RepositorySignPackageRequest request, NuGet.Packaging.Signing.PrimarySignature primarySignature, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Packaging.Signing.PrimarySignature>
NuGet.Packaging.Signing.X509SignatureProvider.X509SignatureProvider(NuGet.Packaging.Signing.ITimestampProvider timestampProvider) -> void
NuGet.Packaging.StreamExtensions
NuGet.Packaging.TopologicalSortUtility
NuGet.Packaging.UnsafePackageEntryException
NuGet.Packaging.UnsafePackageEntryException.UnsafePackageEntryException(string message) -> void
NuGet.Packaging.VersionFolderPathResolver
NuGet.Packaging.VersionFolderPathResolver.GetHashFileName(string packageId, NuGet.Versioning.NuGetVersion version) -> string
NuGet.Packaging.VersionFolderPathResolver.GetHashPath(string packageId, NuGet.Versioning.NuGetVersion version) -> string
NuGet.Packaging.VersionFolderPathResolver.GetManifestFilePath(string packageId, NuGet.Versioning.NuGetVersion version) -> string
NuGet.Packaging.VersionFolderPathResolver.GetNupkgMetadataPath(string packageId, NuGet.Versioning.NuGetVersion version) -> string
NuGet.Packaging.VersionFolderPathResolver.GetPackageDownloadMarkerFileName(string packageId) -> string
NuGet.Packaging.VersionFolderPathResolver.GetPackageFilePath(string packageId, NuGet.Versioning.NuGetVersion version) -> string
NuGet.Packaging.VersionFolderPathResolver.GetVersionListPath(string packageId) -> string
NuGet.Packaging.VersionFolderPathResolver.IsLowerCase.get -> bool
NuGet.Packaging.VersionFolderPathResolver.RootPath.get -> string
NuGet.Packaging.VersionFolderPathResolver.VersionFolderPathResolver(string rootPath) -> void
NuGet.Packaging.VersionFolderPathResolver.VersionFolderPathResolver(string rootPath, bool isLowercase) -> void
NuGet.Packaging.XElementExtensions
NuGet.Packaging.XmlDocFileSaveMode
NuGet.Packaging.XmlDocFileSaveMode.Compress = 2 -> NuGet.Packaging.XmlDocFileSaveMode
NuGet.Packaging.XmlDocFileSaveMode.None = 0 -> NuGet.Packaging.XmlDocFileSaveMode
NuGet.Packaging.XmlDocFileSaveMode.Skip = 1 -> NuGet.Packaging.XmlDocFileSaveMode
NuGet.Packaging.XmlUtility
NuGet.Packaging.ZipArchiveExtensions
NuGet.Packaging.ZipFilePair
NuGet.Packaging.ZipFilePair.FileFullPath.get -> string
NuGet.Packaging.ZipFilePair.IsInstalled() -> bool
NuGet.Packaging.ZipFilePair.PackageEntry.get -> System.IO.Compression.ZipArchiveEntry
NuGet.Packaging.ZipFilePair.ZipFilePair(string fileFullPath, System.IO.Compression.ZipArchiveEntry entry) -> void
NuGet.RuntimeModel.CompatibilityProfile
NuGet.RuntimeModel.CompatibilityProfile.Clone() -> NuGet.RuntimeModel.CompatibilityProfile
NuGet.RuntimeModel.CompatibilityProfile.CompatibilityProfile(string name) -> void
NuGet.RuntimeModel.CompatibilityProfile.CompatibilityProfile(string name, System.Collections.Generic.IEnumerable<NuGet.Frameworks.FrameworkRuntimePair> restoreContexts) -> void
NuGet.RuntimeModel.CompatibilityProfile.Equals(NuGet.RuntimeModel.CompatibilityProfile other) -> bool
NuGet.RuntimeModel.CompatibilityProfile.Name.get -> string
NuGet.RuntimeModel.CompatibilityProfile.RestoreContexts.get -> System.Collections.Generic.IList<NuGet.Frameworks.FrameworkRuntimePair>
NuGet.RuntimeModel.IObjectWriter
NuGet.RuntimeModel.IObjectWriter.WriteArrayEnd() -> void
NuGet.RuntimeModel.IObjectWriter.WriteArrayStart(string name) -> void
NuGet.RuntimeModel.IObjectWriter.WriteNameArray(string name, System.Collections.Generic.IEnumerable<string> values) -> void
NuGet.RuntimeModel.IObjectWriter.WriteNameValue(string name, bool value) -> void
NuGet.RuntimeModel.IObjectWriter.WriteNameValue(string name, int value) -> void
NuGet.RuntimeModel.IObjectWriter.WriteNameValue(string name, string value) -> void
NuGet.RuntimeModel.IObjectWriter.WriteObjectEnd() -> void
NuGet.RuntimeModel.IObjectWriter.WriteObjectStart() -> void
NuGet.RuntimeModel.IObjectWriter.WriteObjectStart(string name) -> void
NuGet.RuntimeModel.JsonObjectWriter
NuGet.RuntimeModel.JsonObjectWriter.Dispose() -> void
NuGet.RuntimeModel.JsonObjectWriter.JsonObjectWriter(Newtonsoft.Json.JsonWriter writer) -> void
NuGet.RuntimeModel.JsonObjectWriter.WriteArrayEnd() -> void
NuGet.RuntimeModel.JsonObjectWriter.WriteArrayStart(string name) -> void
NuGet.RuntimeModel.JsonObjectWriter.WriteNameArray(string name, System.Collections.Generic.IEnumerable<string> values) -> void
NuGet.RuntimeModel.JsonObjectWriter.WriteNameValue(string name, bool value) -> void
NuGet.RuntimeModel.JsonObjectWriter.WriteNameValue(string name, int value) -> void
NuGet.RuntimeModel.JsonObjectWriter.WriteNameValue(string name, string value) -> void
NuGet.RuntimeModel.JsonObjectWriter.WriteObjectEnd() -> void
NuGet.RuntimeModel.JsonObjectWriter.WriteObjectStart() -> void
NuGet.RuntimeModel.JsonObjectWriter.WriteObjectStart(string name) -> void
NuGet.RuntimeModel.JsonRuntimeFormat
NuGet.RuntimeModel.RuntimeDependencySet
NuGet.RuntimeModel.RuntimeDependencySet.Clone() -> NuGet.RuntimeModel.RuntimeDependencySet
NuGet.RuntimeModel.RuntimeDependencySet.Dependencies.get -> System.Collections.Generic.IReadOnlyDictionary<string, NuGet.RuntimeModel.RuntimePackageDependency>
NuGet.RuntimeModel.RuntimeDependencySet.Equals(NuGet.RuntimeModel.RuntimeDependencySet other) -> bool
NuGet.RuntimeModel.RuntimeDependencySet.Id.get -> string
NuGet.RuntimeModel.RuntimeDependencySet.RuntimeDependencySet(string id) -> void
NuGet.RuntimeModel.RuntimeDependencySet.RuntimeDependencySet(string id, System.Collections.Generic.IEnumerable<NuGet.RuntimeModel.RuntimePackageDependency> dependencies) -> void
NuGet.RuntimeModel.RuntimeDescription
NuGet.RuntimeModel.RuntimeDescription.Clone() -> NuGet.RuntimeModel.RuntimeDescription
NuGet.RuntimeModel.RuntimeDescription.Equals(NuGet.RuntimeModel.RuntimeDescription other) -> bool
NuGet.RuntimeModel.RuntimeDescription.InheritedRuntimes.get -> System.Collections.Generic.IReadOnlyList<string>
NuGet.RuntimeModel.RuntimeDescription.RuntimeDependencySets.get -> System.Collections.Generic.IReadOnlyDictionary<string, NuGet.RuntimeModel.RuntimeDependencySet>
NuGet.RuntimeModel.RuntimeDescription.RuntimeDescription(string runtimeIdentifier) -> void
NuGet.RuntimeModel.RuntimeDescription.RuntimeDescription(string runtimeIdentifier, System.Collections.Generic.IEnumerable<NuGet.RuntimeModel.RuntimeDependencySet> runtimeDependencySets) -> void
NuGet.RuntimeModel.RuntimeDescription.RuntimeDescription(string runtimeIdentifier, System.Collections.Generic.IEnumerable<string> inheritedRuntimes) -> void
NuGet.RuntimeModel.RuntimeDescription.RuntimeDescription(string runtimeIdentifier, System.Collections.Generic.IEnumerable<string> inheritedRuntimes, System.Collections.Generic.IEnumerable<NuGet.RuntimeModel.RuntimeDependencySet> runtimeDependencySets) -> void
NuGet.RuntimeModel.RuntimeDescription.RuntimeIdentifier.get -> string
NuGet.RuntimeModel.RuntimeGraph
NuGet.RuntimeModel.RuntimeGraph.AreCompatible(string criteria, string provided) -> bool
NuGet.RuntimeModel.RuntimeGraph.Clone() -> NuGet.RuntimeModel.RuntimeGraph
NuGet.RuntimeModel.RuntimeGraph.Equals(NuGet.RuntimeModel.RuntimeGraph other) -> bool
NuGet.RuntimeModel.RuntimeGraph.ExpandRuntime(string runtime) -> System.Collections.Generic.IEnumerable<string>
NuGet.RuntimeModel.RuntimeGraph.FindRuntimeDependencies(string runtimeName, string packageId) -> System.Collections.Generic.IEnumerable<NuGet.RuntimeModel.RuntimePackageDependency>
NuGet.RuntimeModel.RuntimeGraph.RuntimeGraph() -> void
NuGet.RuntimeModel.RuntimeGraph.RuntimeGraph(System.Collections.Generic.IEnumerable<NuGet.RuntimeModel.CompatibilityProfile> supports) -> void
NuGet.RuntimeModel.RuntimeGraph.RuntimeGraph(System.Collections.Generic.IEnumerable<NuGet.RuntimeModel.RuntimeDescription> runtimes) -> void
NuGet.RuntimeModel.RuntimeGraph.RuntimeGraph(System.Collections.Generic.IEnumerable<NuGet.RuntimeModel.RuntimeDescription> runtimes, System.Collections.Generic.IEnumerable<NuGet.RuntimeModel.CompatibilityProfile> supports) -> void
NuGet.RuntimeModel.RuntimeGraph.Runtimes.get -> System.Collections.Generic.IReadOnlyDictionary<string, NuGet.RuntimeModel.RuntimeDescription>
NuGet.RuntimeModel.RuntimeGraph.Supports.get -> System.Collections.Generic.IReadOnlyDictionary<string, NuGet.RuntimeModel.CompatibilityProfile>
NuGet.RuntimeModel.RuntimeGraph.Supports.set -> void
NuGet.RuntimeModel.RuntimePackageDependency
NuGet.RuntimeModel.RuntimePackageDependency.Clone() -> NuGet.RuntimeModel.RuntimePackageDependency
NuGet.RuntimeModel.RuntimePackageDependency.Equals(NuGet.RuntimeModel.RuntimePackageDependency other) -> bool
NuGet.RuntimeModel.RuntimePackageDependency.Id.get -> string
NuGet.RuntimeModel.RuntimePackageDependency.RuntimePackageDependency(string id, NuGet.Versioning.VersionRange versionRange) -> void
NuGet.RuntimeModel.RuntimePackageDependency.VersionRange.get -> NuGet.Versioning.VersionRange
abstract NuGet.Packaging.PackageReaderBase.CanVerifySignedPackages(NuGet.Packaging.Signing.SignedPackageVerifierSettings verifierSettings) -> bool
abstract NuGet.Packaging.PackageReaderBase.CopyFiles(string destination, System.Collections.Generic.IEnumerable<string> packageFiles, NuGet.Packaging.Core.ExtractPackageFileDelegate extractFile, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Collections.Generic.IEnumerable<string>
abstract NuGet.Packaging.PackageReaderBase.Dispose(bool disposing) -> void
abstract NuGet.Packaging.PackageReaderBase.GetArchiveHashAsync(NuGet.Common.HashAlgorithmName hashAlgorithm, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<byte[]>
abstract NuGet.Packaging.PackageReaderBase.GetContentHash(System.Threading.CancellationToken token, System.Func<string> GetUnsignedPackageHash = null) -> string
abstract NuGet.Packaging.PackageReaderBase.GetFiles() -> System.Collections.Generic.IEnumerable<string>
abstract NuGet.Packaging.PackageReaderBase.GetFiles(string folder) -> System.Collections.Generic.IEnumerable<string>
abstract NuGet.Packaging.PackageReaderBase.GetPrimarySignatureAsync(System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Packaging.Signing.PrimarySignature>
abstract NuGet.Packaging.PackageReaderBase.GetStream(string path) -> System.IO.Stream
abstract NuGet.Packaging.PackageReaderBase.IsSignedAsync(System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<bool>
abstract NuGet.Packaging.PackageReaderBase.ValidateIntegrityAsync(NuGet.Packaging.Signing.SignatureContent signatureContent, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task
abstract NuGet.Packaging.Signing.SignPackageRequest.SignatureType.get -> NuGet.Packaging.Signing.SignatureType
abstract NuGet.Packaging.Signing.Signature.GetSignatureValue() -> byte[]
abstract NuGet.Packaging.Signing.Signature.ThrowForInvalidSignature() -> void
abstract NuGet.Packaging.Signing.SigningSpecifications.AllowedHashAlgorithmOids.get -> string[]
abstract NuGet.Packaging.Signing.SigningSpecifications.AllowedHashAlgorithms.get -> NuGet.Common.HashAlgorithmName[]
abstract NuGet.Packaging.Signing.SigningSpecifications.AllowedSignatureAlgorithmOids.get -> string[]
abstract NuGet.Packaging.Signing.SigningSpecifications.AllowedSignatureAlgorithms.get -> NuGet.Common.SignatureAlgorithmName[]
abstract NuGet.Packaging.Signing.SigningSpecifications.Encoding.get -> System.Text.Encoding
abstract NuGet.Packaging.Signing.SigningSpecifications.RSAPublicKeyMinLength.get -> int
abstract NuGet.Packaging.Signing.SigningSpecifications.SignaturePath.get -> string
abstract NuGet.Packaging.Signing.SigningSpecifications.Version.get -> string
const NuGet.Packaging.Core.NuspecCoreReaderBase.DevelopmentDependency = "developmentDependency" -> string
const NuGet.Packaging.Core.NuspecCoreReaderBase.Id = "id" -> string
const NuGet.Packaging.Core.NuspecCoreReaderBase.Metadata = "metadata" -> string
const NuGet.Packaging.Core.NuspecCoreReaderBase.MinClientVersion = "minClientVersion" -> string
const NuGet.Packaging.Core.NuspecCoreReaderBase.Version = "version" -> string
const NuGet.Packaging.ManifestVersionUtility.DefaultVersion = 1 -> int
const NuGet.Packaging.ManifestVersionUtility.SemverVersion = 3 -> int
const NuGet.Packaging.ManifestVersionUtility.TargetFrameworkSupportForDependencyContentsAndToolsVersion = 4 -> int
const NuGet.Packaging.ManifestVersionUtility.TargetFrameworkSupportForReferencesVersion = 5 -> int
const NuGet.Packaging.ManifestVersionUtility.XdtTransformationVersion = 6 -> int
const NuGet.Packaging.PackageBuilder.MaxIconFileSize = 1048576 -> int
const NuGet.Packaging.PackageExtractionTelemetryEvent.EventName = "PackageExtractionInformation" -> string
const NuGet.Packaging.PackageIdValidator.MaxPackageIdLength = 100 -> int
const NuGet.Packaging.PackageSigningTelemetryEvent.EventName = "SigningInformation" -> string
const NuGet.Packaging.Signing.Oids.AnyPolicy = "2.5.29.32.0" -> string
const NuGet.Packaging.Signing.Oids.AuthorityKeyIdentifier = "2.5.29.35" -> string
const NuGet.Packaging.Signing.Oids.BaselineTimestampPolicy = "0.4.0.2023.1.1" -> string
const NuGet.Packaging.Signing.Oids.CodeSigningEku = "1.3.6.1.5.5.7.3.3" -> string
const NuGet.Packaging.Signing.Oids.CommitmentTypeIdentifierProofOfOrigin = "1.2.840.113549.1.9.16.6.1" -> string
const NuGet.Packaging.Signing.Oids.CommitmentTypeIdentifierProofOfReceipt = "1.2.840.113549.1.9.16.6.2" -> string
const NuGet.Packaging.Signing.Oids.CommitmentTypeIndication = "1.2.840.113549.1.9.16.2.16" -> string
const NuGet.Packaging.Signing.Oids.Countersignature = "1.2.840.113549.1.9.6" -> string
const NuGet.Packaging.Signing.Oids.EnhancedKeyUsage = "2.5.29.37" -> string
const NuGet.Packaging.Signing.Oids.IdQtCps = "1.3.6.1.5.5.7.2.1" -> string
const NuGet.Packaging.Signing.Oids.IdQtUnotice = "1.3.6.1.5.5.7.2.2" -> string
const NuGet.Packaging.Signing.Oids.LifetimeSigningEku = "1.3.6.1.4.1.311.10.3.13" -> string
const NuGet.Packaging.Signing.Oids.NuGetPackageOwners = "1.3.6.1.4.1.311.84.2.1.1.2" -> string
const NuGet.Packaging.Signing.Oids.NuGetV3ServiceIndexUrl = "1.3.6.1.4.1.311.84.2.1.1.1" -> string
const NuGet.Packaging.Signing.Oids.Pkcs7Data = "1.2.840.113549.1.7.1" -> string
const NuGet.Packaging.Signing.Oids.Sha1 = "1.3.14.3.2.26" -> string
const NuGet.Packaging.Signing.Oids.Sha256 = "2.16.840.1.101.3.4.2.1" -> string
const NuGet.Packaging.Signing.Oids.Sha256WithRSAEncryption = "1.2.840.113549.1.1.11" -> string
const NuGet.Packaging.Signing.Oids.Sha384 = "2.16.840.1.101.3.4.2.2" -> string
const NuGet.Packaging.Signing.Oids.Sha384WithRSAEncryption = "1.2.840.113549.1.1.12" -> string
const NuGet.Packaging.Signing.Oids.Sha512 = "2.16.840.1.101.3.4.2.3" -> string
const NuGet.Packaging.Signing.Oids.Sha512WithRSAEncryption = "1.2.840.113549.1.1.13" -> string
const NuGet.Packaging.Signing.Oids.SignatureTimeStampTokenAttribute = "1.2.840.113549.1.9.16.2.14" -> string
const NuGet.Packaging.Signing.Oids.SigningCertificate = "1.2.840.113549.1.9.16.2.12" -> string
const NuGet.Packaging.Signing.Oids.SigningCertificateV2 = "1.2.840.113549.1.9.16.2.47" -> string
const NuGet.Packaging.Signing.Oids.SigningTime = "1.2.840.113549.1.9.5" -> string
const NuGet.Packaging.Signing.Oids.SubjectKeyIdentifier = "2.5.29.14" -> string
const NuGet.Packaging.Signing.Oids.TSTInfoContentType = "1.2.840.113549.1.9.16.1.4" -> string
const NuGet.Packaging.Signing.Oids.TimeStampingEku = "1.3.6.1.5.5.7.3.8" -> string
const NuGet.Packaging.Signing.Rfc3161TimestampTokenInfo.TimestampTokenInfoId = "1.2.840.113549.1.9.16.1.4" -> string
override NuGet.ContentModel.Asset.ToString() -> string
override NuGet.ContentModel.ContentItem.ToString() -> string
override NuGet.ContentModel.SelectionCriteriaEntryBuilder.Add.get -> NuGet.ContentModel.SelectionCriteriaEntryBuilder
override NuGet.ContentModel.SelectionCriteriaEntryBuilder.Criteria.get -> NuGet.ContentModel.SelectionCriteria
override NuGet.Packaging.Core.PackageDependency.Equals(object obj) -> bool
override NuGet.Packaging.Core.PackageDependency.GetHashCode() -> int
override NuGet.Packaging.Core.PackageDependency.ToString() -> string
override NuGet.Packaging.Core.PackageDependencyInfo.Equals(object obj) -> bool
override NuGet.Packaging.Core.PackageDependencyInfo.GetHashCode() -> int
override NuGet.Packaging.Core.PackageDependencyInfo.ToString() -> string
override NuGet.Packaging.Core.PackageIdentity.Equals(object obj) -> bool
override NuGet.Packaging.Core.PackageIdentity.GetHashCode() -> int
override NuGet.Packaging.Core.PackageIdentity.ToString() -> string
override NuGet.Packaging.Core.PackageType.Equals(object obj) -> bool
override NuGet.Packaging.Core.PackageType.GetHashCode() -> int
override NuGet.Packaging.Core.RepositoryMetadata.Equals(object obj) -> bool
override NuGet.Packaging.Core.RepositoryMetadata.GetHashCode() -> int
override NuGet.Packaging.FrameworkReference.Equals(object obj) -> bool
override NuGet.Packaging.FrameworkReference.GetHashCode() -> int
override NuGet.Packaging.FrameworkReferenceGroup.Equals(object obj) -> bool
override NuGet.Packaging.FrameworkReferenceGroup.GetHashCode() -> int
override NuGet.Packaging.FrameworkSpecificGroup.Equals(object obj) -> bool
override NuGet.Packaging.FrameworkSpecificGroup.GetHashCode() -> int
override NuGet.Packaging.LicenseMetadata.Equals(object obj) -> bool
override NuGet.Packaging.LicenseMetadata.GetHashCode() -> int
override NuGet.Packaging.Licenses.LogicalOperator.ToString() -> string
override NuGet.Packaging.Licenses.NuGetLicense.ToString() -> string
override NuGet.Packaging.Licenses.NuGetLicenseException.ToString() -> string
override NuGet.Packaging.Licenses.WithOperator.ToString() -> string
override NuGet.Packaging.MinClientVersionException.AsLogMessage() -> NuGet.Common.ILogMessage
override NuGet.Packaging.NupkgMetadataFile.Equals(object obj) -> bool
override NuGet.Packaging.NupkgMetadataFile.GetHashCode() -> int
override NuGet.Packaging.PackageArchiveReader.CanVerifySignedPackages(NuGet.Packaging.Signing.SignedPackageVerifierSettings verifierSettings) -> bool
override NuGet.Packaging.PackageArchiveReader.CopyFiles(string destination, System.Collections.Generic.IEnumerable<string> packageFiles, NuGet.Packaging.Core.ExtractPackageFileDelegate extractFile, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Collections.Generic.IEnumerable<string>
override NuGet.Packaging.PackageArchiveReader.Dispose(bool disposing) -> void
override NuGet.Packaging.PackageArchiveReader.GetArchiveHashAsync(NuGet.Common.HashAlgorithmName hashAlgorithmName, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<byte[]>
override NuGet.Packaging.PackageArchiveReader.GetContentHash(System.Threading.CancellationToken token, System.Func<string> GetUnsignedPackageHash = null) -> string
override NuGet.Packaging.PackageArchiveReader.GetFiles() -> System.Collections.Generic.IEnumerable<string>
override NuGet.Packaging.PackageArchiveReader.GetFiles(string folder) -> System.Collections.Generic.IEnumerable<string>
override NuGet.Packaging.PackageArchiveReader.GetPrimarySignatureAsync(System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Packaging.Signing.PrimarySignature>
override NuGet.Packaging.PackageArchiveReader.GetStream(string path) -> System.IO.Stream
override NuGet.Packaging.PackageArchiveReader.IsSignedAsync(System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<bool>
override NuGet.Packaging.PackageArchiveReader.ValidateIntegrityAsync(NuGet.Packaging.Signing.SignatureContent signatureContent, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task
override NuGet.Packaging.PackageDependencyGroup.Equals(object obj) -> bool
override NuGet.Packaging.PackageDependencyGroup.GetHashCode() -> int
override NuGet.Packaging.PackageDependencyGroup.ToString() -> string
override NuGet.Packaging.PackageFolderReader.CanVerifySignedPackages(NuGet.Packaging.Signing.SignedPackageVerifierSettings verifierSettings) -> bool
override NuGet.Packaging.PackageFolderReader.CopyFiles(string destination, System.Collections.Generic.IEnumerable<string> packageFiles, NuGet.Packaging.Core.ExtractPackageFileDelegate extractFile, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Collections.Generic.IEnumerable<string>
override NuGet.Packaging.PackageFolderReader.Dispose(bool disposing) -> void
override NuGet.Packaging.PackageFolderReader.GetArchiveHashAsync(NuGet.Common.HashAlgorithmName hashAlgorithm, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<byte[]>
override NuGet.Packaging.PackageFolderReader.GetContentHash(System.Threading.CancellationToken token, System.Func<string> GetUnsignedPackageHash = null) -> string
override NuGet.Packaging.PackageFolderReader.GetFiles() -> System.Collections.Generic.IEnumerable<string>
override NuGet.Packaging.PackageFolderReader.GetFiles(string folder) -> System.Collections.Generic.IEnumerable<string>
override NuGet.Packaging.PackageFolderReader.GetNuspecFile() -> string
override NuGet.Packaging.PackageFolderReader.GetPrimarySignatureAsync(System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.Packaging.Signing.PrimarySignature>
override NuGet.Packaging.PackageFolderReader.GetStream(string path) -> System.IO.Stream
override NuGet.Packaging.PackageFolderReader.IsSignedAsync(System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<bool>
override NuGet.Packaging.PackageFolderReader.ValidateIntegrityAsync(NuGet.Packaging.Signing.SignatureContent signatureContent, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task
override NuGet.Packaging.PackageReference.ToString() -> string
override NuGet.Packaging.PhysicalPackageFile.Equals(object obj) -> bool
override NuGet.Packaging.PhysicalPackageFile.GetHashCode() -> int
override NuGet.Packaging.PhysicalPackageFile.ToString() -> string
override NuGet.Packaging.Signing.AuthorPrimarySignature.FriendlyName.get -> string
override NuGet.Packaging.Signing.AuthorPrimarySignature.Verify(NuGet.Packaging.Signing.Timestamp timestamp, NuGet.Packaging.Signing.SignatureVerifySettings settings, NuGet.Common.HashAlgorithmName fingerprintAlgorithm, System.Security.Cryptography.X509Certificates.X509Certificate2Collection certificateExtraStore) -> NuGet.Packaging.Signing.SignatureVerificationSummary
override NuGet.Packaging.Signing.AuthorSignPackageRequest.SignatureType.get -> NuGet.Packaging.Signing.SignatureType
override NuGet.Packaging.Signing.CertificateHashAllowListEntry.Equals(object obj) -> bool
override NuGet.Packaging.Signing.CertificateHashAllowListEntry.GetHashCode() -> int
override NuGet.Packaging.Signing.PrimarySignature.FriendlyName.get -> string
override NuGet.Packaging.Signing.PrimarySignature.GetSignatureValue() -> byte[]
override NuGet.Packaging.Signing.PrimarySignature.ThrowForInvalidSignature() -> void
override NuGet.Packaging.Signing.ReadOnlyBufferedStream.CanRead.get -> bool
override NuGet.Packaging.Signing.ReadOnlyBufferedStream.CanSeek.get -> bool
override NuGet.Packaging.Signing.ReadOnlyBufferedStream.CanTimeout.get -> bool
override NuGet.Packaging.Signing.ReadOnlyBufferedStream.CanWrite.get -> bool
override NuGet.Packaging.Signing.ReadOnlyBufferedStream.CopyToAsync(System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
override NuGet.Packaging.Signing.ReadOnlyBufferedStream.Flush() -> void
override NuGet.Packaging.Signing.ReadOnlyBufferedStream.FlushAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
override NuGet.Packaging.Signing.ReadOnlyBufferedStream.Length.get -> long
override NuGet.Packaging.Signing.ReadOnlyBufferedStream.Position.get -> long
override NuGet.Packaging.Signing.ReadOnlyBufferedStream.Position.set -> void
override NuGet.Packaging.Signing.ReadOnlyBufferedStream.Read(byte[] buffer, int offset, int count) -> int
override NuGet.Packaging.Signing.ReadOnlyBufferedStream.ReadByte() -> int
override NuGet.Packaging.Signing.ReadOnlyBufferedStream.ReadTimeout.get -> int
override NuGet.Packaging.Signing.ReadOnlyBufferedStream.ReadTimeout.set -> void
override NuGet.Packaging.Signing.ReadOnlyBufferedStream.Seek(long offset, System.IO.SeekOrigin origin) -> long
override NuGet.Packaging.Signing.ReadOnlyBufferedStream.SetLength(long value) -> void
override NuGet.Packaging.Signing.ReadOnlyBufferedStream.Write(byte[] buffer, int offset, int count) -> void
override NuGet.Packaging.Signing.ReadOnlyBufferedStream.WriteAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
override NuGet.Packaging.Signing.ReadOnlyBufferedStream.WriteByte(byte value) -> void
override NuGet.Packaging.Signing.ReadOnlyBufferedStream.WriteTimeout.get -> int
override NuGet.Packaging.Signing.ReadOnlyBufferedStream.WriteTimeout.set -> void
override NuGet.Packaging.Signing.RepositoryCountersignature.FriendlyName.get -> string
override NuGet.Packaging.Signing.RepositoryCountersignature.GetSignatureValue() -> byte[]
override NuGet.Packaging.Signing.RepositoryCountersignature.Verify(NuGet.Packaging.Signing.Timestamp timestamp, NuGet.Packaging.Signing.SignatureVerifySettings settings, NuGet.Common.HashAlgorithmName fingerprintAlgorithm, System.Security.Cryptography.X509Certificates.X509Certificate2Collection certificateExtraStore) -> NuGet.Packaging.Signing.SignatureVerificationSummary
override NuGet.Packaging.Signing.RepositoryPrimarySignature.FriendlyName.get -> string
override NuGet.Packaging.Signing.RepositoryPrimarySignature.Verify(NuGet.Packaging.Signing.Timestamp timestamp, NuGet.Packaging.Signing.SignatureVerifySettings settings, NuGet.Common.HashAlgorithmName fingerprintAlgorithm, System.Security.Cryptography.X509Certificates.X509Certificate2Collection certificateExtraStore) -> NuGet.Packaging.Signing.SignatureVerificationSummary
override NuGet.Packaging.Signing.RepositorySignPackageRequest.SignatureType.get -> NuGet.Packaging.Signing.SignatureType
override NuGet.Packaging.Signing.Rfc3161TimestampTokenInfo.CopyFrom(System.Security.Cryptography.AsnEncodedData asnEncodedData) -> void
override NuGet.Packaging.Signing.SignedPackageArchive.Dispose(bool disposing) -> void
override NuGet.Packaging.Signing.SigningSpecificationsV1.AllowedHashAlgorithmOids.get -> string[]
override NuGet.Packaging.Signing.SigningSpecificationsV1.AllowedHashAlgorithms.get -> NuGet.Common.HashAlgorithmName[]
override NuGet.Packaging.Signing.SigningSpecificationsV1.AllowedSignatureAlgorithmOids.get -> string[]
override NuGet.Packaging.Signing.SigningSpecificationsV1.AllowedSignatureAlgorithms.get -> NuGet.Common.SignatureAlgorithmName[]
override NuGet.Packaging.Signing.SigningSpecificationsV1.Encoding.get -> System.Text.Encoding
override NuGet.Packaging.Signing.SigningSpecificationsV1.RSAPublicKeyMinLength.get -> int
override NuGet.Packaging.Signing.SigningSpecificationsV1.SignaturePath.get -> string
override NuGet.Packaging.Signing.SigningSpecificationsV1.Version.get -> string
override NuGet.Packaging.Signing.TrustedSignerAllowListEntry.Equals(object obj) -> bool
override NuGet.Packaging.Signing.TrustedSignerAllowListEntry.GetHashCode() -> int
override NuGet.Packaging.UnsafePackageEntryException.AsLogMessage() -> NuGet.Common.ILogMessage
override NuGet.RuntimeModel.CompatibilityProfile.Equals(object obj) -> bool
override NuGet.RuntimeModel.CompatibilityProfile.GetHashCode() -> int
override NuGet.RuntimeModel.CompatibilityProfile.ToString() -> string
override NuGet.RuntimeModel.RuntimeDependencySet.Equals(object obj) -> bool
override NuGet.RuntimeModel.RuntimeDependencySet.GetHashCode() -> int
override NuGet.RuntimeModel.RuntimeDependencySet.ToString() -> string
override NuGet.RuntimeModel.RuntimeDescription.Equals(object obj) -> bool
override NuGet.RuntimeModel.RuntimeDescription.GetHashCode() -> int
override NuGet.RuntimeModel.RuntimeDescription.ToString() -> string
override NuGet.RuntimeModel.RuntimeGraph.Equals(object obj) -> bool
override NuGet.RuntimeModel.RuntimeGraph.GetHashCode() -> int
override NuGet.RuntimeModel.RuntimePackageDependency.Equals(object obj) -> bool
override NuGet.RuntimeModel.RuntimePackageDependency.GetHashCode() -> int
override NuGet.RuntimeModel.RuntimePackageDependency.ToString() -> string
static NuGet.ContentModel.PatternDefinition.implicit operator NuGet.ContentModel.PatternDefinition(string pattern) -> NuGet.ContentModel.PatternDefinition
static NuGet.Packaging.CollectionExtensions.AddRange<T>(this System.Collections.Generic.ICollection<T> collection, System.Collections.Generic.IEnumerable<T> items) -> void
static NuGet.Packaging.Core.NuspecUtility.GetPackageTypes(System.Xml.Linq.XElement metadataNode, bool useMetadataNamespace) -> System.Collections.Generic.IReadOnlyList<NuGet.Packaging.Core.PackageType>
static NuGet.Packaging.Core.NuspecUtility.IsServiceable(System.Xml.Linq.XElement metadataNode) -> bool
static NuGet.Packaging.Core.PackageDependencyInfoComparer.Default.get -> NuGet.Packaging.Core.PackageDependencyInfoComparer
static NuGet.Packaging.Core.PackageIdentity.Comparer.get -> NuGet.Packaging.Core.PackageIdentityComparer
static NuGet.Packaging.Core.PackageIdentityComparer.Default.get -> NuGet.Packaging.Core.PackageIdentityComparer
static NuGet.Packaging.Core.PackageType.operator !=(NuGet.Packaging.Core.PackageType a, NuGet.Packaging.Core.PackageType b) -> bool
static NuGet.Packaging.Core.PackageType.operator ==(NuGet.Packaging.Core.PackageType a, NuGet.Packaging.Core.PackageType b) -> bool
static NuGet.Packaging.Core.RepositoryMetadata.operator !=(NuGet.Packaging.Core.RepositoryMetadata a, NuGet.Packaging.Core.RepositoryMetadata b) -> bool
static NuGet.Packaging.Core.RepositoryMetadata.operator ==(NuGet.Packaging.Core.RepositoryMetadata a, NuGet.Packaging.Core.RepositoryMetadata b) -> bool
static NuGet.Packaging.FrameworkNameUtility.ParseFrameworkFolderName(string path, bool strictParsing, out string effectivePath) -> System.Runtime.Versioning.FrameworkName
static NuGet.Packaging.FrameworkNameUtility.ParseFrameworkNameFromFilePath(string filePath, out string effectivePath) -> System.Runtime.Versioning.FrameworkName
static NuGet.Packaging.FrameworkNameUtility.ParseNuGetFrameworkFolderName(string path, bool strictParsing, out string effectivePath) -> NuGet.Frameworks.NuGetFramework
static NuGet.Packaging.FrameworkNameUtility.ParseNuGetFrameworkFromFilePath(string filePath, out string effectivePath) -> NuGet.Frameworks.NuGetFramework
static NuGet.Packaging.FrameworksExtensions.GetFrameworkString(this NuGet.Frameworks.NuGetFramework self) -> string
static NuGet.Packaging.Licenses.NuGetLicenseData.LicenseListVersion -> string
static NuGet.Packaging.Licenses.NuGetLicenseExpression.Parse(string expression) -> NuGet.Packaging.Licenses.NuGetLicenseExpression
static NuGet.Packaging.Licenses.NuGetLicenseExpressionExtensions.HasOnlyStandardIdentifiers(this NuGet.Packaging.Licenses.NuGetLicenseExpression expression) -> bool
static NuGet.Packaging.Licenses.NuGetLicenseExpressionExtensions.IsUnlicensed(this NuGet.Packaging.Licenses.NuGetLicense license) -> bool
static NuGet.Packaging.Licenses.NuGetLicenseExpressionExtensions.IsUnlicensed(this NuGet.Packaging.Licenses.NuGetLicenseExpression expression) -> bool
static NuGet.Packaging.Licenses.NuGetLicenseExpressionExtensions.OnEachLeafNode(this NuGet.Packaging.Licenses.NuGetLicenseExpression expression, System.Action<NuGet.Packaging.Licenses.NuGetLicense> licenseProcessor, System.Action<NuGet.Packaging.Licenses.NuGetLicenseException> exceptionProcessor) -> void
static NuGet.Packaging.Manifest.Create(NuGet.Packaging.IPackageMetadata metadata) -> NuGet.Packaging.Manifest
static NuGet.Packaging.Manifest.ReadFrom(System.IO.Stream stream, System.Func<string, string> propertyProvider, bool validateSchema) -> NuGet.Packaging.Manifest
static NuGet.Packaging.Manifest.ReadFrom(System.IO.Stream stream, bool validateSchema) -> NuGet.Packaging.Manifest
static NuGet.Packaging.Manifest.Validate(NuGet.Packaging.Manifest manifest) -> void
static NuGet.Packaging.ManifestSchemaUtility.GetManifestSchemaSet(string schemaNamespace) -> System.Xml.Schema.XmlSchemaSet
static NuGet.Packaging.ManifestSchemaUtility.GetSchemaNamespace(int version) -> string
static NuGet.Packaging.ManifestSchemaUtility.GetVersionFromNamespace(string namespace) -> int
static NuGet.Packaging.ManifestSchemaUtility.IsKnownSchema(string schemaNamespace) -> bool
static NuGet.Packaging.ManifestVersionUtility.GetManifestVersion(NuGet.Packaging.ManifestMetadata metadata) -> int
static NuGet.Packaging.MinClientVersionUtility.GetNuGetClientVersion() -> NuGet.Versioning.NuGetVersion
static NuGet.Packaging.MinClientVersionUtility.IsMinClientVersionCompatible(NuGet.Packaging.Core.NuspecCoreReaderBase nuspecReader) -> bool
static NuGet.Packaging.MinClientVersionUtility.IsMinClientVersionCompatible(NuGet.Versioning.NuGetVersion packageMinClientVersion) -> bool
static NuGet.Packaging.MinClientVersionUtility.VerifyMinClientVersion(NuGet.Packaging.Core.NuspecCoreReaderBase nuspecReader) -> void
static NuGet.Packaging.NupkgMetadataFileFormat.Read(System.IO.Stream stream, NuGet.Common.ILogger log, string path) -> NuGet.Packaging.NupkgMetadataFile
static NuGet.Packaging.NupkgMetadataFileFormat.Read(System.IO.TextReader reader, NuGet.Common.ILogger log, string path) -> NuGet.Packaging.NupkgMetadataFile
static NuGet.Packaging.NupkgMetadataFileFormat.Read(string filePath) -> NuGet.Packaging.NupkgMetadataFile
static NuGet.Packaging.NupkgMetadataFileFormat.Read(string filePath, NuGet.Common.ILogger log) -> NuGet.Packaging.NupkgMetadataFile
static NuGet.Packaging.NupkgMetadataFileFormat.Write(System.IO.Stream stream, NuGet.Packaging.NupkgMetadataFile hashFile) -> void
static NuGet.Packaging.NupkgMetadataFileFormat.Write(System.IO.TextWriter textWriter, NuGet.Packaging.NupkgMetadataFile hashFile) -> void
static NuGet.Packaging.NupkgMetadataFileFormat.Write(string filePath, NuGet.Packaging.NupkgMetadataFile hashFile) -> void
static NuGet.Packaging.PackageBuilder.ValidateReferenceAssemblies(System.Collections.Generic.IEnumerable<NuGet.Packaging.IPackageFile> files, System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageReferenceSet> packageAssemblyReferences) -> void
static NuGet.Packaging.PackageExtraction.PackageExtractionBehavior.XmlDocFileSaveMode.get -> NuGet.Packaging.XmlDocFileSaveMode
static NuGet.Packaging.PackageExtraction.PackageExtractionBehavior.XmlDocFileSaveMode.set -> void
static NuGet.Packaging.PackageExtractor.CopySatelliteFilesAsync(NuGet.Packaging.Core.PackageIdentity packageIdentity, NuGet.Packaging.PackagePathResolver packagePathResolver, NuGet.Packaging.PackageSaveMode packageSaveMode, NuGet.Packaging.PackageExtractionContext packageExtractionContext, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<string>>
static NuGet.Packaging.PackageExtractor.ExtractPackageAsync(string source, NuGet.Packaging.PackageReaderBase packageReader, NuGet.Packaging.PackagePathResolver packagePathResolver, NuGet.Packaging.PackageExtractionContext packageExtractionContext, System.Threading.CancellationToken token, System.Guid parentId = default(System.Guid)) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<string>>
static NuGet.Packaging.PackageExtractor.ExtractPackageAsync(string source, NuGet.Packaging.PackageReaderBase packageReader, System.IO.Stream packageStream, NuGet.Packaging.PackagePathResolver packagePathResolver, NuGet.Packaging.PackageExtractionContext packageExtractionContext, System.Threading.CancellationToken token, System.Guid parentId = default(System.Guid)) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<string>>
static NuGet.Packaging.PackageExtractor.ExtractPackageAsync(string source, System.IO.Stream packageStream, NuGet.Packaging.PackagePathResolver packagePathResolver, NuGet.Packaging.PackageExtractionContext packageExtractionContext, System.Threading.CancellationToken token, System.Guid parentId = default(System.Guid)) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<string>>
static NuGet.Packaging.PackageExtractor.InstallFromSourceAsync(NuGet.Packaging.Core.PackageIdentity packageIdentity, NuGet.Packaging.IPackageDownloader packageDownloader, NuGet.Packaging.VersionFolderPathResolver versionFolderPathResolver, NuGet.Packaging.PackageExtractionContext packageExtractionContext, System.Threading.CancellationToken token, System.Guid parentId = default(System.Guid)) -> System.Threading.Tasks.Task<bool>
static NuGet.Packaging.PackageExtractor.InstallFromSourceAsync(string source, NuGet.Packaging.Core.PackageIdentity packageIdentity, System.Func<System.IO.Stream, System.Threading.Tasks.Task> copyToAsync, NuGet.Packaging.VersionFolderPathResolver versionFolderPathResolver, NuGet.Packaging.PackageExtractionContext packageExtractionContext, System.Threading.CancellationToken token, System.Guid parentId = default(System.Guid)) -> System.Threading.Tasks.Task<bool>
static NuGet.Packaging.PackageHelper.GetInstalledPackageFilesAsync(NuGet.Packaging.PackageArchiveReader packageReader, NuGet.Packaging.Core.PackageIdentity packageIdentity, NuGet.Packaging.PackagePathResolver packagePathResolver, NuGet.Packaging.PackageSaveMode packageSaveMode, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Packaging.ZipFilePair>>
static NuGet.Packaging.PackageHelper.GetInstalledSatelliteFilesAsync(NuGet.Packaging.PackageArchiveReader packageReader, NuGet.Packaging.PackagePathResolver packagePathResolver, NuGet.Packaging.PackageSaveMode packageSaveMode, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Tuple<string, System.Collections.Generic.IEnumerable<NuGet.Packaging.ZipFilePair>>>
static NuGet.Packaging.PackageHelper.GetSatelliteFilesAsync(NuGet.Packaging.PackageReaderBase packageReader, NuGet.Packaging.PackagePathResolver packagePathResolver, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Tuple<string, System.Collections.Generic.IEnumerable<string>>>
static NuGet.Packaging.PackageHelper.IsAssembly(string path) -> bool
static NuGet.Packaging.PackageHelper.IsManifest(string path) -> bool
static NuGet.Packaging.PackageHelper.IsNuspec(string path) -> bool
static NuGet.Packaging.PackageHelper.IsPackageFile(string packageFileName, NuGet.Packaging.PackageSaveMode packageSaveMode) -> bool
static NuGet.Packaging.PackageHelper.IsRoot(string path) -> bool
static NuGet.Packaging.PackageIdValidator.IsValidPackageId(string packageId) -> bool
static NuGet.Packaging.PackageIdValidator.ValidatePackageId(string packageId) -> void
static NuGet.Packaging.PackagePathHelper.GetInstalledPackageFilePath(NuGet.Packaging.Core.PackageIdentity packageIdentity, NuGet.Packaging.PackagePathResolver packagePathResolver) -> string
static NuGet.Packaging.PackagePathHelper.GetPackageLookupPaths(NuGet.Packaging.Core.PackageIdentity packageIdentity, NuGet.Packaging.PackagePathResolver packagePathResolver) -> System.Collections.Generic.IEnumerable<string>
static NuGet.Packaging.PackageReaderBase.GetNuspecFile(System.Collections.Generic.IEnumerable<string> files) -> string
static NuGet.Packaging.PackageReaderBase.IsAllowedBuildFile(string packageId, string path) -> bool
static NuGet.Packaging.PackageReaderBase.IsReferenceAssembly(string path) -> bool
static NuGet.Packaging.PackageReaderBase.ValidatePackageEntries(string normalizedDestination, System.Collections.Generic.IEnumerable<string> packageFiles, NuGet.Packaging.Core.PackageIdentity packageIdentity) -> void
static NuGet.Packaging.PackageReaderBase.ValidatePackageEntry(string normalizedDestination, string normalizedFilePath, NuGet.Packaging.Core.PackageIdentity packageIdentity) -> void
static NuGet.Packaging.PackageReaderExtensions.GetPackageFilesAsync(this NuGet.Packaging.Core.IAsyncPackageCoreReader packageReader, NuGet.Packaging.PackageSaveMode packageSaveMode, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<string>>
static NuGet.Packaging.PackageReaderExtensions.GetSatelliteFilesAsync(this NuGet.Packaging.IAsyncPackageContentReader packageReader, string packageLanguage, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<string>>
static NuGet.Packaging.PackagesConfig.BoolAttribute(System.Xml.Linq.XElement node, string name, bool defaultValue = false) -> bool
static NuGet.Packaging.PackagesConfig.HasAttributeValue(System.Xml.Linq.XElement node, string attributeName, string targetValue, out System.Xml.Linq.XElement element) -> bool
static NuGet.Packaging.PackagesConfig.TryGetAttribute(System.Xml.Linq.XElement node, string name, out string value) -> bool
static NuGet.Packaging.PackagingConstants.Folders.Known.get -> string[]
static NuGet.Packaging.RepositorySignatureInfoProvider.Instance.get -> NuGet.Packaging.RepositorySignatureInfoProvider
static NuGet.Packaging.Rules.AnalysisResources.AssemblyDirectlyUnderLibWarning.get -> string
static NuGet.Packaging.Rules.AnalysisResources.AssemblyOutsideLibWarning.get -> string
static NuGet.Packaging.Rules.AnalysisResources.BuildConventionIsViolatedWarning.get -> string
static NuGet.Packaging.Rules.AnalysisResources.Culture.get -> System.Globalization.CultureInfo
static NuGet.Packaging.Rules.AnalysisResources.Culture.set -> void
static NuGet.Packaging.Rules.AnalysisResources.DefaultSpecValueWarning.get -> string
static NuGet.Packaging.Rules.AnalysisResources.DependenciesGroupsForEachTFMBeginningToFiles.get -> string
static NuGet.Packaging.Rules.AnalysisResources.DependenciesGroupsForEachTFMBeginningToNuspec.get -> string
static NuGet.Packaging.Rules.AnalysisResources.DependenciesGroupsForEachTFMEndingToFile.get -> string
static NuGet.Packaging.Rules.AnalysisResources.DependenciesGroupsForEachTFMEndingToNuspec.get -> string
static NuGet.Packaging.Rules.AnalysisResources.DependenciesGroupsForEachTFMHasCompatMatch.get -> string
static NuGet.Packaging.Rules.AnalysisResources.DependenciesGroupsForEachTFMHasNoExactMatch.get -> string
static NuGet.Packaging.Rules.AnalysisResources.FilePathTooLongWarning.get -> string
static NuGet.Packaging.Rules.AnalysisResources.IconUrlDeprecationWarning.get -> string
static NuGet.Packaging.Rules.AnalysisResources.InvalidFrameworkWarning.get -> string
static NuGet.Packaging.Rules.AnalysisResources.InvalidPlaceholderFileWarning.get -> string
static NuGet.Packaging.Rules.AnalysisResources.InvalidPrereleaseDependencyWarning.get -> string
static NuGet.Packaging.Rules.AnalysisResources.LegacyVersionWarning.get -> string
static NuGet.Packaging.Rules.AnalysisResources.LicenseUrlDeprecationWarning.get -> string
static NuGet.Packaging.Rules.AnalysisResources.Migrator_AssemblyDirectlyUnderLibWarning.get -> string
static NuGet.Packaging.Rules.AnalysisResources.Migrator_PackageHasContentFolder.get -> string
static NuGet.Packaging.Rules.AnalysisResources.Migrator_PackageHasInstallScript.get -> string
static NuGet.Packaging.Rules.AnalysisResources.Migrator_XdtTransformInPackage.get -> string
static NuGet.Packaging.Rules.AnalysisResources.MisplacedInitScriptWarning.get -> string
static NuGet.Packaging.Rules.AnalysisResources.MisplacedTransformFileWarning.get -> string
static NuGet.Packaging.Rules.AnalysisResources.NoRefOrLibFolderInPackage.get -> string
static NuGet.Packaging.Rules.AnalysisResources.PlaceholderFileInPackageWarning.get -> string
static NuGet.Packaging.Rules.AnalysisResources.ReferencesInNuspecAndRefFilesDontMatchWarning.get -> string
static NuGet.Packaging.Rules.AnalysisResources.ReferencesInNuspecAndRefFilesDontMatchWarningAddToNuspecListItemFormat.get -> string
static NuGet.Packaging.Rules.AnalysisResources.ReferencesInNuspecAndRefFilesDontMatchWarningAddToNuspecNoTfmListItemFormat.get -> string
static NuGet.Packaging.Rules.AnalysisResources.ReferencesInNuspecAndRefFilesDontMatchWarningAddToRefListItemFormat.get -> string
static NuGet.Packaging.Rules.AnalysisResources.ResourceManager.get -> System.Resources.ResourceManager
static NuGet.Packaging.Rules.AnalysisResources.ScriptOutsideToolsWarning.get -> string
static NuGet.Packaging.Rules.AnalysisResources.UnrecognizedLicenseIdentifier.get -> string
static NuGet.Packaging.Rules.AnalysisResources.UnrecognizedScriptWarning.get -> string
static NuGet.Packaging.Rules.AnalysisResources.UnspecifiedDependencyVersionWarning.get -> string
static NuGet.Packaging.Rules.AnalysisResources.WinRTObsoleteWarning.get -> string
static NuGet.Packaging.Rules.RuleSet.PackageCreationRuleSet.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.Rules.IPackageRule>
static NuGet.Packaging.Rules.RuleSet.PackagesConfigToPackageReferenceMigrationRuleSet.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.Rules.IPackageRule>
static NuGet.Packaging.Signing.Accuracy.Read(byte[] bytes) -> NuGet.Packaging.Signing.Accuracy
static NuGet.Packaging.Signing.AlgorithmIdentifier.Read(byte[] bytes) -> NuGet.Packaging.Signing.AlgorithmIdentifier
static NuGet.Packaging.Signing.AttributeUtility.CreateCommitmentTypeIndication(NuGet.Packaging.Signing.SignatureType type) -> System.Security.Cryptography.CryptographicAttributeObject
static NuGet.Packaging.Signing.AttributeUtility.CreateNuGetPackageOwners(System.Collections.Generic.IReadOnlyList<string> packageOwners) -> System.Security.Cryptography.CryptographicAttributeObject
static NuGet.Packaging.Signing.AttributeUtility.CreateNuGetV3ServiceIndexUrl(System.Uri v3ServiceIndexUrl) -> System.Security.Cryptography.CryptographicAttributeObject
static NuGet.Packaging.Signing.AttributeUtility.CreateSigningCertificateV2(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate, NuGet.Common.HashAlgorithmName hashAlgorithm) -> System.Security.Cryptography.CryptographicAttributeObject
static NuGet.Packaging.Signing.AttributeUtility.GetAttribute(this System.Security.Cryptography.CryptographicAttributeObjectCollection attributes, string oid) -> System.Security.Cryptography.CryptographicAttributeObject
static NuGet.Packaging.Signing.AttributeUtility.GetAttributes(this System.Security.Cryptography.CryptographicAttributeObjectCollection attributes, string oid) -> System.Collections.Generic.IEnumerable<System.Security.Cryptography.CryptographicAttributeObject>
static NuGet.Packaging.Signing.AttributeUtility.GetNuGetPackageOwners(System.Security.Cryptography.CryptographicAttributeObjectCollection signedAttributes) -> System.Collections.Generic.IReadOnlyList<string>
static NuGet.Packaging.Signing.AttributeUtility.GetNuGetV3ServiceIndexUrl(System.Security.Cryptography.CryptographicAttributeObjectCollection signedAttributes) -> System.Uri
static NuGet.Packaging.Signing.AttributeUtility.GetSignatureType(System.Security.Cryptography.CryptographicAttributeObjectCollection signedAttributes) -> NuGet.Packaging.Signing.SignatureType
static NuGet.Packaging.Signing.AttributeUtility.GetSignatureType(string oid) -> NuGet.Packaging.Signing.SignatureType
static NuGet.Packaging.Signing.AttributeUtility.GetSignatureTypeOid(NuGet.Packaging.Signing.SignatureType signatureType) -> string
static NuGet.Packaging.Signing.CertificateChainUtility.GetCertificateChain(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate, System.Security.Cryptography.X509Certificates.X509Certificate2Collection extraStore, NuGet.Common.ILogger logger, NuGet.Packaging.Signing.CertificateType certificateType) -> NuGet.Packaging.Signing.IX509CertificateChain
static NuGet.Packaging.Signing.CertificateChainUtility.GetCertificateChain(System.Security.Cryptography.X509Certificates.X509Chain x509Chain) -> NuGet.Packaging.Signing.IX509CertificateChain
static NuGet.Packaging.Signing.CertificateUtility.GetHash(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate, NuGet.Common.HashAlgorithmName hashAlgorithm) -> byte[]
static NuGet.Packaging.Signing.CertificateUtility.GetHashString(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate, NuGet.Common.HashAlgorithmName hashAlgorithm) -> string
static NuGet.Packaging.Signing.CertificateUtility.GetRawDataForCollection(System.Security.Cryptography.X509Certificates.X509Certificate2Collection certificates) -> System.Collections.Generic.IReadOnlyList<byte[]>
static NuGet.Packaging.Signing.CertificateUtility.HasExtendedKeyUsage(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate, string ekuOid) -> bool
static NuGet.Packaging.Signing.CertificateUtility.HasLifetimeSigningEku(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate) -> bool
static NuGet.Packaging.Signing.CertificateUtility.IsCertificatePublicKeyValid(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate) -> bool
static NuGet.Packaging.Signing.CertificateUtility.IsCertificateValidityPeriodInTheFuture(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate) -> bool
static NuGet.Packaging.Signing.CertificateUtility.IsDateInsideValidityPeriod(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate, System.DateTimeOffset date) -> bool
static NuGet.Packaging.Signing.CertificateUtility.IsSelfIssued(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate) -> bool
static NuGet.Packaging.Signing.CertificateUtility.IsSignatureAlgorithmSupported(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate) -> bool
static NuGet.Packaging.Signing.CertificateUtility.IsValidForPurposeFast(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate, string ekuOid) -> bool
static NuGet.Packaging.Signing.CertificateUtility.X509Certificate2CollectionToString(System.Security.Cryptography.X509Certificates.X509Certificate2Collection certCollection, NuGet.Common.HashAlgorithmName fingerprintAlgorithm) -> string
static NuGet.Packaging.Signing.CertificateUtility.X509Certificate2ToString(System.Security.Cryptography.X509Certificates.X509Certificate2 cert, NuGet.Common.HashAlgorithmName fingerprintAlgorithm) -> string
static NuGet.Packaging.Signing.CertificateUtility.X509ChainToString(System.Security.Cryptography.X509Certificates.X509Chain chain, NuGet.Common.HashAlgorithmName fingerprintAlgorithm) -> string
static NuGet.Packaging.Signing.ClientPolicyContext.GetClientPolicy(NuGet.Configuration.ISettings settings, NuGet.Common.ILogger logger) -> NuGet.Packaging.Signing.ClientPolicyContext
static NuGet.Packaging.Signing.CommitmentTypeIndication.Create(System.Security.Cryptography.Oid commitmentTypeId) -> NuGet.Packaging.Signing.CommitmentTypeIndication
static NuGet.Packaging.Signing.CommitmentTypeIndication.Read(byte[] bytes) -> NuGet.Packaging.Signing.CommitmentTypeIndication
static NuGet.Packaging.Signing.CommitmentTypeQualifier.Read(byte[] bytes) -> NuGet.Packaging.Signing.CommitmentTypeQualifier
static NuGet.Packaging.Signing.Crc32.CalculateCrc(byte[] data) -> uint
static NuGet.Packaging.Signing.DerEncoding.DerGeneralizedTime.Read(string decodedTime) -> NuGet.Packaging.Signing.DerEncoding.DerGeneralizedTime
static NuGet.Packaging.Signing.EssCertId.Read(byte[] bytes) -> NuGet.Packaging.Signing.EssCertId
static NuGet.Packaging.Signing.EssCertIdV2.Create(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate, NuGet.Common.HashAlgorithmName hashAlgorithmName) -> NuGet.Packaging.Signing.EssCertIdV2
static NuGet.Packaging.Signing.EssCertIdV2.Read(byte[] bytes) -> NuGet.Packaging.Signing.EssCertIdV2
static NuGet.Packaging.Signing.Extensions.Read(byte[] bytes) -> NuGet.Packaging.Signing.Extensions
static NuGet.Packaging.Signing.GeneralName.Create(System.Security.Cryptography.X509Certificates.X500DistinguishedName distinguishedName) -> NuGet.Packaging.Signing.GeneralName
static NuGet.Packaging.Signing.GeneralName.Read(byte[] bytes) -> NuGet.Packaging.Signing.GeneralName
static NuGet.Packaging.Signing.IssuerSerial.Create(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate) -> NuGet.Packaging.Signing.IssuerSerial
static NuGet.Packaging.Signing.IssuerSerial.Read(byte[] bytes) -> NuGet.Packaging.Signing.IssuerSerial
static NuGet.Packaging.Signing.KeyPairFileUtility.GetValueOrThrow(System.Collections.Generic.Dictionary<string, string> values, string key) -> string
static NuGet.Packaging.Signing.MessageImprint.Read(byte[] bytes) -> NuGet.Packaging.Signing.MessageImprint
static NuGet.Packaging.Signing.NuGetPackageOwners.Read(byte[] bytes) -> NuGet.Packaging.Signing.NuGetPackageOwners
static NuGet.Packaging.Signing.NuGetV3ServiceIndexUrl.Read(byte[] bytes) -> NuGet.Packaging.Signing.NuGetV3ServiceIndexUrl
static NuGet.Packaging.Signing.PolicyInformation.Read(byte[] bytes) -> NuGet.Packaging.Signing.PolicyInformation
static NuGet.Packaging.Signing.PolicyQualifierInfo.Read(byte[] bytes) -> NuGet.Packaging.Signing.PolicyQualifierInfo
static NuGet.Packaging.Signing.PrimarySignature.Load(System.IO.Stream stream) -> NuGet.Packaging.Signing.PrimarySignature
static NuGet.Packaging.Signing.PrimarySignature.Load(System.Security.Cryptography.Pkcs.SignedCms cms) -> NuGet.Packaging.Signing.PrimarySignature
static NuGet.Packaging.Signing.PrimarySignature.Load(byte[] data) -> NuGet.Packaging.Signing.PrimarySignature
static NuGet.Packaging.Signing.PrimarySignature.ThrowForInvalidPrimarySignature() -> void
static NuGet.Packaging.Signing.PrimarySignatureFactory.CreateSignature(System.Security.Cryptography.Pkcs.SignedCms signedCms) -> NuGet.Packaging.Signing.PrimarySignature
static NuGet.Packaging.Signing.RepositoryCountersignature.GetRepositoryCountersignature(NuGet.Packaging.Signing.PrimarySignature primarySignature) -> NuGet.Packaging.Signing.RepositoryCountersignature
static NuGet.Packaging.Signing.RepositorySignatureInfoUtility.GetRepositoryAllowList(System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.IRepositoryCertificateInfo> repositoryCertificateInfos) -> System.Collections.Generic.IReadOnlyCollection<NuGet.Packaging.Signing.CertificateHashAllowListEntry>
static NuGet.Packaging.Signing.RepositorySignatureInfoUtility.GetSignedPackageVerifierSettings(NuGet.Packaging.RepositorySignatureInfo repoSignatureInfo, NuGet.Packaging.Signing.SignedPackageVerifierSettings fallbackSettings) -> NuGet.Packaging.Signing.SignedPackageVerifierSettings
static NuGet.Packaging.Signing.SignatureContent.Load(byte[] bytes, NuGet.Packaging.Signing.SigningSpecifications signingSpecifications) -> NuGet.Packaging.Signing.SignatureContent
static NuGet.Packaging.Signing.SignatureLog.DebugLog(string message) -> NuGet.Packaging.Signing.SignatureLog
static NuGet.Packaging.Signing.SignatureLog.DetailedLog(string message) -> NuGet.Packaging.Signing.SignatureLog
static NuGet.Packaging.Signing.SignatureLog.Error(NuGet.Common.NuGetLogCode code, string message) -> NuGet.Packaging.Signing.SignatureLog
static NuGet.Packaging.Signing.SignatureLog.InformationLog(string message) -> NuGet.Packaging.Signing.SignatureLog
static NuGet.Packaging.Signing.SignatureLog.Issue(bool fatal, NuGet.Common.NuGetLogCode code, string message) -> NuGet.Packaging.Signing.SignatureLog
static NuGet.Packaging.Signing.SignatureUtility.GetCertificateChain(NuGet.Packaging.Signing.PrimarySignature primarySignature) -> NuGet.Packaging.Signing.IX509CertificateChain
static NuGet.Packaging.Signing.SignatureUtility.GetCertificateChain(NuGet.Packaging.Signing.PrimarySignature primarySignature, NuGet.Packaging.Signing.RepositoryCountersignature repositoryCountersignature) -> NuGet.Packaging.Signing.IX509CertificateChain
static NuGet.Packaging.Signing.SignatureUtility.GetTimestampCertificateChain(NuGet.Packaging.Signing.PrimarySignature primarySignature) -> NuGet.Packaging.Signing.IX509CertificateChain
static NuGet.Packaging.Signing.SignatureUtility.GetTimestampCertificateChain(NuGet.Packaging.Signing.PrimarySignature primarySignature, NuGet.Packaging.Signing.RepositoryCountersignature repositoryCountersignature) -> NuGet.Packaging.Signing.IX509CertificateChain
static NuGet.Packaging.Signing.SignatureUtility.HasRepositoryCountersignature(NuGet.Packaging.Signing.PrimarySignature primarySignature) -> bool
static NuGet.Packaging.Signing.SignatureVerifySettings.Default.get -> NuGet.Packaging.Signing.SignatureVerifySettings
static NuGet.Packaging.Signing.SignedPackageArchiveIOUtility.HashBytes(System.Security.Cryptography.HashAlgorithm hashAlgorithm, byte[] bytes) -> void
static NuGet.Packaging.Signing.SignedPackageArchiveIOUtility.ReadAndHashUntilPosition(System.IO.BinaryReader reader, System.Security.Cryptography.HashAlgorithm hashAlgorithm, long position) -> void
static NuGet.Packaging.Signing.SignedPackageArchiveIOUtility.ReadAndWriteUntilPosition(System.IO.BinaryReader reader, System.IO.BinaryWriter writer, long position) -> void
static NuGet.Packaging.Signing.SignedPackageArchiveIOUtility.ReadSignedArchiveMetadata(System.IO.BinaryReader reader, bool validateSignatureEntry = true) -> NuGet.Packaging.Signing.SignedPackageArchiveMetadata
static NuGet.Packaging.Signing.SignedPackageArchiveUtility.IsSigned(System.IO.BinaryReader reader) -> bool
static NuGet.Packaging.Signing.SignedPackageArchiveUtility.IsZip64(System.IO.BinaryReader reader) -> bool
static NuGet.Packaging.Signing.SignedPackageArchiveUtility.OpenPackageSignatureFileStream(System.IO.BinaryReader reader) -> System.IO.Stream
static NuGet.Packaging.Signing.SignedPackageArchiveUtility.RemoveRepositorySignaturesAsync(System.IO.Stream input, System.IO.Stream output, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>
static NuGet.Packaging.Signing.SignedPackageVerifierSettings.GetAcceptModeDefaultPolicy(NuGet.Common.IEnvironmentVariableReader environmentVariableReader = null) -> NuGet.Packaging.Signing.SignedPackageVerifierSettings
static NuGet.Packaging.Signing.SignedPackageVerifierSettings.GetDefault(NuGet.Common.IEnvironmentVariableReader environmentVariableReader = null) -> NuGet.Packaging.Signing.SignedPackageVerifierSettings
static NuGet.Packaging.Signing.SignedPackageVerifierSettings.GetRequireModeDefaultPolicy(NuGet.Common.IEnvironmentVariableReader environmentVariableReader = null) -> NuGet.Packaging.Signing.SignedPackageVerifierSettings
static NuGet.Packaging.Signing.SignedPackageVerifierSettings.GetVerifyCommandDefaultPolicy(NuGet.Common.IEnvironmentVariableReader environmentVariableReader = null) -> NuGet.Packaging.Signing.SignedPackageVerifierSettings
static NuGet.Packaging.Signing.SigningCertificate.Read(byte[] bytes) -> NuGet.Packaging.Signing.SigningCertificate
static NuGet.Packaging.Signing.SigningCertificateV2.Create(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate, NuGet.Common.HashAlgorithmName hashAlgorithmName) -> NuGet.Packaging.Signing.SigningCertificateV2
static NuGet.Packaging.Signing.SigningCertificateV2.Read(byte[] bytes) -> NuGet.Packaging.Signing.SigningCertificateV2
static NuGet.Packaging.Signing.SigningOptions.CreateFromFilePaths(string inputPackageFilePath, string outputPackageFilePath, bool overwrite, NuGet.Packaging.Signing.ISignatureProvider signatureProvider, NuGet.Common.ILogger logger) -> NuGet.Packaging.Signing.SigningOptions
static NuGet.Packaging.Signing.SigningUtility.CreateCmsSigner(NuGet.Packaging.Signing.SignPackageRequest request, NuGet.Common.ILogger logger) -> System.Security.Cryptography.Pkcs.CmsSigner
static NuGet.Packaging.Signing.SigningUtility.CreateSignedAttributes(NuGet.Packaging.Signing.RepositorySignPackageRequest request, System.Collections.Generic.IReadOnlyList<System.Security.Cryptography.X509Certificates.X509Certificate2> chainList) -> System.Security.Cryptography.CryptographicAttributeObjectCollection
static NuGet.Packaging.Signing.SigningUtility.CreateSignedAttributes(NuGet.Packaging.Signing.SignPackageRequest request, System.Collections.Generic.IReadOnlyList<System.Security.Cryptography.X509Certificates.X509Certificate2> chainList) -> System.Security.Cryptography.CryptographicAttributeObjectCollection
static NuGet.Packaging.Signing.SigningUtility.SignAsync(NuGet.Packaging.Signing.SigningOptions options, NuGet.Packaging.Signing.SignPackageRequest signRequest, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task
static NuGet.Packaging.Signing.SigningUtility.Verify(NuGet.Packaging.Signing.SignPackageRequest request, NuGet.Common.ILogger logger) -> void
static NuGet.Packaging.Signing.TrustedSignersProvider.GetAllowListEntries(NuGet.Configuration.ISettings settings, NuGet.Common.ILogger logger) -> System.Collections.Generic.IReadOnlyList<NuGet.Packaging.Signing.TrustedSignerAllowListEntry>
static NuGet.Packaging.Signing.TstInfo.Read(byte[] bytes) -> NuGet.Packaging.Signing.TstInfo
static NuGet.Packaging.Signing.VerificationUtility.GetSignatureVerificationStatus(NuGet.Packaging.Signing.SignatureVerificationStatusFlags flags) -> NuGet.Packaging.Signing.SignatureVerificationStatus
static NuGet.Packaging.Signing.VerificationUtility.IsVerificationTarget(NuGet.Packaging.Signing.SignatureType signatureType, NuGet.Packaging.Signing.VerificationTarget target) -> bool
static NuGet.Packaging.StreamExtensions.CopyToFile(this System.IO.Stream inputStream, string fileFullPath) -> string
static NuGet.Packaging.TopologicalSortUtility.SortPackagesByDependencyOrder(System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.PackageDependencyInfo> packages) -> System.Collections.Generic.IReadOnlyList<NuGet.Packaging.Core.PackageDependencyInfo>
static NuGet.Packaging.TopologicalSortUtility.SortPackagesByDependencyOrder<T>(System.Collections.Generic.IEnumerable<T> items, System.StringComparer comparer, System.Func<T, string> getId, System.Func<T, string[]> getDependencies) -> System.Collections.Generic.IReadOnlyList<T>
static NuGet.Packaging.XElementExtensions.ElementsNoNamespace(this System.Xml.Linq.XContainer container, string localName) -> System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>
static NuGet.Packaging.XElementExtensions.Except(this System.Xml.Linq.XElement source, System.Xml.Linq.XElement target) -> System.Xml.Linq.XElement
static NuGet.Packaging.XElementExtensions.GetOptionalAttributeValue(this System.Xml.Linq.XElement element, string localName, string namespaceName = null) -> string
static NuGet.Packaging.XmlUtility.LoadSafe(System.IO.Stream input) -> System.Xml.Linq.XDocument
static NuGet.Packaging.XmlUtility.LoadSafe(System.IO.Stream input, bool ignoreWhiteSpace) -> System.Xml.Linq.XDocument
static NuGet.Packaging.ZipArchiveExtensions.GetFiles(this System.IO.Compression.ZipArchive zipArchive) -> System.Collections.Generic.IEnumerable<string>
static NuGet.Packaging.ZipArchiveExtensions.LookupEntry(this System.IO.Compression.ZipArchive zipArchive, string path) -> System.IO.Compression.ZipArchiveEntry
static NuGet.Packaging.ZipArchiveExtensions.OpenFile(this System.IO.Compression.ZipArchive zipArchive, string path) -> System.IO.Stream
static NuGet.Packaging.ZipArchiveExtensions.SaveAsFile(this System.IO.Compression.ZipArchiveEntry entry, string fileFullPath, NuGet.Common.ILogger logger) -> string
static NuGet.Packaging.ZipArchiveExtensions.UpdateFileTimeFromEntry(this System.IO.Compression.ZipArchiveEntry entry, string fileFullPath, NuGet.Common.ILogger logger) -> void
static NuGet.RuntimeModel.JsonRuntimeFormat.ReadRuntimeGraph(Newtonsoft.Json.Linq.JToken json) -> NuGet.RuntimeModel.RuntimeGraph
static NuGet.RuntimeModel.JsonRuntimeFormat.ReadRuntimeGraph(System.IO.Stream stream) -> NuGet.RuntimeModel.RuntimeGraph
static NuGet.RuntimeModel.JsonRuntimeFormat.ReadRuntimeGraph(System.IO.TextReader textReader) -> NuGet.RuntimeModel.RuntimeGraph
static NuGet.RuntimeModel.JsonRuntimeFormat.ReadRuntimeGraph(string filePath) -> NuGet.RuntimeModel.RuntimeGraph
static NuGet.RuntimeModel.JsonRuntimeFormat.WriteRuntimeGraph(NuGet.RuntimeModel.IObjectWriter writer, NuGet.RuntimeModel.RuntimeGraph runtimeGraph) -> void
static NuGet.RuntimeModel.JsonRuntimeFormat.WriteRuntimeGraph(string filePath, NuGet.RuntimeModel.RuntimeGraph runtimeGraph) -> void
static NuGet.RuntimeModel.RuntimeDescription.Merge(NuGet.RuntimeModel.RuntimeDescription left, NuGet.RuntimeModel.RuntimeDescription right) -> NuGet.RuntimeModel.RuntimeDescription
static NuGet.RuntimeModel.RuntimeGraph.Merge(NuGet.RuntimeModel.RuntimeGraph left, NuGet.RuntimeModel.RuntimeGraph right) -> NuGet.RuntimeModel.RuntimeGraph
static readonly NuGet.Client.ManagedCodeConventions.PropertyNames.AnyValue -> string
static readonly NuGet.Client.ManagedCodeConventions.PropertyNames.CodeLanguage -> string
static readonly NuGet.Client.ManagedCodeConventions.PropertyNames.Locale -> string
static readonly NuGet.Client.ManagedCodeConventions.PropertyNames.MSBuild -> string
static readonly NuGet.Client.ManagedCodeConventions.PropertyNames.ManagedAssembly -> string
static readonly NuGet.Client.ManagedCodeConventions.PropertyNames.RuntimeIdentifier -> string
static readonly NuGet.Client.ManagedCodeConventions.PropertyNames.SatelliteAssembly -> string
static readonly NuGet.Client.ManagedCodeConventions.PropertyNames.TargetFrameworkMoniker -> string
static readonly NuGet.Packaging.Core.NuspecUtility.FrameworkReference -> string
static readonly NuGet.Packaging.Core.NuspecUtility.FrameworkReferences -> string
static readonly NuGet.Packaging.Core.NuspecUtility.Group -> string
static readonly NuGet.Packaging.Core.NuspecUtility.License -> string
static readonly NuGet.Packaging.Core.NuspecUtility.Name -> string
static readonly NuGet.Packaging.Core.NuspecUtility.PackageType -> string
static readonly NuGet.Packaging.Core.NuspecUtility.PackageTypes -> string
static readonly NuGet.Packaging.Core.NuspecUtility.Repository -> string
static readonly NuGet.Packaging.Core.NuspecUtility.RepositoryBranch -> string
static readonly NuGet.Packaging.Core.NuspecUtility.RepositoryCommit -> string
static readonly NuGet.Packaging.Core.NuspecUtility.RepositoryUrl -> string
static readonly NuGet.Packaging.Core.NuspecUtility.Serviceable -> string
static readonly NuGet.Packaging.Core.NuspecUtility.TargetFramework -> string
static readonly NuGet.Packaging.Core.NuspecUtility.Type -> string
static readonly NuGet.Packaging.Core.NuspecUtility.Version -> string
static readonly NuGet.Packaging.Core.PackageDependencyComparer.Default -> NuGet.Packaging.Core.PackageDependencyComparer
static readonly NuGet.Packaging.Core.PackageType.Dependency -> NuGet.Packaging.Core.PackageType
static readonly NuGet.Packaging.Core.PackageType.DotnetCliTool -> NuGet.Packaging.Core.PackageType
static readonly NuGet.Packaging.Core.PackageType.DotnetPlatform -> NuGet.Packaging.Core.PackageType
static readonly NuGet.Packaging.Core.PackageType.DotnetTool -> NuGet.Packaging.Core.PackageType
static readonly NuGet.Packaging.Core.PackageType.EmptyVersion -> System.Version
static readonly NuGet.Packaging.Core.PackageType.Legacy -> NuGet.Packaging.Core.PackageType
static readonly NuGet.Packaging.Core.PackageType.PackageTypeNameComparer -> System.StringComparer
static readonly NuGet.Packaging.Core.PackageType.SymbolsPackage -> NuGet.Packaging.Core.PackageType
static readonly NuGet.Packaging.Core.PackagingCoreConstants.EmptyFolder -> string
static readonly NuGet.Packaging.Core.PackagingCoreConstants.ForwardSlashEmptyFolder -> string
static readonly NuGet.Packaging.Core.PackagingCoreConstants.HashFileExtension -> string
static readonly NuGet.Packaging.Core.PackagingCoreConstants.NupkgExtension -> string
static readonly NuGet.Packaging.Core.PackagingCoreConstants.NupkgMetadataFileExtension -> string
static readonly NuGet.Packaging.Core.PackagingCoreConstants.NuspecExtension -> string
static readonly NuGet.Packaging.Core.PackagingCoreConstants.PackageDownloadMarkerFileExtension -> string
static readonly NuGet.Packaging.LicenseMetadata.CurrentVersion -> System.Version
static readonly NuGet.Packaging.LicenseMetadata.EmptyVersion -> System.Version
static readonly NuGet.Packaging.LicenseMetadata.LicenseFileDeprecationUrl -> System.Uri
static readonly NuGet.Packaging.LicenseMetadata.LicenseServiceLinkTemplate -> string
static readonly NuGet.Packaging.Licenses.NuGetLicenseData.ExceptionList -> System.Collections.Generic.IReadOnlyDictionary<string, NuGet.Packaging.Licenses.ExceptionData>
static readonly NuGet.Packaging.Licenses.NuGetLicenseData.LicenseList -> System.Collections.Generic.IReadOnlyDictionary<string, NuGet.Packaging.Licenses.LicenseData>
static readonly NuGet.Packaging.NupkgMetadataFileFormat.Version -> int
static readonly NuGet.Packaging.PackagesConfig.IdAttributeName -> string
static readonly NuGet.Packaging.PackagesConfig.MinClientAttributeName -> string
static readonly NuGet.Packaging.PackagesConfig.PackageNodeName -> string
static readonly NuGet.Packaging.PackagesConfig.PackagesNodeName -> string
static readonly NuGet.Packaging.PackagesConfig.RequireInstallAttributeName -> string
static readonly NuGet.Packaging.PackagesConfig.TargetFrameworkAttributeName -> string
static readonly NuGet.Packaging.PackagesConfig.UserInstalledAttributeName -> string
static readonly NuGet.Packaging.PackagesConfig.VersionAttributeName -> string
static readonly NuGet.Packaging.PackagesConfig.allowedVersionsAttributeName -> string
static readonly NuGet.Packaging.PackagesConfig.developmentDependencyAttributeName -> string
static readonly NuGet.Packaging.PackagingConstants.AgnosticFramework -> string
static readonly NuGet.Packaging.PackagingConstants.AnyCodeLanguage -> string
static readonly NuGet.Packaging.PackagingConstants.AnyFramework -> string
static readonly NuGet.Packaging.PackagingConstants.ContentFilesDefaultBuildAction -> string
static readonly NuGet.Packaging.PackagingConstants.Folders.Analyzers -> string
static readonly NuGet.Packaging.PackagingConstants.Folders.Build -> string
static readonly NuGet.Packaging.PackagingConstants.Folders.BuildCrossTargeting -> string
static readonly NuGet.Packaging.PackagingConstants.Folders.BuildTransitive -> string
static readonly NuGet.Packaging.PackagingConstants.Folders.Content -> string
static readonly NuGet.Packaging.PackagingConstants.Folders.ContentFiles -> string
static readonly NuGet.Packaging.PackagingConstants.Folders.Lib -> string
static readonly NuGet.Packaging.PackagingConstants.Folders.Native -> string
static readonly NuGet.Packaging.PackagingConstants.Folders.Ref -> string
static readonly NuGet.Packaging.PackagingConstants.Folders.Runtimes -> string
static readonly NuGet.Packaging.PackagingConstants.Folders.Source -> string
static readonly NuGet.Packaging.PackagingConstants.Folders.Tools -> string
static readonly NuGet.Packaging.PackagingConstants.ManifestExtension -> string
static readonly NuGet.Packaging.PackagingConstants.PackageVerifyDurationName -> string
static readonly NuGet.Packaging.PackagingConstants.SnupkgFormat -> string
static readonly NuGet.Packaging.PackagingConstants.SymbolsNupkgFormat -> string
static readonly NuGet.Packaging.PackagingConstants.TargetFrameworkPropertyKey -> string
static readonly NuGet.Packaging.Signing.SigningSpecifications.V1 -> NuGet.Packaging.Signing.SigningSpecificationsV1
static readonly NuGet.RuntimeModel.RuntimeGraph.Empty -> NuGet.RuntimeModel.RuntimeGraph
static readonly NuGet.RuntimeModel.RuntimeGraph.RuntimeGraphFileName -> string
virtual NuGet.ContentModel.ContentPropertyDefinition.Compare(object criteriaValue, object candidateValue1, object candidateValue2) -> int
virtual NuGet.ContentModel.ContentPropertyDefinition.IsCriteriaSatisfied(object critieriaValue, object candidateValue) -> bool
virtual NuGet.ContentModel.ContentPropertyDefinition.TryLookup(string name, NuGet.ContentModel.PatternTable table, out object value) -> bool
virtual NuGet.ContentModel.SelectionCriteriaBuilder.Add.get -> NuGet.ContentModel.SelectionCriteriaEntryBuilder
virtual NuGet.ContentModel.SelectionCriteriaBuilder.Criteria.get -> NuGet.ContentModel.SelectionCriteria
virtual NuGet.Packaging.Core.NuspecCoreReader.GetDependencies() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.Core.PackageDependency>
virtual NuGet.Packaging.Core.NuspecCoreReaderBase.GetDevelopmentDependency() -> bool
virtual NuGet.Packaging.Core.NuspecCoreReaderBase.GetId() -> string
virtual NuGet.Packaging.Core.NuspecCoreReaderBase.GetIdentity() -> NuGet.Packaging.Core.PackageIdentity
virtual NuGet.Packaging.Core.NuspecCoreReaderBase.GetMetadata() -> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>>
virtual NuGet.Packaging.Core.NuspecCoreReaderBase.GetMetadataValue(string name) -> string
virtual NuGet.Packaging.Core.NuspecCoreReaderBase.GetMinClientVersion() -> NuGet.Versioning.NuGetVersion
virtual NuGet.Packaging.Core.NuspecCoreReaderBase.GetPackageTypes() -> System.Collections.Generic.IReadOnlyList<NuGet.Packaging.Core.PackageType>
virtual NuGet.Packaging.Core.NuspecCoreReaderBase.GetVersion() -> NuGet.Versioning.NuGetVersion
virtual NuGet.Packaging.Core.NuspecCoreReaderBase.IsServiceable() -> bool
virtual NuGet.Packaging.Core.PackageIdentity.Equals(NuGet.Packaging.Core.PackageIdentity other, NuGet.Versioning.VersionComparison versionComparison) -> bool
virtual NuGet.Packaging.Core.PackagingException.AsLogMessage() -> NuGet.Common.ILogMessage
virtual NuGet.Packaging.PackagePathResolver.GetInstallPath(NuGet.Packaging.Core.PackageIdentity packageIdentity) -> string
virtual NuGet.Packaging.PackagePathResolver.GetInstalledPackageFilePath(NuGet.Packaging.Core.PackageIdentity packageIdentity) -> string
virtual NuGet.Packaging.PackagePathResolver.GetInstalledPath(NuGet.Packaging.Core.PackageIdentity packageIdentity) -> string
virtual NuGet.Packaging.PackagePathResolver.GetPackageDirectoryName(NuGet.Packaging.Core.PackageIdentity packageIdentity) -> string
virtual NuGet.Packaging.PackagePathResolver.GetPackageFileName(NuGet.Packaging.Core.PackageIdentity packageIdentity) -> string
virtual NuGet.Packaging.PackageReaderBase.CopyFilesAsync(string destination, System.Collections.Generic.IEnumerable<string> packageFiles, NuGet.Packaging.Core.ExtractPackageFileDelegate extractFile, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<string>>
virtual NuGet.Packaging.PackageReaderBase.CopyNupkgAsync(string nupkgFilePath, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<string>
virtual NuGet.Packaging.PackageReaderBase.GetBuildItems() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
virtual NuGet.Packaging.PackageReaderBase.GetBuildItemsAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>>
virtual NuGet.Packaging.PackageReaderBase.GetContentItems() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
virtual NuGet.Packaging.PackageReaderBase.GetContentItemsAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>>
virtual NuGet.Packaging.PackageReaderBase.GetDevelopmentDependency() -> bool
virtual NuGet.Packaging.PackageReaderBase.GetDevelopmentDependencyAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>
virtual NuGet.Packaging.PackageReaderBase.GetFilesAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<string>>
virtual NuGet.Packaging.PackageReaderBase.GetFilesAsync(string folder, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<string>>
virtual NuGet.Packaging.PackageReaderBase.GetFrameworkItems() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
virtual NuGet.Packaging.PackageReaderBase.GetFrameworkItemsAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>>
virtual NuGet.Packaging.PackageReaderBase.GetIdentity() -> NuGet.Packaging.Core.PackageIdentity
virtual NuGet.Packaging.PackageReaderBase.GetIdentityAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Packaging.Core.PackageIdentity>
virtual NuGet.Packaging.PackageReaderBase.GetItems(string folderName) -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
virtual NuGet.Packaging.PackageReaderBase.GetItemsAsync(string folderName, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>>
virtual NuGet.Packaging.PackageReaderBase.GetLibItems() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
virtual NuGet.Packaging.PackageReaderBase.GetLibItemsAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>>
virtual NuGet.Packaging.PackageReaderBase.GetMinClientVersion() -> NuGet.Versioning.NuGetVersion
virtual NuGet.Packaging.PackageReaderBase.GetMinClientVersionAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Versioning.NuGetVersion>
virtual NuGet.Packaging.PackageReaderBase.GetNuspec() -> System.IO.Stream
virtual NuGet.Packaging.PackageReaderBase.GetNuspecAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.IO.Stream>
virtual NuGet.Packaging.PackageReaderBase.GetNuspecFile() -> string
virtual NuGet.Packaging.PackageReaderBase.GetNuspecFileAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<string>
virtual NuGet.Packaging.PackageReaderBase.GetNuspecReaderAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.Packaging.NuspecReader>
virtual NuGet.Packaging.PackageReaderBase.GetPackageDependencies() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageDependencyGroup>
virtual NuGet.Packaging.PackageReaderBase.GetPackageDependenciesAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Packaging.PackageDependencyGroup>>
virtual NuGet.Packaging.PackageReaderBase.GetPackageTypes() -> System.Collections.Generic.IReadOnlyList<NuGet.Packaging.Core.PackageType>
virtual NuGet.Packaging.PackageReaderBase.GetPackageTypesAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<NuGet.Packaging.Core.PackageType>>
virtual NuGet.Packaging.PackageReaderBase.GetReferenceItems() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
virtual NuGet.Packaging.PackageReaderBase.GetReferenceItemsAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>>
virtual NuGet.Packaging.PackageReaderBase.GetStreamAsync(string path, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.IO.Stream>
virtual NuGet.Packaging.PackageReaderBase.GetSupportedFrameworks() -> System.Collections.Generic.IEnumerable<NuGet.Frameworks.NuGetFramework>
virtual NuGet.Packaging.PackageReaderBase.GetSupportedFrameworksAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Frameworks.NuGetFramework>>
virtual NuGet.Packaging.PackageReaderBase.GetToolItems() -> System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>
virtual NuGet.Packaging.PackageReaderBase.GetToolItemsAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NuGet.Packaging.FrameworkSpecificGroup>>
virtual NuGet.Packaging.PackageReaderBase.IsServiceable() -> bool
virtual NuGet.Packaging.PackageReaderBase.IsServiceableAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<bool>
virtual NuGet.Packaging.PackageReaderBase.NuspecReader.get -> NuGet.Packaging.NuspecReader
virtual NuGet.Packaging.Signing.PackageVerificationResult.Issues.get -> System.Collections.Generic.IEnumerable<NuGet.Packaging.Signing.SignatureLog>
virtual NuGet.Packaging.Signing.PackageVerificationResult.Trust.get -> NuGet.Packaging.Signing.SignatureVerificationStatus
virtual NuGet.Packaging.Signing.Signature.FriendlyName.get -> string
virtual NuGet.Packaging.Signing.Signature.Verify(NuGet.Packaging.Signing.Timestamp timestamp, NuGet.Packaging.Signing.SignatureVerifySettings settings, NuGet.Common.HashAlgorithmName fingerprintAlgorithm, System.Security.Cryptography.X509Certificates.X509Certificate2Collection certificateExtraStore) -> NuGet.Packaging.Signing.SignatureVerificationSummary
virtual NuGet.Packaging.VersionFolderPathResolver.GetInstallPath(string packageId, NuGet.Versioning.NuGetVersion version) -> string
virtual NuGet.Packaging.VersionFolderPathResolver.GetManifestFileName(string packageId, NuGet.Versioning.NuGetVersion version) -> string
virtual NuGet.Packaging.VersionFolderPathResolver.GetPackageDirectory(string packageId, NuGet.Versioning.NuGetVersion version) -> string
virtual NuGet.Packaging.VersionFolderPathResolver.GetPackageFileName(string packageId, NuGet.Versioning.NuGetVersion version) -> string
virtual NuGet.Packaging.VersionFolderPathResolver.GetVersionListDirectory(string packageId) -> string
