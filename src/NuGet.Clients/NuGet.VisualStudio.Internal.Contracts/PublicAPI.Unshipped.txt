#nullable enable
NuGet.VisualStudio.Internal.Contracts.AlternatePackageMetadataContextInfo
NuGet.VisualStudio.Internal.Contracts.AlternatePackageMetadataContextInfo.AlternatePackageMetadataContextInfo(string! packageId, NuGet.Versioning.VersionRange! range) -> void
NuGet.VisualStudio.Internal.Contracts.AlternatePackageMetadataContextInfo.PackageId.get -> string!
NuGet.VisualStudio.Internal.Contracts.AlternatePackageMetadataContextInfo.VersionRange.get -> NuGet.Versioning.VersionRange!
NuGet.VisualStudio.Internal.Contracts.IInstalledAndTransitivePackages
NuGet.VisualStudio.Internal.Contracts.IInstalledAndTransitivePackages.InstalledPackages.get -> System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.IPackageReferenceContextInfo!>!
NuGet.VisualStudio.Internal.Contracts.IInstalledAndTransitivePackages.TransitivePackages.get -> System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.IPackageReferenceContextInfo!>!
NuGet.VisualStudio.Internal.Contracts.INuGetProjectManagerService
NuGet.VisualStudio.Internal.Contracts.INuGetProjectManagerService.BeginOperationAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask
NuGet.VisualStudio.Internal.Contracts.INuGetProjectManagerService.EndOperationAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask
NuGet.VisualStudio.Internal.Contracts.INuGetProjectManagerService.ExecuteActionsAsync(System.Collections.Generic.IReadOnlyList<NuGet.VisualStudio.Internal.Contracts.ProjectAction!>! actions, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask
NuGet.VisualStudio.Internal.Contracts.INuGetProjectManagerService.GetInstallActionsAsync(System.Collections.Generic.IReadOnlyCollection<string!>! projectIds, NuGet.Packaging.Core.PackageIdentity! packageIdentity, NuGet.PackageManagement.VersionConstraints versionConstraints, bool includePrelease, NuGet.Resolver.DependencyBehavior dependencyBehavior, System.Collections.Generic.IReadOnlyList<string!>! packageSourceNames, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<System.Collections.Generic.IReadOnlyList<NuGet.VisualStudio.Internal.Contracts.ProjectAction!>!>
NuGet.VisualStudio.Internal.Contracts.INuGetProjectManagerService.GetInstalledAndTransitivePackagesAsync(System.Collections.Generic.IReadOnlyCollection<string!>! projectIds, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<NuGet.VisualStudio.Internal.Contracts.IInstalledAndTransitivePackages!>
NuGet.VisualStudio.Internal.Contracts.INuGetProjectManagerService.GetInstalledPackagesAsync(System.Collections.Generic.IReadOnlyCollection<string!>! projectIds, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.IPackageReferenceContextInfo!>!>
NuGet.VisualStudio.Internal.Contracts.INuGetProjectManagerService.GetInstalledPackagesDependencyInfoAsync(string! projectId, bool includeUnresolved, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<System.Collections.Generic.IReadOnlyCollection<NuGet.Packaging.Core.PackageDependencyInfo!>!>
NuGet.VisualStudio.Internal.Contracts.INuGetProjectManagerService.GetMetadataAsync(string! projectId, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<NuGet.VisualStudio.Internal.Contracts.IProjectMetadataContextInfo!>
NuGet.VisualStudio.Internal.Contracts.INuGetProjectManagerService.GetProjectAsync(string! projectId, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<NuGet.VisualStudio.Internal.Contracts.IProjectContextInfo!>
NuGet.VisualStudio.Internal.Contracts.INuGetProjectManagerService.GetProjectsAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.IProjectContextInfo!>!>
NuGet.VisualStudio.Internal.Contracts.INuGetProjectManagerService.GetProjectsWithDeprecatedDotnetFrameworkAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.IProjectContextInfo!>!>
NuGet.VisualStudio.Internal.Contracts.INuGetProjectManagerService.GetTargetFrameworksAsync(System.Collections.Generic.IReadOnlyCollection<string!>! projectIds, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<System.Collections.Generic.IReadOnlyCollection<NuGet.Frameworks.NuGetFramework!>!>
NuGet.VisualStudio.Internal.Contracts.INuGetProjectManagerService.GetUninstallActionsAsync(System.Collections.Generic.IReadOnlyCollection<string!>! projectIds, NuGet.Packaging.Core.PackageIdentity! packageIdentity, bool removeDependencies, bool forceRemove, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<System.Collections.Generic.IReadOnlyList<NuGet.VisualStudio.Internal.Contracts.ProjectAction!>!>
NuGet.VisualStudio.Internal.Contracts.INuGetProjectManagerService.GetUpdateActionsAsync(System.Collections.Generic.IReadOnlyCollection<string!>! projectIds, System.Collections.Generic.IReadOnlyCollection<NuGet.Packaging.Core.PackageIdentity!>! packageIdentities, NuGet.PackageManagement.VersionConstraints versionConstraints, bool includePrelease, NuGet.Resolver.DependencyBehavior dependencyBehavior, System.Collections.Generic.IReadOnlyList<string!>! packageSourceNames, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<System.Collections.Generic.IReadOnlyList<NuGet.VisualStudio.Internal.Contracts.ProjectAction!>!>
NuGet.VisualStudio.Internal.Contracts.INuGetProjectManagerService.TryGetInstalledPackageFilePathAsync(string! projectId, NuGet.Packaging.Core.PackageIdentity! packageIdentity, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<(bool, string?)>
NuGet.VisualStudio.Internal.Contracts.INuGetProjectManagerServiceState
NuGet.VisualStudio.Internal.Contracts.INuGetProjectManagerServiceState.AsyncSemaphore.get -> Microsoft.VisualStudio.Threading.AsyncSemaphore!
NuGet.VisualStudio.Internal.Contracts.INuGetProjectManagerServiceState.PackageIdentity.get -> NuGet.Packaging.Core.PackageIdentity?
NuGet.VisualStudio.Internal.Contracts.INuGetProjectManagerServiceState.PackageIdentity.set -> void
NuGet.VisualStudio.Internal.Contracts.INuGetProjectManagerServiceState.Reset() -> void
NuGet.VisualStudio.Internal.Contracts.INuGetProjectManagerServiceState.ResolvedActions.get -> System.Collections.Generic.Dictionary<string!, NuGet.PackageManagement.ResolvedAction!>!
NuGet.VisualStudio.Internal.Contracts.INuGetProjectManagerServiceState.SourceCacheContext.get -> NuGet.Protocol.Core.Types.SourceCacheContext?
NuGet.VisualStudio.Internal.Contracts.INuGetProjectManagerServiceState.SourceCacheContext.set -> void
NuGet.VisualStudio.Internal.Contracts.INuGetProjectUpgraderService
NuGet.VisualStudio.Internal.Contracts.INuGetProjectUpgraderService.BackupProjectAsync(string! projectId, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<string!>
NuGet.VisualStudio.Internal.Contracts.INuGetProjectUpgraderService.GetUpgradeableProjectsAsync(System.Collections.Generic.IReadOnlyCollection<string!>! projectIds, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.IProjectContextInfo!>!>
NuGet.VisualStudio.Internal.Contracts.INuGetProjectUpgraderService.InstallPackagesAsync(string! projectId, System.Collections.Generic.IReadOnlyList<NuGet.Packaging.Core.PackageIdentity!>! packageIdentities, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask
NuGet.VisualStudio.Internal.Contracts.INuGetProjectUpgraderService.IsProjectUpgradeableAsync(string! projectId, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<bool>
NuGet.VisualStudio.Internal.Contracts.INuGetProjectUpgraderService.SaveProjectAsync(string! projectId, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask
NuGet.VisualStudio.Internal.Contracts.INuGetProjectUpgraderService.UninstallPackagesAsync(string! projectId, System.Collections.Generic.IReadOnlyList<NuGet.Packaging.Core.PackageIdentity!>! packageIdentities, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask
NuGet.VisualStudio.Internal.Contracts.INuGetProjectUpgraderService.UpgradeProjectToPackageReferenceAsync(string! projectId, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<NuGet.VisualStudio.Internal.Contracts.IProjectContextInfo!>
NuGet.VisualStudio.Internal.Contracts.INuGetRemoteFileService
NuGet.VisualStudio.Internal.Contracts.INuGetRemoteFileService.GetEmbeddedLicenseAsync(NuGet.Packaging.Core.PackageIdentity! packageIdentity, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<System.IO.Stream?>
NuGet.VisualStudio.Internal.Contracts.INuGetRemoteFileService.GetPackageIconAsync(NuGet.Packaging.Core.PackageIdentity! packageIdentity, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<System.IO.Stream?>
NuGet.VisualStudio.Internal.Contracts.INuGetSearchService
NuGet.VisualStudio.Internal.Contracts.INuGetSearchService.ContinueSearchAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<NuGet.VisualStudio.Internal.Contracts.SearchResultContextInfo!>
NuGet.VisualStudio.Internal.Contracts.INuGetSearchService.GetAllPackagesAsync(System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.IProjectContextInfo!>! projectContextInfos, System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo!>! packageSources, System.Collections.Generic.IReadOnlyCollection<string!>! targetFrameworks, NuGet.Protocol.Core.Types.SearchFilter! searchFilter, NuGet.VisualStudio.Internal.Contracts.ItemFilter itemFilter, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo!>!>
NuGet.VisualStudio.Internal.Contracts.INuGetSearchService.GetDeprecationMetadataAsync(NuGet.Packaging.Core.PackageIdentity! identity, System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo!>! packageSources, bool includePrerelease, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<NuGet.VisualStudio.Internal.Contracts.PackageDeprecationMetadataContextInfo?>
NuGet.VisualStudio.Internal.Contracts.INuGetSearchService.GetPackageMetadataAsync(NuGet.Packaging.Core.PackageIdentity! identity, System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo!>! packageSources, bool includePrerelease, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<(NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo!, NuGet.VisualStudio.Internal.Contracts.PackageDeprecationMetadataContextInfo?)>
NuGet.VisualStudio.Internal.Contracts.INuGetSearchService.GetPackageMetadataListAsync(string! id, System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo!>! packageSources, bool includePrerelease, bool includeUnlisted, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo!>!>
NuGet.VisualStudio.Internal.Contracts.INuGetSearchService.GetPackageVersionsAsync(NuGet.Packaging.Core.PackageIdentity! identity, System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo!>! packageSources, bool includePrerelease, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.VersionInfoContextInfo!>!>
NuGet.VisualStudio.Internal.Contracts.INuGetSearchService.GetTotalCountAsync(int maxCount, System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.IProjectContextInfo!>! projectContextInfos, System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo!>! packageSources, System.Collections.Generic.IReadOnlyCollection<string!>! targetFrameworks, NuGet.Protocol.Core.Types.SearchFilter! searchFilter, NuGet.VisualStudio.Internal.Contracts.ItemFilter itemFilter, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<int>
NuGet.VisualStudio.Internal.Contracts.INuGetSearchService.RefreshSearchAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<NuGet.VisualStudio.Internal.Contracts.SearchResultContextInfo!>
NuGet.VisualStudio.Internal.Contracts.INuGetSearchService.SearchAsync(System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.IProjectContextInfo!>! projectContextInfos, System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo!>! packageSources, System.Collections.Generic.IReadOnlyCollection<string!>! targetFrameworks, string! searchText, NuGet.Protocol.Core.Types.SearchFilter! searchFilter, NuGet.VisualStudio.Internal.Contracts.ItemFilter itemFilter, bool useRecommender, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<NuGet.VisualStudio.Internal.Contracts.SearchResultContextInfo!>
NuGet.VisualStudio.Internal.Contracts.INuGetSolutionManagerService.AfterNuGetCacheUpdated -> System.EventHandler<string!>!
NuGet.VisualStudio.Internal.Contracts.INuGetSolutionManagerService.AfterProjectRenamed -> System.EventHandler<NuGet.VisualStudio.Internal.Contracts.IProjectContextInfo!>!
NuGet.VisualStudio.Internal.Contracts.INuGetSolutionManagerService.GetSolutionDirectoryAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<string!>
NuGet.VisualStudio.Internal.Contracts.INuGetSolutionManagerService.ProjectAdded -> System.EventHandler<NuGet.VisualStudio.Internal.Contracts.IProjectContextInfo!>!
NuGet.VisualStudio.Internal.Contracts.INuGetSolutionManagerService.ProjectRemoved -> System.EventHandler<NuGet.VisualStudio.Internal.Contracts.IProjectContextInfo!>!
NuGet.VisualStudio.Internal.Contracts.INuGetSolutionManagerService.ProjectRenamed -> System.EventHandler<NuGet.VisualStudio.Internal.Contracts.IProjectContextInfo!>!
NuGet.VisualStudio.Internal.Contracts.INuGetSolutionManagerService.ProjectUpdated -> System.EventHandler<NuGet.VisualStudio.Internal.Contracts.IProjectContextInfo!>!
NuGet.VisualStudio.Internal.Contracts.INuGetSolutionService.RestoreSolutionAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task!
NuGet.VisualStudio.Internal.Contracts.INuGetSourcesService.GetActivePackageSourceNameAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<string?>
NuGet.VisualStudio.Internal.Contracts.INuGetSourcesService.GetPackageSourcesAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<System.Collections.Generic.IReadOnlyList<NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo!>!>
NuGet.VisualStudio.Internal.Contracts.INuGetSourcesService.PackageSourcesChanged -> System.EventHandler<System.Collections.Generic.IReadOnlyList<NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo!>!>?
NuGet.VisualStudio.Internal.Contracts.INuGetSourcesService.SavePackageSourceContextInfosAsync(System.Collections.Generic.IReadOnlyList<NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo!>! sources, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask
NuGet.VisualStudio.Internal.Contracts.INuGetSourcesService.SavePackageSourcesAsync(System.Collections.Generic.IReadOnlyList<NuGet.Configuration.PackageSource!>! sources, NuGet.Configuration.PackageSourceUpdateOptions! packageSourceUpdateOptions, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask
NuGet.VisualStudio.Internal.Contracts.IPackageReferenceContextInfo.Framework.get -> NuGet.Frameworks.NuGetFramework?
NuGet.VisualStudio.Internal.Contracts.IPackageReferenceContextInfo.Identity.get -> NuGet.Packaging.Core.PackageIdentity!
NuGet.VisualStudio.Internal.Contracts.IProjectContextInfo.ProjectId.get -> string!
NuGet.VisualStudio.Internal.Contracts.IProjectMetadataContextInfo.SupportedFrameworks.get -> System.Collections.Generic.IReadOnlyCollection<NuGet.Frameworks.NuGetFramework!>?
NuGet.VisualStudio.Internal.Contracts.ImplicitProjectAction.Equals(NuGet.VisualStudio.Internal.Contracts.ImplicitProjectAction? other) -> bool
NuGet.VisualStudio.Internal.Contracts.ImplicitProjectAction.Id.get -> string!
NuGet.VisualStudio.Internal.Contracts.ImplicitProjectAction.ImplicitProjectAction(string! id, NuGet.Packaging.Core.PackageIdentity! packageIdentity, NuGet.PackageManagement.NuGetProjectActionType projectActionType) -> void
NuGet.VisualStudio.Internal.Contracts.ImplicitProjectAction.PackageIdentity.get -> NuGet.Packaging.Core.PackageIdentity!
NuGet.VisualStudio.Internal.Contracts.ItemFilter
NuGet.VisualStudio.Internal.Contracts.ItemFilter.All = 0 -> NuGet.VisualStudio.Internal.Contracts.ItemFilter
NuGet.VisualStudio.Internal.Contracts.ItemFilter.Consolidate = 3 -> NuGet.VisualStudio.Internal.Contracts.ItemFilter
NuGet.VisualStudio.Internal.Contracts.ItemFilter.Installed = 1 -> NuGet.VisualStudio.Internal.Contracts.ItemFilter
NuGet.VisualStudio.Internal.Contracts.ItemFilter.UpdatesAvailable = 2 -> NuGet.VisualStudio.Internal.Contracts.ItemFilter
NuGet.VisualStudio.Internal.Contracts.LoadingStatus
NuGet.VisualStudio.Internal.Contracts.LoadingStatus.Cancelled = 1 -> NuGet.VisualStudio.Internal.Contracts.LoadingStatus
NuGet.VisualStudio.Internal.Contracts.LoadingStatus.ErrorOccurred = 2 -> NuGet.VisualStudio.Internal.Contracts.LoadingStatus
NuGet.VisualStudio.Internal.Contracts.LoadingStatus.Loading = 3 -> NuGet.VisualStudio.Internal.Contracts.LoadingStatus
NuGet.VisualStudio.Internal.Contracts.LoadingStatus.NoItemsFound = 4 -> NuGet.VisualStudio.Internal.Contracts.LoadingStatus
NuGet.VisualStudio.Internal.Contracts.LoadingStatus.NoMoreItems = 5 -> NuGet.VisualStudio.Internal.Contracts.LoadingStatus
NuGet.VisualStudio.Internal.Contracts.LoadingStatus.Ready = 6 -> NuGet.VisualStudio.Internal.Contracts.LoadingStatus
NuGet.VisualStudio.Internal.Contracts.LoadingStatus.Unknown = 0 -> NuGet.VisualStudio.Internal.Contracts.LoadingStatus
NuGet.VisualStudio.Internal.Contracts.PackageDeprecationMetadataContextInfo
NuGet.VisualStudio.Internal.Contracts.PackageDeprecationMetadataContextInfo.AlternatePackage.get -> NuGet.VisualStudio.Internal.Contracts.AlternatePackageMetadataContextInfo?
NuGet.VisualStudio.Internal.Contracts.PackageDeprecationMetadataContextInfo.Message.get -> string!
NuGet.VisualStudio.Internal.Contracts.PackageDeprecationMetadataContextInfo.PackageDeprecationMetadataContextInfo(string! message, System.Collections.Generic.IReadOnlyCollection<string!>? reasons, NuGet.VisualStudio.Internal.Contracts.AlternatePackageMetadataContextInfo? alternatePackageContextInfo) -> void
NuGet.VisualStudio.Internal.Contracts.PackageDeprecationMetadataContextInfo.Reasons.get -> System.Collections.Generic.IReadOnlyCollection<string!>?
NuGet.VisualStudio.Internal.Contracts.InstalledAndTransitivePackages
NuGet.VisualStudio.Internal.Contracts.InstalledAndTransitivePackages.InstalledAndTransitivePackages(System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.IPackageReferenceContextInfo!>? installedPackages, System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.IPackageReferenceContextInfo!>? transitivePackages) -> void
NuGet.VisualStudio.Internal.Contracts.InstalledAndTransitivePackages.InstalledPackages.get -> System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.IPackageReferenceContextInfo!>!
NuGet.VisualStudio.Internal.Contracts.InstalledAndTransitivePackages.TransitivePackages.get -> System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.IPackageReferenceContextInfo!>!
NuGet.VisualStudio.Internal.Contracts.PackageReferenceContextInfo.Framework.get -> NuGet.Frameworks.NuGetFramework?
NuGet.VisualStudio.Internal.Contracts.PackageReferenceContextInfo.Identity.get -> NuGet.Packaging.Core.PackageIdentity!
NuGet.VisualStudio.Internal.Contracts.PackageReferenceContextInfo.PackageReferenceContextInfo(NuGet.Packaging.Core.PackageIdentity! identity, NuGet.Frameworks.NuGetFramework? framework) -> void
NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo
NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.Authors.get -> string?
NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.DependencySets.get -> System.Collections.Generic.IReadOnlyCollection<NuGet.Packaging.PackageDependencyGroup!>?
NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.Description.get -> string?
NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.DownloadCount.get -> long?
NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.IconUrl.get -> System.Uri?
NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.Identity.get -> NuGet.Packaging.Core.PackageIdentity?
NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.IsListed.get -> bool
NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.IsRecommended.get -> bool
NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.LicenseMetadata.get -> NuGet.Packaging.LicenseMetadata?
NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.LicenseUrl.get -> System.Uri?
NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.Owners.get -> string?
NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.PackageDetailsUrl.get -> System.Uri?
NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.PackagePath.get -> string?
NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.PackageSearchMetadataContextInfo() -> void
NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.PrefixReserved.get -> bool
NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.ProjectUrl.get -> System.Uri?
NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.Published.get -> System.DateTimeOffset?
NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.RecommenderVersion.get -> (string! modelVersion, string! vsixVersion)?
NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.ReportAbuseUrl.get -> System.Uri?
NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.RequireLicenseAcceptance.get -> bool
NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.Summary.get -> string?
NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.Tags.get -> string?
NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.Title.get -> string?
NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.Vulnerabilities.get -> System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.PackageVulnerabilityMetadataContextInfo!>?
NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo
NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo.Clone() -> NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo!
NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo.Description.get -> string?
NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo.Equals(NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo! other) -> bool
NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo.IsEnabled.get -> bool
NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo.IsEnabled.set -> void
NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo.IsMachineWide.get -> bool
NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo.Name.get -> string!
NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo.Name.set -> void
NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo.OriginalHashCode.get -> int
NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo.PackageSourceContextInfo(string! source) -> void
NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo.PackageSourceContextInfo(string! source, string! name) -> void
NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo.PackageSourceContextInfo(string! source, string! name, bool isEnabled) -> void
NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo.Source.get -> string!
NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo.Source.set -> void
NuGet.VisualStudio.Internal.Contracts.PackageVulnerabilityMetadataContextInfo
NuGet.VisualStudio.Internal.Contracts.PackageVulnerabilityMetadataContextInfo.AdvisoryUrl.get -> System.Uri!
NuGet.VisualStudio.Internal.Contracts.PackageVulnerabilityMetadataContextInfo.PackageVulnerabilityMetadataContextInfo(System.Uri! advisoryUrl, int severity) -> void
NuGet.VisualStudio.Internal.Contracts.PackageVulnerabilityMetadataContextInfo.Severity.get -> int
NuGet.VisualStudio.Internal.Contracts.ProjectAction.Equals(NuGet.VisualStudio.Internal.Contracts.ProjectAction? other) -> bool
NuGet.VisualStudio.Internal.Contracts.ProjectAction.Id.get -> string!
NuGet.VisualStudio.Internal.Contracts.ProjectAction.ImplicitActions.get -> System.Collections.Generic.IReadOnlyList<NuGet.VisualStudio.Internal.Contracts.ImplicitProjectAction!>!
NuGet.VisualStudio.Internal.Contracts.ProjectAction.PackageIdentity.get -> NuGet.Packaging.Core.PackageIdentity!
NuGet.VisualStudio.Internal.Contracts.ProjectAction.ProjectAction(string! id, string! projectId, NuGet.Packaging.Core.PackageIdentity! packageIdentity, NuGet.PackageManagement.NuGetProjectActionType projectActionType, System.Collections.Generic.IReadOnlyList<NuGet.VisualStudio.Internal.Contracts.ImplicitProjectAction!>? implicitActions) -> void
NuGet.VisualStudio.Internal.Contracts.ProjectAction.ProjectId.get -> string!
NuGet.VisualStudio.Internal.Contracts.ProjectContextInfo.ProjectContextInfo(string! projectId, NuGet.ProjectModel.ProjectStyle projectStyle, NuGet.VisualStudio.Internal.Contracts.NuGetProjectKind projectKind) -> void
NuGet.VisualStudio.Internal.Contracts.ProjectContextInfo.ProjectId.get -> string!
NuGet.VisualStudio.Internal.Contracts.ProjectMetadataContextInfo.SupportedFrameworks.get -> System.Collections.Generic.IReadOnlyCollection<NuGet.Frameworks.NuGetFramework!>?
NuGet.VisualStudio.Internal.Contracts.RemoteError
NuGet.VisualStudio.Internal.Contracts.RemoteError.ActivityLogMessage.get -> string?
NuGet.VisualStudio.Internal.Contracts.RemoteError.LogMessage.get -> NuGet.Common.ILogMessage!
NuGet.VisualStudio.Internal.Contracts.RemoteError.LogMessages.get -> System.Collections.Generic.IReadOnlyList<NuGet.Common.ILogMessage!>?
NuGet.VisualStudio.Internal.Contracts.RemoteError.ProjectContextLogMessage.get -> string?
NuGet.VisualStudio.Internal.Contracts.RemoteError.RemoteError(string! typeName, NuGet.Common.ILogMessage! logMessage, System.Collections.Generic.IReadOnlyList<NuGet.Common.ILogMessage!>? logMessages) -> void
NuGet.VisualStudio.Internal.Contracts.RemoteError.RemoteError(string! typeName, NuGet.Common.ILogMessage! logMessage, System.Collections.Generic.IReadOnlyList<NuGet.Common.ILogMessage!>? logMessages, string? projectContextLogMessage, string? activityLogMessage) -> void
NuGet.VisualStudio.Internal.Contracts.RemoteError.TypeName.get -> string!
NuGet.VisualStudio.Internal.Contracts.RemoteErrorCode
NuGet.VisualStudio.Internal.Contracts.RemoteErrorCode.RemoteError = -31999 -> NuGet.VisualStudio.Internal.Contracts.RemoteErrorCode
NuGet.VisualStudio.Internal.Contracts.RemoteErrorUtility
NuGet.VisualStudio.Internal.Contracts.SearchResultContextInfo
NuGet.VisualStudio.Internal.Contracts.SearchResultContextInfo.HasMoreItems.get -> bool
NuGet.VisualStudio.Internal.Contracts.SearchResultContextInfo.OperationId.get -> System.Guid?
NuGet.VisualStudio.Internal.Contracts.SearchResultContextInfo.PackageSearchItems.get -> System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo!>!
NuGet.VisualStudio.Internal.Contracts.SearchResultContextInfo.SearchResultContextInfo() -> void
NuGet.VisualStudio.Internal.Contracts.SearchResultContextInfo.SearchResultContextInfo(System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo!>! packageSearchItems, System.Collections.Generic.IReadOnlyDictionary<string!, NuGet.VisualStudio.Internal.Contracts.LoadingStatus>! sourceLoadingStatus, bool hasMoreItems) -> void
NuGet.VisualStudio.Internal.Contracts.SearchResultContextInfo.SearchResultContextInfo(System.Collections.Generic.IReadOnlyCollection<NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo!>! packageSearchItems, System.Collections.Generic.IReadOnlyDictionary<string!, NuGet.VisualStudio.Internal.Contracts.LoadingStatus>! sourceLoadingStatus, bool hasMoreItems, System.Guid? operationId) -> void
NuGet.VisualStudio.Internal.Contracts.SearchResultContextInfo.SearchResultContextInfo(System.Guid? operationId) -> void
NuGet.VisualStudio.Internal.Contracts.SearchResultContextInfo.SourceLoadingStatus.get -> System.Collections.Generic.IReadOnlyDictionary<string!, NuGet.VisualStudio.Internal.Contracts.LoadingStatus>!
NuGet.VisualStudio.Internal.Contracts.VersionInfoContextInfo
NuGet.VisualStudio.Internal.Contracts.VersionInfoContextInfo.DownloadCount.get -> long?
NuGet.VisualStudio.Internal.Contracts.VersionInfoContextInfo.PackageDeprecationMetadata.get -> NuGet.VisualStudio.Internal.Contracts.PackageDeprecationMetadataContextInfo?
NuGet.VisualStudio.Internal.Contracts.VersionInfoContextInfo.PackageSearchMetadata.get -> NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo?
NuGet.VisualStudio.Internal.Contracts.VersionInfoContextInfo.Version.get -> NuGet.Versioning.NuGetVersion!
NuGet.VisualStudio.Internal.Contracts.VersionInfoContextInfo.VersionInfoContextInfo(NuGet.Versioning.NuGetVersion! version) -> void
NuGet.VisualStudio.Internal.Contracts.VersionInfoContextInfo.VersionInfoContextInfo(NuGet.Versioning.NuGetVersion! version, long? downloadCount) -> void
override NuGet.VisualStudio.Internal.Contracts.ImplicitProjectAction.Equals(object! obj) -> bool
override NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo.Equals(object! obj) -> bool
override NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo.GetHashCode() -> int
override NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo.ToString() -> string!
override NuGet.VisualStudio.Internal.Contracts.PackageVulnerabilityMetadataContextInfo.Equals(object! obj) -> bool
override NuGet.VisualStudio.Internal.Contracts.PackageVulnerabilityMetadataContextInfo.GetHashCode() -> int
override NuGet.VisualStudio.Internal.Contracts.ProjectAction.Equals(object! obj) -> bool
static NuGet.VisualStudio.Internal.Contracts.AlternatePackageMetadataContextInfo.Create(NuGet.Protocol.AlternatePackageMetadata! alternatePackageMetadata) -> NuGet.VisualStudio.Internal.Contracts.AlternatePackageMetadataContextInfo!
static NuGet.VisualStudio.Internal.Contracts.PackageDeprecationMetadataContextInfo.Create(NuGet.Protocol.PackageDeprecationMetadata! packageDeprecationMetadata) -> NuGet.VisualStudio.Internal.Contracts.PackageDeprecationMetadataContextInfo!
static NuGet.VisualStudio.Internal.Contracts.PackageReferenceContextInfo.Create(NuGet.Packaging.PackageReference! packageReference) -> NuGet.VisualStudio.Internal.Contracts.PackageReferenceContextInfo!
static NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.Create(NuGet.Protocol.Core.Types.IPackageSearchMetadata! packageSearchMetadata) -> NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo!
static NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo.Create(NuGet.Protocol.Core.Types.IPackageSearchMetadata! packageSearchMetadata, bool isRecommended, (string!, string!)? recommenderVersion) -> NuGet.VisualStudio.Internal.Contracts.PackageSearchMetadataContextInfo!
static NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo.Create(NuGet.Configuration.PackageSource! packageSource) -> NuGet.VisualStudio.Internal.Contracts.PackageSourceContextInfo!
static NuGet.VisualStudio.Internal.Contracts.ProjectContextInfo.CreateAsync(NuGet.ProjectManagement.NuGetProject! nugetProject, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.ValueTask<NuGet.VisualStudio.Internal.Contracts.IProjectContextInfo!>
static NuGet.VisualStudio.Internal.Contracts.ProjectMetadataContextInfo.Create(System.Collections.Generic.IReadOnlyDictionary<string!, object?>! projectMetadata) -> NuGet.VisualStudio.Internal.Contracts.ProjectMetadataContextInfo!
static NuGet.VisualStudio.Internal.Contracts.RemoteErrorUtility.ToRemoteError(System.Exception! exception) -> NuGet.VisualStudio.Internal.Contracts.RemoteError!
static NuGet.VisualStudio.Internal.Contracts.VersionInfoContextInfo.CreateAsync(NuGet.Protocol.Core.Types.VersionInfo! versionInfo) -> System.Threading.Tasks.ValueTask<NuGet.VisualStudio.Internal.Contracts.VersionInfoContextInfo!>
static readonly NuGet.VisualStudio.Internal.Contracts.NuGetServices.ProjectManagerService -> Microsoft.ServiceHub.Framework.ServiceRpcDescriptor!
static readonly NuGet.VisualStudio.Internal.Contracts.NuGetServices.ProjectUpgraderService -> Microsoft.ServiceHub.Framework.ServiceRpcDescriptor!
static readonly NuGet.VisualStudio.Internal.Contracts.NuGetServices.RemoteFileService -> Microsoft.ServiceHub.Framework.ServiceRpcDescriptor!
static readonly NuGet.VisualStudio.Internal.Contracts.NuGetServices.SearchService -> Microsoft.ServiceHub.Framework.ServiceRpcDescriptor!
static readonly NuGet.VisualStudio.Internal.Contracts.NuGetServices.SolutionManagerService -> Microsoft.ServiceHub.Framework.ServiceRpcDescriptor!
static readonly NuGet.VisualStudio.Internal.Contracts.NuGetServices.SolutionService -> Microsoft.ServiceHub.Framework.ServiceRpcDescriptor!
static readonly NuGet.VisualStudio.Internal.Contracts.NuGetServices.SourceProviderService -> Microsoft.ServiceHub.Framework.ServiceRpcDescriptor!
NuGet.VisualStudio.Internal.Contracts.INuGetSolutionManagerService
NuGet.VisualStudio.Internal.Contracts.INuGetSolutionService
NuGet.VisualStudio.Internal.Contracts.INuGetSourcesService
NuGet.VisualStudio.Internal.Contracts.IPackageReferenceContextInfo
NuGet.VisualStudio.Internal.Contracts.IPackageReferenceContextInfo.AllowedVersions.get -> NuGet.Versioning.VersionRange?
NuGet.VisualStudio.Internal.Contracts.IPackageReferenceContextInfo.IsAutoReferenced.get -> bool
NuGet.VisualStudio.Internal.Contracts.IPackageReferenceContextInfo.IsDevelopmentDependency.get -> bool
NuGet.VisualStudio.Internal.Contracts.IPackageReferenceContextInfo.IsUserInstalled.get -> bool
NuGet.VisualStudio.Internal.Contracts.IProjectContextInfo
NuGet.VisualStudio.Internal.Contracts.IProjectContextInfo.ProjectKind.get -> NuGet.VisualStudio.Internal.Contracts.NuGetProjectKind
NuGet.VisualStudio.Internal.Contracts.IProjectContextInfo.ProjectStyle.get -> NuGet.ProjectModel.ProjectStyle
NuGet.VisualStudio.Internal.Contracts.IProjectMetadataContextInfo
NuGet.VisualStudio.Internal.Contracts.IProjectMetadataContextInfo.FullPath.get -> string?
NuGet.VisualStudio.Internal.Contracts.IProjectMetadataContextInfo.Name.get -> string?
NuGet.VisualStudio.Internal.Contracts.IProjectMetadataContextInfo.ProjectId.get -> string?
NuGet.VisualStudio.Internal.Contracts.IProjectMetadataContextInfo.TargetFramework.get -> NuGet.Frameworks.NuGetFramework?
NuGet.VisualStudio.Internal.Contracts.IProjectMetadataContextInfo.UniqueName.get -> string?
NuGet.VisualStudio.Internal.Contracts.ImplicitProjectAction
NuGet.VisualStudio.Internal.Contracts.ImplicitProjectAction.ProjectActionType.get -> NuGet.PackageManagement.NuGetProjectActionType
NuGet.VisualStudio.Internal.Contracts.NuGetProjectKind
NuGet.VisualStudio.Internal.Contracts.NuGetProjectKind.PackageReference = 2 -> NuGet.VisualStudio.Internal.Contracts.NuGetProjectKind
NuGet.VisualStudio.Internal.Contracts.NuGetProjectKind.PackagesConfig = 1 -> NuGet.VisualStudio.Internal.Contracts.NuGetProjectKind
NuGet.VisualStudio.Internal.Contracts.NuGetProjectKind.ProjectK = 3 -> NuGet.VisualStudio.Internal.Contracts.NuGetProjectKind
NuGet.VisualStudio.Internal.Contracts.NuGetProjectKind.Unknown = 0 -> NuGet.VisualStudio.Internal.Contracts.NuGetProjectKind
NuGet.VisualStudio.Internal.Contracts.NuGetServices
NuGet.VisualStudio.Internal.Contracts.PackageReferenceContextInfo
NuGet.VisualStudio.Internal.Contracts.PackageReferenceContextInfo.AllowedVersions.get -> NuGet.Versioning.VersionRange?
NuGet.VisualStudio.Internal.Contracts.PackageReferenceContextInfo.IsAutoReferenced.get -> bool
NuGet.VisualStudio.Internal.Contracts.PackageReferenceContextInfo.IsDevelopmentDependency.get -> bool
NuGet.VisualStudio.Internal.Contracts.PackageReferenceContextInfo.IsUserInstalled.get -> bool
NuGet.VisualStudio.Internal.Contracts.ProjectAction
NuGet.VisualStudio.Internal.Contracts.ProjectAction.ProjectActionType.get -> NuGet.PackageManagement.NuGetProjectActionType
NuGet.VisualStudio.Internal.Contracts.ProjectContextInfo
NuGet.VisualStudio.Internal.Contracts.ProjectContextInfo.ProjectKind.get -> NuGet.VisualStudio.Internal.Contracts.NuGetProjectKind
NuGet.VisualStudio.Internal.Contracts.ProjectContextInfo.ProjectStyle.get -> NuGet.ProjectModel.ProjectStyle
NuGet.VisualStudio.Internal.Contracts.ProjectMetadataContextInfo
NuGet.VisualStudio.Internal.Contracts.ProjectMetadataContextInfo.FullPath.get -> string?
NuGet.VisualStudio.Internal.Contracts.ProjectMetadataContextInfo.Name.get -> string?
NuGet.VisualStudio.Internal.Contracts.ProjectMetadataContextInfo.ProjectId.get -> string?
NuGet.VisualStudio.Internal.Contracts.ProjectMetadataContextInfo.TargetFramework.get -> NuGet.Frameworks.NuGetFramework?
NuGet.VisualStudio.Internal.Contracts.ProjectMetadataContextInfo.UniqueName.get -> string?
override NuGet.VisualStudio.Internal.Contracts.ImplicitProjectAction.GetHashCode() -> int
override NuGet.VisualStudio.Internal.Contracts.ProjectAction.GetHashCode() -> int
